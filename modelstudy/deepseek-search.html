<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>寒梦的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/hmblog/logo.png">
    <meta name="description" content="宝剑锋从磨砺出，梅花香自苦寒来。">
    
    <link rel="preload" href="/hmblog/assets/css/0.styles.e7d53aa5.css" as="style"><link rel="preload" href="/hmblog/assets/js/app.252ae38c.js" as="script"><link rel="preload" href="/hmblog/assets/js/7.5041dce4.js" as="script"><link rel="preload" href="/hmblog/assets/js/2.79670d2b.js" as="script"><link rel="preload" href="/hmblog/assets/js/1.1d6abb18.js" as="script"><link rel="preload" href="/hmblog/assets/js/72.194abe8d.js" as="script"><link rel="preload" href="/hmblog/assets/js/34.b26cede8.js" as="script"><link rel="prefetch" href="/hmblog/assets/js/10.63d0ad8f.js"><link rel="prefetch" href="/hmblog/assets/js/100.5613e6ba.js"><link rel="prefetch" href="/hmblog/assets/js/101.b8eb0459.js"><link rel="prefetch" href="/hmblog/assets/js/102.40868c51.js"><link rel="prefetch" href="/hmblog/assets/js/103.1f40d097.js"><link rel="prefetch" href="/hmblog/assets/js/104.4e73c56a.js"><link rel="prefetch" href="/hmblog/assets/js/105.cb525ef5.js"><link rel="prefetch" href="/hmblog/assets/js/106.252f49ca.js"><link rel="prefetch" href="/hmblog/assets/js/107.91d170e8.js"><link rel="prefetch" href="/hmblog/assets/js/108.8a514186.js"><link rel="prefetch" href="/hmblog/assets/js/109.f15844d7.js"><link rel="prefetch" href="/hmblog/assets/js/11.08937b90.js"><link rel="prefetch" href="/hmblog/assets/js/110.a0e27b36.js"><link rel="prefetch" href="/hmblog/assets/js/111.1c542559.js"><link rel="prefetch" href="/hmblog/assets/js/112.5fa57e84.js"><link rel="prefetch" href="/hmblog/assets/js/113.bfbfcd5a.js"><link rel="prefetch" href="/hmblog/assets/js/114.2e526e4d.js"><link rel="prefetch" href="/hmblog/assets/js/115.221e2f65.js"><link rel="prefetch" href="/hmblog/assets/js/116.a7726179.js"><link rel="prefetch" href="/hmblog/assets/js/117.22075f73.js"><link rel="prefetch" href="/hmblog/assets/js/118.459f31e3.js"><link rel="prefetch" href="/hmblog/assets/js/119.f7a33a09.js"><link rel="prefetch" href="/hmblog/assets/js/120.8b58a340.js"><link rel="prefetch" href="/hmblog/assets/js/121.277e1f1e.js"><link rel="prefetch" href="/hmblog/assets/js/122.ec3ae934.js"><link rel="prefetch" href="/hmblog/assets/js/123.514ade54.js"><link rel="prefetch" href="/hmblog/assets/js/124.6b6c2b7d.js"><link rel="prefetch" href="/hmblog/assets/js/125.a7fb1fbe.js"><link rel="prefetch" href="/hmblog/assets/js/126.b5ef252a.js"><link rel="prefetch" href="/hmblog/assets/js/127.d8121d6d.js"><link rel="prefetch" href="/hmblog/assets/js/128.40963707.js"><link rel="prefetch" href="/hmblog/assets/js/129.bf256481.js"><link rel="prefetch" href="/hmblog/assets/js/130.0031ec91.js"><link rel="prefetch" href="/hmblog/assets/js/131.4fe99cc5.js"><link rel="prefetch" href="/hmblog/assets/js/132.fcf1a74b.js"><link rel="prefetch" href="/hmblog/assets/js/133.ff8e24a1.js"><link rel="prefetch" href="/hmblog/assets/js/134.db2d31f5.js"><link rel="prefetch" href="/hmblog/assets/js/135.b152d9b0.js"><link rel="prefetch" href="/hmblog/assets/js/136.936be57e.js"><link rel="prefetch" href="/hmblog/assets/js/137.48f9d2b5.js"><link rel="prefetch" href="/hmblog/assets/js/138.3bdb70b7.js"><link rel="prefetch" href="/hmblog/assets/js/139.2c511f09.js"><link rel="prefetch" href="/hmblog/assets/js/14.0ac4aea5.js"><link rel="prefetch" href="/hmblog/assets/js/140.5f00d305.js"><link rel="prefetch" href="/hmblog/assets/js/141.41c9f925.js"><link rel="prefetch" href="/hmblog/assets/js/142.b37e8f1d.js"><link rel="prefetch" href="/hmblog/assets/js/143.20c71a9e.js"><link rel="prefetch" href="/hmblog/assets/js/144.17cece65.js"><link rel="prefetch" href="/hmblog/assets/js/145.978e7516.js"><link rel="prefetch" href="/hmblog/assets/js/146.94bdfed5.js"><link rel="prefetch" href="/hmblog/assets/js/147.f9c95b0c.js"><link rel="prefetch" href="/hmblog/assets/js/148.355cbcf5.js"><link rel="prefetch" href="/hmblog/assets/js/149.b1e46aaf.js"><link rel="prefetch" href="/hmblog/assets/js/15.2cac15c3.js"><link rel="prefetch" href="/hmblog/assets/js/150.b5a35472.js"><link rel="prefetch" href="/hmblog/assets/js/151.d309c32e.js"><link rel="prefetch" href="/hmblog/assets/js/152.fb9a950d.js"><link rel="prefetch" href="/hmblog/assets/js/153.c231397c.js"><link rel="prefetch" href="/hmblog/assets/js/154.2c76a2e9.js"><link rel="prefetch" href="/hmblog/assets/js/155.ad43ee17.js"><link rel="prefetch" href="/hmblog/assets/js/156.b0fe3a29.js"><link rel="prefetch" href="/hmblog/assets/js/157.d085315f.js"><link rel="prefetch" href="/hmblog/assets/js/158.9f11fbf4.js"><link rel="prefetch" href="/hmblog/assets/js/159.178d8a8a.js"><link rel="prefetch" href="/hmblog/assets/js/16.41c97ec9.js"><link rel="prefetch" href="/hmblog/assets/js/160.e6a3b7e3.js"><link rel="prefetch" href="/hmblog/assets/js/161.b897eab6.js"><link rel="prefetch" href="/hmblog/assets/js/162.54114dbe.js"><link rel="prefetch" href="/hmblog/assets/js/163.156fce2c.js"><link rel="prefetch" href="/hmblog/assets/js/164.e44a107d.js"><link rel="prefetch" href="/hmblog/assets/js/165.50843d9b.js"><link rel="prefetch" href="/hmblog/assets/js/166.51cc166e.js"><link rel="prefetch" href="/hmblog/assets/js/167.1e241fd0.js"><link rel="prefetch" href="/hmblog/assets/js/168.1f0c33e5.js"><link rel="prefetch" href="/hmblog/assets/js/169.62546341.js"><link rel="prefetch" href="/hmblog/assets/js/17.29a60e10.js"><link rel="prefetch" href="/hmblog/assets/js/170.3e1d4983.js"><link rel="prefetch" href="/hmblog/assets/js/171.5975c042.js"><link rel="prefetch" href="/hmblog/assets/js/172.a172fe4f.js"><link rel="prefetch" href="/hmblog/assets/js/173.b7f30ce1.js"><link rel="prefetch" href="/hmblog/assets/js/174.cf213ee7.js"><link rel="prefetch" href="/hmblog/assets/js/175.fead80ee.js"><link rel="prefetch" href="/hmblog/assets/js/176.d8597cdf.js"><link rel="prefetch" href="/hmblog/assets/js/177.72596ae1.js"><link rel="prefetch" href="/hmblog/assets/js/178.d0c48b18.js"><link rel="prefetch" href="/hmblog/assets/js/179.d5c444fc.js"><link rel="prefetch" href="/hmblog/assets/js/18.27fd2b83.js"><link rel="prefetch" href="/hmblog/assets/js/180.2f29e719.js"><link rel="prefetch" href="/hmblog/assets/js/181.bb359567.js"><link rel="prefetch" href="/hmblog/assets/js/182.e140022f.js"><link rel="prefetch" href="/hmblog/assets/js/183.88c88131.js"><link rel="prefetch" href="/hmblog/assets/js/184.7dafb863.js"><link rel="prefetch" href="/hmblog/assets/js/185.6ee6fee4.js"><link rel="prefetch" href="/hmblog/assets/js/186.a58d3091.js"><link rel="prefetch" href="/hmblog/assets/js/187.06e4ac29.js"><link rel="prefetch" href="/hmblog/assets/js/188.4f58b234.js"><link rel="prefetch" href="/hmblog/assets/js/189.b7fcaad5.js"><link rel="prefetch" href="/hmblog/assets/js/19.e7351a57.js"><link rel="prefetch" href="/hmblog/assets/js/190.1ee24f3f.js"><link rel="prefetch" href="/hmblog/assets/js/191.71d1ed44.js"><link rel="prefetch" href="/hmblog/assets/js/192.8e13dbd5.js"><link rel="prefetch" href="/hmblog/assets/js/193.6ffdbe3c.js"><link rel="prefetch" href="/hmblog/assets/js/194.f3092777.js"><link rel="prefetch" href="/hmblog/assets/js/195.61518c26.js"><link rel="prefetch" href="/hmblog/assets/js/196.4749bfe4.js"><link rel="prefetch" href="/hmblog/assets/js/197.02f293f5.js"><link rel="prefetch" href="/hmblog/assets/js/198.66d067f8.js"><link rel="prefetch" href="/hmblog/assets/js/199.e713626b.js"><link rel="prefetch" href="/hmblog/assets/js/20.20706f57.js"><link rel="prefetch" href="/hmblog/assets/js/200.a0428ce1.js"><link rel="prefetch" href="/hmblog/assets/js/201.10f94064.js"><link rel="prefetch" href="/hmblog/assets/js/202.85104aab.js"><link rel="prefetch" href="/hmblog/assets/js/203.610baaad.js"><link rel="prefetch" href="/hmblog/assets/js/204.d7a56285.js"><link rel="prefetch" href="/hmblog/assets/js/205.e9c3d532.js"><link rel="prefetch" href="/hmblog/assets/js/21.0feb36e8.js"><link rel="prefetch" href="/hmblog/assets/js/22.40bc0c74.js"><link rel="prefetch" href="/hmblog/assets/js/23.3f7042f4.js"><link rel="prefetch" href="/hmblog/assets/js/24.ed563c46.js"><link rel="prefetch" href="/hmblog/assets/js/25.ac1b0e72.js"><link rel="prefetch" href="/hmblog/assets/js/26.683143d5.js"><link rel="prefetch" href="/hmblog/assets/js/27.f0066995.js"><link rel="prefetch" href="/hmblog/assets/js/28.d8aebbf6.js"><link rel="prefetch" href="/hmblog/assets/js/29.411fc063.js"><link rel="prefetch" href="/hmblog/assets/js/3.1300dadf.js"><link rel="prefetch" href="/hmblog/assets/js/30.2f75779a.js"><link rel="prefetch" href="/hmblog/assets/js/31.a195dbd7.js"><link rel="prefetch" href="/hmblog/assets/js/32.a4da846d.js"><link rel="prefetch" href="/hmblog/assets/js/33.cbaf45e6.js"><link rel="prefetch" href="/hmblog/assets/js/35.b991843f.js"><link rel="prefetch" href="/hmblog/assets/js/36.ae8fa883.js"><link rel="prefetch" href="/hmblog/assets/js/37.dc5b3f34.js"><link rel="prefetch" href="/hmblog/assets/js/38.2acfc275.js"><link rel="prefetch" href="/hmblog/assets/js/39.c2783769.js"><link rel="prefetch" href="/hmblog/assets/js/4.a36b649a.js"><link rel="prefetch" href="/hmblog/assets/js/40.b6871f20.js"><link rel="prefetch" href="/hmblog/assets/js/41.b9269303.js"><link rel="prefetch" href="/hmblog/assets/js/42.e8164e0c.js"><link rel="prefetch" href="/hmblog/assets/js/43.70ef46e5.js"><link rel="prefetch" href="/hmblog/assets/js/44.9331e0b2.js"><link rel="prefetch" href="/hmblog/assets/js/45.5feef070.js"><link rel="prefetch" href="/hmblog/assets/js/46.cbe15db5.js"><link rel="prefetch" href="/hmblog/assets/js/47.13b797de.js"><link rel="prefetch" href="/hmblog/assets/js/48.7030d96f.js"><link rel="prefetch" href="/hmblog/assets/js/49.21360ca4.js"><link rel="prefetch" href="/hmblog/assets/js/5.ade88313.js"><link rel="prefetch" href="/hmblog/assets/js/50.2278b4f1.js"><link rel="prefetch" href="/hmblog/assets/js/51.dfcce7fa.js"><link rel="prefetch" href="/hmblog/assets/js/52.411e6b71.js"><link rel="prefetch" href="/hmblog/assets/js/53.9f14e863.js"><link rel="prefetch" href="/hmblog/assets/js/54.ae21c7a9.js"><link rel="prefetch" href="/hmblog/assets/js/55.0b0dbecf.js"><link rel="prefetch" href="/hmblog/assets/js/56.2b3b9c9e.js"><link rel="prefetch" href="/hmblog/assets/js/57.eb5c4857.js"><link rel="prefetch" href="/hmblog/assets/js/58.5bb642a4.js"><link rel="prefetch" href="/hmblog/assets/js/59.310d4748.js"><link rel="prefetch" href="/hmblog/assets/js/6.3551780c.js"><link rel="prefetch" href="/hmblog/assets/js/60.43f50fd6.js"><link rel="prefetch" href="/hmblog/assets/js/61.bf7359ad.js"><link rel="prefetch" href="/hmblog/assets/js/62.bbc1a63f.js"><link rel="prefetch" href="/hmblog/assets/js/63.4f514386.js"><link rel="prefetch" href="/hmblog/assets/js/64.75891b13.js"><link rel="prefetch" href="/hmblog/assets/js/65.c594c5f0.js"><link rel="prefetch" href="/hmblog/assets/js/66.3b2e8434.js"><link rel="prefetch" href="/hmblog/assets/js/67.d21dd018.js"><link rel="prefetch" href="/hmblog/assets/js/68.3a1952eb.js"><link rel="prefetch" href="/hmblog/assets/js/69.4a9f3de5.js"><link rel="prefetch" href="/hmblog/assets/js/70.79851ca4.js"><link rel="prefetch" href="/hmblog/assets/js/71.6b0dd684.js"><link rel="prefetch" href="/hmblog/assets/js/73.57d7aacb.js"><link rel="prefetch" href="/hmblog/assets/js/74.21d325f3.js"><link rel="prefetch" href="/hmblog/assets/js/75.5db4d81f.js"><link rel="prefetch" href="/hmblog/assets/js/76.f614fd28.js"><link rel="prefetch" href="/hmblog/assets/js/77.5fb8fe74.js"><link rel="prefetch" href="/hmblog/assets/js/78.cbf908d6.js"><link rel="prefetch" href="/hmblog/assets/js/79.16b13beb.js"><link rel="prefetch" href="/hmblog/assets/js/8.1407b990.js"><link rel="prefetch" href="/hmblog/assets/js/80.b7f99985.js"><link rel="prefetch" href="/hmblog/assets/js/81.c5c33a8c.js"><link rel="prefetch" href="/hmblog/assets/js/82.1bb32711.js"><link rel="prefetch" href="/hmblog/assets/js/83.0126cbfc.js"><link rel="prefetch" href="/hmblog/assets/js/84.bf184586.js"><link rel="prefetch" href="/hmblog/assets/js/85.ed882d02.js"><link rel="prefetch" href="/hmblog/assets/js/86.00a6c023.js"><link rel="prefetch" href="/hmblog/assets/js/87.19ec978b.js"><link rel="prefetch" href="/hmblog/assets/js/88.da0b0fce.js"><link rel="prefetch" href="/hmblog/assets/js/89.1b3f0dc7.js"><link rel="prefetch" href="/hmblog/assets/js/9.7b6dd5b4.js"><link rel="prefetch" href="/hmblog/assets/js/90.5b446b43.js"><link rel="prefetch" href="/hmblog/assets/js/91.b7568648.js"><link rel="prefetch" href="/hmblog/assets/js/92.41c96c2a.js"><link rel="prefetch" href="/hmblog/assets/js/93.c88897c2.js"><link rel="prefetch" href="/hmblog/assets/js/94.1b8ca6ee.js"><link rel="prefetch" href="/hmblog/assets/js/95.ad838784.js"><link rel="prefetch" href="/hmblog/assets/js/96.8d479f68.js"><link rel="prefetch" href="/hmblog/assets/js/97.50826eb1.js"><link rel="prefetch" href="/hmblog/assets/js/98.bdb338cb.js"><link rel="prefetch" href="/hmblog/assets/js/99.4842effa.js"><link rel="prefetch" href="/hmblog/assets/js/vendors~docsearch.e480d9b8.js">
    <link rel="stylesheet" href="/hmblog/assets/css/0.styles.e7d53aa5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>寒梦的博客</h3> <p class="description" data-v-59e6cb88>宝剑锋从磨砺出，梅花香自苦寒来。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>寒梦</span>
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hmblog/" class="home-link router-link-active"><!----> <span class="site-name">寒梦的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Python
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/basic.html" class="nav-link"><i class="undefined"></i>
  Python 基础
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/builtin-function.html" class="nav-link"><i class="undefined"></i>
  Python 内置函数的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/function.html" class="nav-link"><i class="undefined"></i>
  Python 函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/numpy.html" class="nav-link"><i class="undefined"></i>
  Python numpy
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/array-operation.html" class="nav-link"><i class="undefined"></i>
  Python 数组操作
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-library.html" class="nav-link"><i class="undefined"></i>
  Python 常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/string-function.html" class="nav-link"><i class="undefined"></i>
  Python 字符串函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-pip-install.html" class="nav-link"><i class="undefined"></i>
  pip 那些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/line-continue.html" class="nav-link"><i class="undefined"></i>
  Python 中的行续行符
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/pandas-study.html" class="nav-link"><i class="undefined"></i>
  pandas 库的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-important.html" class="nav-link"><i class="undefined"></i>
  python 几个常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-collect.html" class="nav-link"><i class="undefined"></i>
  python 汇总
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-web.html" class="nav-link"><i class="undefined"></i>
  Python Web框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      大模型应用开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/transformer-basic.html" class="nav-link"><i class="undefined"></i>
  Transformer 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-knowledge.html" class="nav-link"><i class="undefined"></i>
  大模型基础概念
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/prompts.html" class="nav-link"><i class="undefined"></i>
  提示词工程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rag.html" class="nav-link"><i class="undefined"></i>
  检索增强生成RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/data-chunk.html" class="nav-link"><i class="undefined"></i>
  数据分块
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-langchain-rag.html" class="nav-link"><i class="undefined"></i>
  Langchain &amp; RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag.html" class="nav-link"><i class="undefined"></i>
  RAG 知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag-pain.html" class="nav-link"><i class="undefined"></i>
  RAG 痛点分析
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-study.html" class="nav-link"><i class="undefined"></i>
  Langchain use
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vector-database.html" class="nav-link"><i class="undefined"></i>
  向量数据库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/first-model-project.html" class="nav-link"><i class="undefined"></i>
  RAG 项目实战
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-function-calling.html" class="nav-link"><i class="undefined"></i>
  Function Calling
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/agent.html" class="nav-link"><i class="undefined"></i>
  Agent 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-prompt.html" class="nav-link"><i class="undefined"></i>
  LangChain Prompt的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-english.html" class="nav-link"><i class="undefined"></i>
  大模型相关的英语词汇
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rl.html" class="nav-link"><i class="undefined"></i>
  强化学习
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/peft.html" class="nav-link"><i class="undefined"></i>
  大模型微调
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/quantization.html" class="nav-link"><i class="undefined"></i>
  模型量化
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vLLM-intro.html" class="nav-link"><i class="undefined"></i>
  vLLM
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-pytorch.html" class="nav-link"><i class="undefined"></i>
  PyTorch Dataset VS Huggingface Dataset
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-train-process.html" class="nav-link"><i class="undefined"></i>
  从零训练一个大模型的完整流程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-aigc.html" class="nav-link"><i class="undefined"></i>
  生成式AI
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      强大的MCP
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-knowledge.html" class="nav-link"><i class="undefined"></i>
  MCP 是什么
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/ide-mcp-server.html" class="nav-link"><i class="undefined"></i>
  IDE 使用MCP Server实操
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-tool.html" class="nav-link"><i class="undefined"></i>
  常见的MCP工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      算法
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/sort.html" class="nav-link"><i class="undefined"></i>
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/double-pointer.html" class="nav-link"><i class="undefined"></i>
  双指针算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-tree.html" class="nav-link"><i class="undefined"></i>
  二叉树
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/receive-rain.html" class="nav-link"><i class="undefined"></i>
  接雨水
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/dynamic-plan.html" class="nav-link"><i class="undefined"></i>
  动态规划
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/greedy.html" class="nav-link"><i class="undefined"></i>
  贪心算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/longasc-sequence.html" class="nav-link"><i class="undefined"></i>
  最长上升子序列
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-search.html" class="nav-link"><i class="undefined"></i>
  二分查找
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/reverse-list.html" class="nav-link"><i class="undefined"></i>
  反转链表
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/del-single-list.html" class="nav-link"><i class="undefined"></i>
  删除单链表-集合
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/other.html" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/compare-al.html" class="nav-link"><i class="undefined"></i>
  m个数，最多用n次比较，找出第二大的数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/effect-bracket.html" class="nav-link"><i class="undefined"></i>
  有效的括号
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/other/ai-agent.html" class="nav-link"><i class="undefined"></i>
  AI项目
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/conda.html" class="nav-link"><i class="undefined"></i>
  Conda 使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/using-packages.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/pytorch-know.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-learn.html" class="nav-link"><i class="undefined"></i>
  transformer库中那些常用函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-collect.html" class="nav-link"><i class="undefined"></i>
  transformer库学习哪些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-1.html" class="nav-link"><i class="undefined"></i>
  transformer 使用T5模型
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-2.html" class="nav-link"><i class="undefined"></i>
  torch DataLoader
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-3.html" class="nav-link"><i class="undefined"></i>
  设置随机种子
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/model-refrence.html" class="nav-link"><i class="undefined"></i>
  优秀的参考文档
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/git-operate.html" class="nav-link"><i class="undefined"></i>
  git 操作命令
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/fine-tuning-adapters.html" class="nav-link"><i class="undefined"></i>
  PEFT 之Adapters
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/swanLab-info.html" class="nav-link"><i class="undefined"></i>
  深度学习之SwanLab
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/lora-0-1.html" class="nav-link"><i class="undefined"></i>
  从0到1手撕LoRA类
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/rag-question-compare.html" class="nav-link"><i class="undefined"></i>
  临时
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hmyjyghh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/ghh_" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/cool-62-29/columns" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://hmyjyghh.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <h3 class="name" data-v-1fad0c41>
    寒梦
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>129</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Python
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/basic.html" class="nav-link"><i class="undefined"></i>
  Python 基础
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/builtin-function.html" class="nav-link"><i class="undefined"></i>
  Python 内置函数的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/function.html" class="nav-link"><i class="undefined"></i>
  Python 函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/numpy.html" class="nav-link"><i class="undefined"></i>
  Python numpy
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/array-operation.html" class="nav-link"><i class="undefined"></i>
  Python 数组操作
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-library.html" class="nav-link"><i class="undefined"></i>
  Python 常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/string-function.html" class="nav-link"><i class="undefined"></i>
  Python 字符串函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-pip-install.html" class="nav-link"><i class="undefined"></i>
  pip 那些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/line-continue.html" class="nav-link"><i class="undefined"></i>
  Python 中的行续行符
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/pandas-study.html" class="nav-link"><i class="undefined"></i>
  pandas 库的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-important.html" class="nav-link"><i class="undefined"></i>
  python 几个常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-collect.html" class="nav-link"><i class="undefined"></i>
  python 汇总
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-web.html" class="nav-link"><i class="undefined"></i>
  Python Web框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      大模型应用开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/transformer-basic.html" class="nav-link"><i class="undefined"></i>
  Transformer 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-knowledge.html" class="nav-link"><i class="undefined"></i>
  大模型基础概念
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/prompts.html" class="nav-link"><i class="undefined"></i>
  提示词工程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rag.html" class="nav-link"><i class="undefined"></i>
  检索增强生成RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/data-chunk.html" class="nav-link"><i class="undefined"></i>
  数据分块
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-langchain-rag.html" class="nav-link"><i class="undefined"></i>
  Langchain &amp; RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag.html" class="nav-link"><i class="undefined"></i>
  RAG 知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag-pain.html" class="nav-link"><i class="undefined"></i>
  RAG 痛点分析
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-study.html" class="nav-link"><i class="undefined"></i>
  Langchain use
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vector-database.html" class="nav-link"><i class="undefined"></i>
  向量数据库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/first-model-project.html" class="nav-link"><i class="undefined"></i>
  RAG 项目实战
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-function-calling.html" class="nav-link"><i class="undefined"></i>
  Function Calling
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/agent.html" class="nav-link"><i class="undefined"></i>
  Agent 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-prompt.html" class="nav-link"><i class="undefined"></i>
  LangChain Prompt的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-english.html" class="nav-link"><i class="undefined"></i>
  大模型相关的英语词汇
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rl.html" class="nav-link"><i class="undefined"></i>
  强化学习
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/peft.html" class="nav-link"><i class="undefined"></i>
  大模型微调
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/quantization.html" class="nav-link"><i class="undefined"></i>
  模型量化
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vLLM-intro.html" class="nav-link"><i class="undefined"></i>
  vLLM
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-pytorch.html" class="nav-link"><i class="undefined"></i>
  PyTorch Dataset VS Huggingface Dataset
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-train-process.html" class="nav-link"><i class="undefined"></i>
  从零训练一个大模型的完整流程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-aigc.html" class="nav-link"><i class="undefined"></i>
  生成式AI
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      强大的MCP
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-knowledge.html" class="nav-link"><i class="undefined"></i>
  MCP 是什么
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/ide-mcp-server.html" class="nav-link"><i class="undefined"></i>
  IDE 使用MCP Server实操
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-tool.html" class="nav-link"><i class="undefined"></i>
  常见的MCP工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      算法
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/sort.html" class="nav-link"><i class="undefined"></i>
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/double-pointer.html" class="nav-link"><i class="undefined"></i>
  双指针算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-tree.html" class="nav-link"><i class="undefined"></i>
  二叉树
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/receive-rain.html" class="nav-link"><i class="undefined"></i>
  接雨水
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/dynamic-plan.html" class="nav-link"><i class="undefined"></i>
  动态规划
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/greedy.html" class="nav-link"><i class="undefined"></i>
  贪心算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/longasc-sequence.html" class="nav-link"><i class="undefined"></i>
  最长上升子序列
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-search.html" class="nav-link"><i class="undefined"></i>
  二分查找
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/reverse-list.html" class="nav-link"><i class="undefined"></i>
  反转链表
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/del-single-list.html" class="nav-link"><i class="undefined"></i>
  删除单链表-集合
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/other.html" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/compare-al.html" class="nav-link"><i class="undefined"></i>
  m个数，最多用n次比较，找出第二大的数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/effect-bracket.html" class="nav-link"><i class="undefined"></i>
  有效的括号
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/other/ai-agent.html" class="nav-link"><i class="undefined"></i>
  AI项目
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/conda.html" class="nav-link"><i class="undefined"></i>
  Conda 使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/using-packages.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/pytorch-know.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-learn.html" class="nav-link"><i class="undefined"></i>
  transformer库中那些常用函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-collect.html" class="nav-link"><i class="undefined"></i>
  transformer库学习哪些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-1.html" class="nav-link"><i class="undefined"></i>
  transformer 使用T5模型
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-2.html" class="nav-link"><i class="undefined"></i>
  torch DataLoader
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-3.html" class="nav-link"><i class="undefined"></i>
  设置随机种子
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/model-refrence.html" class="nav-link"><i class="undefined"></i>
  优秀的参考文档
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/git-operate.html" class="nav-link"><i class="undefined"></i>
  git 操作命令
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/fine-tuning-adapters.html" class="nav-link"><i class="undefined"></i>
  PEFT 之Adapters
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/swanLab-info.html" class="nav-link"><i class="undefined"></i>
  深度学习之SwanLab
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/lora-0-1.html" class="nav-link"><i class="undefined"></i>
  从0到1手撕LoRA类
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/rag-question-compare.html" class="nav-link"><i class="undefined"></i>
  临时
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hmyjyghh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/ghh_" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/cool-62-29/columns" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://hmyjyghh.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>寒梦</span>
          
        <!---->
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title"></h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>寒梦</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><ul><li><strong>Prompt Design（提示设计）</strong>：<strong>学习如何向模型“提问”</strong>。你不动模型本身，只优化你的指令。</li> <li><strong>Prompt Tuning（提示微调）</strong>：<strong>教模型学会一种新的“内部提问方式”</strong>。你给模型一些可以学习的“软提示”，而不是修改它的核心知识。</li> <li><strong>Fine-Tuning（微调，特指全量微调）</strong>：<strong>给模型“回炉重造”，学习新专业</strong>。你直接修改模型的核心参数，让它适应新任务。</li></ul> <p>下面我们进行详细的分解和对比。</p> <hr> <h3 id="_1-prompt-design-提示设计-提示工程"><a href="#_1-prompt-design-提示设计-提示工程" class="header-anchor">#</a> 1. Prompt Design（提示设计 / 提示工程）</h3> <ul><li><strong>核心思想</strong>：<strong>不修改模型任何参数</strong>。通过精心设计和优化输入给模型的文本（即提示），来引导模型生成我们想要的输出。</li> <li><strong>怎么做</strong>：你就像一位沟通专家，不断尝试不同的措辞、格式、例子（少样本学习）来“哄骗”模型做出最佳表现。</li> <li><strong>参数更新</strong>：<strong>无</strong>。模型参数完全冻结。</li> <li><strong>比喻</strong>：你有一本百科全书（模型），你想知道“珠穆朗玛峰的高度”。<strong>Prompt Design</strong> 就是研究如何问得最好：“珠穆朗玛峰多高？”、“请告诉我世界最高峰的海拔？”、“Q：珠穆朗玛峰高度？ A：”。</li> <li><strong>优点</strong>：
<ul><li><strong>零成本</strong>：不需要计算资源训练。</li> <li><strong>快速迭代</strong>：立即看到修改提示后的效果。</li> <li><strong>通用性</strong>：适用于所有黑盒API（如ChatGPT）。</li></ul></li> <li><strong>缺点</strong>：
<ul><li><strong>效果受限</strong>：性能上限受限于基础模型的能力。</li> <li><strong>不稳定</strong>：提示的微小变化可能导致输出巨大差异。</li> <li><strong>提示长度</strong>：加入大量示例（少样本学习）会消耗大量上下文窗口。</li></ul></li></ul> <hr> <h3 id="_2-prompt-tuning-提示微调"><a href="#_2-prompt-tuning-提示微调" class="header-anchor">#</a> 2. Prompt Tuning（提示微调）</h3> <ul><li><strong>核心思想</strong>：一种<strong>参数高效微调</strong> 方法。它<strong>不修改原始模型的预训练参数</strong>，而是在模型的输入序列前加入一小段<strong>可训练的“软提示”向量</strong>，然后在特定任务的数据集上<strong>只训练这些向量</strong>。</li> <li><strong>怎么做</strong>：
<ol><li>在输入文本的嵌入向量前，拼接一段随机初始化的向量（例如10个 token 长度的向量）。</li> <li>冻结整个预训练模型。</li> <li>在任务数据上，通过梯度下降<strong>只更新这段“软提示”向量</strong>，让模型学会看到这段向量就知道要执行什么任务。</li></ol></li> <li><strong>参数更新</strong>：<strong>少量</strong>。只更新新增的“软提示”参数，通常只占模型总参数的0.01%~1%。</li> <li><strong>比喻</strong>：百科全书（模型）本身不变，但你给它贴上一组它自己能理解的“隐形便签条”。当你贴上某套特定的便签条时，它就知道要切换到“医疗问答模式”；贴上另一套，它就切换到“写诗模式”。你在训练的就是这些“隐形便签条”。</li> <li><strong>优点</strong>：
<ul><li><strong>极其高效</strong>：训练参数量极少，显存占用低，训练速度快。</li> <li><strong>可复用性</strong>：可以为不同任务训练不同的提示，然后在同一个基础模型上切换。</li> <li><strong>避免遗忘</strong>：因为不改动核心模型，所以几乎不会忘记原有知识。</li></ul></li> <li><strong>缺点</strong>：
<ul><li><strong>性能</strong>：通常比全量微调稍差，尤其在模型规模较小的时候。</li> <li><strong>可解释性差</strong>：“软提示”是人类无法直接理解的数字向量。</li></ul></li></ul> <hr> <h3 id="_3-fine-tuning-微调-通常指全量微调"><a href="#_3-fine-tuning-微调-通常指全量微调" class="header-anchor">#</a> 3. Fine-Tuning（微调，通常指全量微调）</h3> <ul><li><strong>核心思想</strong>：<strong>更新模型的所有（或绝大部分）参数</strong>。让模型的整个知识体系适应下游任务。这是最传统、最强大的迁移学习方法。</li> <li><strong>怎么做</strong>：
<ol><li>在一个与目标任务相关的数据集上，用预训练好的模型（如BERT、GPT）进行继续训练。</li> <li>训练过程中，使用梯度下降和反向传播<strong>更新模型每一层的权重</strong>。</li></ol></li> <li><strong>参数更新</strong>：<strong>全部或大部分</strong>。更新整个模型的参数。</li> <li><strong>比喻</strong>：你把一位通才（预训练模型）送到法学院进行深造。在学习过程中，他<strong>大脑的神经元连接（模型参数）被重塑了</strong>，他变成了一个法律专家，但可能因此忘记了一些关于天文或音乐的知识（灾难性遗忘）。</li> <li><strong>优点</strong>：
<ul><li><strong>性能强大</strong>：通常是三种方法中能达到最高性能的方法。</li> <li><strong>端到端学习</strong>：模型能从数据中深度学习任务的方方面面。</li></ul></li> <li><strong>缺点</strong>：
<ul><li><strong>成本高昂</strong>：需要巨大的计算资源、时间和显存。</li> <li><strong>灾难性遗忘</strong>：模型可能会过度适应新任务，而丢失原有的通用知识。</li> <li><strong>模型膨胀</strong>：每个任务都需要保存一份完整的模型副本，存储成本高。</li></ul></li></ul> <hr> <h3 id="三者的直观对比"><a href="#三者的直观对比" class="header-anchor">#</a> 三者的直观对比</h3> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">Prompt Design（提示设计）</th> <th style="text-align:left;">Prompt Tuning（提示微调）</th> <th style="text-align:left;">Fine-Tuning（全量微调）</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>是否更新参数</strong></td> <td style="text-align:left;"><strong>否</strong></td> <td style="text-align:left;"><strong>是，只更新“软提示”</strong></td> <td style="text-align:left;"><strong>是，更新全部或大部分参数</strong></td></tr> <tr><td style="text-align:left;"><strong>计算成本</strong></td> <td style="text-align:left;">无</td> <td style="text-align:left;">很低</td> <td style="text-align:left;">非常高</td></tr> <tr><td style="text-align:left;"><strong>存储成本</strong></td> <td style="text-align:left;">只需保存文本提示</td> <td style="text-align:left;">只需保存小小的提示向量</td> <td style="text-align:left;">需保存整个模型的副本</td></tr> <tr><td style="text-align:left;"><strong>性能潜力</strong></td> <td style="text-align:left;">受基础模型限制</td> <td style="text-align:left;">中等，接近全量微调</td> <td style="text-align:left;"><strong>最高</strong></td></tr> <tr><td style="text-align:left;"><strong>灾难性遗忘</strong></td> <td style="text-align:left;">无</td> <td style="text-align:left;">基本无</td> <td style="text-align:left;">严重</td></tr> <tr><td style="text-align:left;"><strong>多任务处理</strong></td> <td style="text-align:left;">手动切换提示</td> <td style="text-align:left;">加载不同的提示向量</td> <td style="text-align:left;">需要多个独立模型</td></tr> <tr><td style="text-align:left;"><strong>核心思想</strong></td> <td style="text-align:left;"><strong>改变输入</strong></td> <td style="text-align:left;"><strong>为模型添加可训练输入</strong></td> <td style="text-align:left;"><strong>改变模型本身</strong></td></tr></tbody></table> <h3 id="总结与关系"><a href="#总结与关系" class="header-anchor">#</a> 总结与关系</h3> <ul><li><strong>Prompt Design</strong> 是 <strong>“外部指令”</strong> 的优化，是使用任何模型的第一步。</li> <li><strong>Prompt Tuning</strong> 是 <strong>“内部指令”</strong> 的优化，是一种轻量级的训练方法，属于 <strong>参数高效微调</strong> 的范畴。</li> <li><strong>Fine-Tuning</strong> 是 <strong>“模型本体”</strong> 的优化，是一种重量级的训练方法。</li></ul> <p><strong>发展脉络</strong>：从 <strong>Full Fine-Tuning</strong> -&gt; <strong>Prompt Tuning</strong> 和其衍生技术（如LoRA），体现了业界的一个明确趋势：<strong>如何用越来越小的代价，激发大模型越来越强的性能</strong>。</p> <p>对于实践者来说，通常的建议是：</p> <ol><li>首先尝试 <strong>Prompt Design</strong>，看看基础模型的能力天花板。</li> <li>如果效果不够，且计算资源有限，使用 <strong>Prompt Tuning</strong> 或 <strong>LoRA</strong> 等PEFT方法。</li> <li>只有在追求极致性能且资源充足的情况下，才考虑成本高昂的 <strong>全量微调</strong>。</li></ol> <hr> <blockquote><p>Prompt-tuning 技术的优势</p></blockquote> <p>为什么我们要使用Prompt-tuning？相比于传统的Fine-tuning，它带来了革命性的好处：</p> <ol><li><p><strong>参数效率极高（Parameter-Efficient）</strong></p> <ul><li>传统微调需要更新整个模型（可能包含数十亿甚至数千亿参数），计算和存储成本巨大。</li> <li>Prompt-tuning 只优化极少量的参数（通常只占模型总参数的0.01%~1%），大大降低了硬件门槛。</li></ul></li> <li><p><strong>避免灾难性遗忘（Catastrophic Forgetting）</strong></p> <ul><li>传统微调可能会为了让模型适应新任务而覆盖掉预训练时学到的通用知识。</li> <li>Prompt-tuning 保持原模型参数不变，完美保留了模型在预训练阶段获得的所有知识和能力。</li></ul></li> <li><p><strong>易于部署和切换</strong></p> <ul><li>对于一个基础模型（如LLaMA 3），你可以为不同任务（情感分析、命名实体识别、文本摘要）训练出多个不同的“软提示”。</li> <li>部署时，你只需要保存和加载这些小小的提示文件（几KB到几MB），即可让同一个模型实例瞬间切换为不同任务的专家，而无需维护多个完整的模型副本（每个都可能是几个GB）。</li></ul></li> <li><p><strong>效果逼近全量微调</strong></p> <ul><li>尤其是在模型规模足够大（例如超过100亿参数）时，Prompt-tuning 的性能可以逼近甚至在某些任务上超越全量微调。</li></ul></li></ol> <hr> <h3 id="_3-prefix-tuning"><a href="#_3-prefix-tuning" class="header-anchor">#</a> 3. Prefix Tuning</h3> <ul><li><strong>普通Prompt-Tuning</strong>：只在模型的<strong>输入嵌入层（Input Embedding Layer）</strong> 添加可训练的提示向量。这相当于在对话开始时给模型一个总体的指令。</li> <li><strong>Prefix-Tuning</strong>：不仅在输入层，而是在<strong>模型的每一层（或某几层）的激活（activation）之前</strong>，都添加一组可训练的前缀向量。这相当于在模型思考的每一个步骤、每一个阶段都不断地进行引导和提醒，确保它不偏离轨道。</li></ul> <p><strong>关键比喻：</strong>
想象你在指导一位实习生写报告。</p> <ul><li><strong>Fine-tuning</strong>：你把他送去重新培训，改变他的整个知识结构。</li> <li><strong>Prompt-Tuning</strong>：你在任务开始时给他一份详细的书面指令。</li> <li><strong>Prefix-Tuning</strong>：你不仅给了书面指令，还在他写报告的每一个章节（引言、正文、结论）开始时，都在他旁边给予针对性的提示和引导。这种“持续陪伴”式的指导显然更深入、更有效。</li></ul> <h3 id="_4-相比lora-adalora的改进点是什么"><a href="#_4-相比lora-adalora的改进点是什么" class="header-anchor">#</a> 4. 相比LORA，AdaLoRA的改进点是什么？</h3> <p>好的，这是一个非常核心且重要的问题。简单来说，AdaLoRA是对LoRA的一种<strong>自适应优化</strong>，它的核心改进在于<strong>能够动态地、智能地分配参数预算</strong>，从而在相同的参数总量下获得更好的性能，或者以更少的参数达到与LoRA相当的性能。</p> <p>为了深入理解，我们先快速回顾一下标准LoRA。</p> <h3 id="标准lora的简要回顾"><a href="#标准lora的简要回顾" class="header-anchor">#</a> 标准LoRA的简要回顾</h3> <p>在LoRA中，我们对预训练模型的一个权重矩阵 ( W \in \mathbb{R}^{d \times k} ) 注入一个低秩适配器。其更新方式为：
[
h = Wx + \Delta W x = Wx + BAx
]
其中，( B \in \mathbb{R}^{d \times r} ), ( A \in \mathbb{R}^{r \times k} )，且秩 ( r \ll \min(d, k) )。</p> <p><strong>LoRA的关键特点：</strong></p> <ol><li><strong>固定的秩（r）</strong>：在训练开始前，你需要为每一个LoRA适配器手动指定一个固定的秩 ( r )。</li> <li><strong>均匀的参数分配</strong>：无论这个参数矩阵有多重要，你都分配相同的秩 ( r ) 和参数量 ( r(d+k) )。</li> <li><strong>简单的SVD</strong>：虽然其灵感来自低秩分解，但训练时并不直接使用SVD，而是训练 ( A ) 和 ( B )。</li></ol> <h3 id="adalora的核心改进"><a href="#adalora的核心改进" class="header-anchor">#</a> AdaLoRA的核心改进</h3> <p>AdaLoRA通过引入以下三个关键技术，解决了LoRA“固定秩和均匀分配”的缺点：</p> <h4 id="_1-参数重要性评分"><a href="#_1-参数重要性评分" class="header-anchor">#</a> 1. <strong>参数重要性评分</strong></h4> <p>AdaLoRA会为每一个三元组 ( (i, j) ) （在SVD中对应奇异值和奇异向量）计算一个<strong>重要性分数</strong> ( I_{ij} )。这个分数用于衡量该参数对最终任务性能的贡献程度。常用的计算方法是基于梯度和参数值本身，例如：
[
I_{ij} = |\theta_{ij} \cdot \nabla_{\theta_{ij}} \mathcal{L}|
]
其中 ( \theta ) 代表参数，( \mathcal{L} ) 是损失函数。这个分数在训练过程中会定期更新。</p> <h4 id="_2-动态的预算分配和秩调整"><a href="#_2-动态的预算分配和秩调整" class="header-anchor">#</a> 2. <strong>动态的预算分配和秩调整</strong></h4> <p>这是AdaLoRA最核心的改进。它不再为所有模块固定一个秩，而是：</p> <ul><li><strong>设定一个总参数预算</strong>（例如，总参数量不能超过50万个）。</li> <li>在训练过程中，<strong>周期性地根据重要性分数对所有的LoRA模块进行“修剪”和“生长”</strong>：
<ul><li><strong>修剪</strong>：对于重要性分数低的参数（或整个奇异值），直接将其移除（置零或丢弃），释放出参数预算。</li> <li><strong>生长</strong>：将释放出来的参数预算，重新分配给那些重要性分数高的模块，增加它们的秩，让它们有能力学习更复杂、更精细的适配。</li></ul></li></ul> <p>这个过程就像一个智能的资源管理器，不断地将计算资源从“不重要”的任务转移到“重要”的任务上。</p> <h4 id="_3-通过svd参数化进行高效调整"><a href="#_3-通过svd参数化进行高效调整" class="header-anchor">#</a> 3. <strong>通过SVD参数化进行高效调整</strong></h4> <p>为了能够实现上述的精细修剪和生长，AdaLoRA没有使用LoRA中简单的 ( BA ) 分解，而是直接采用了<strong>奇异值分解（SVD）</strong> 的形式来表示增量矩阵：
[
\Delta W = P \Lambda Q
]
其中：</p> <ul><li>( P \in \mathbb{R}^{d \times r} ) 是左奇异向量矩阵（正交）。</li> <li>( Q \in \mathbb{R}^{r \times k} ) 是右奇异向量矩阵（正交）。</li> <li>( \Lambda \in \mathbb{R}^{r \times r} ) 是对角矩阵，包含了奇异值。</li></ul> <p><strong>为什么这样设计？</strong></p> <ul><li><strong>奇异值（( \Lambda )）</strong> 直接对应了该方向的重要性。修剪时，可以直接丢弃奇异值最小的方向。</li> <li><strong>奇异向量（( P, Q )）</strong> 的正交性约束保证了参数化的稳定性和有效性，避免了在动态调整过程中出现数值不稳定或冗余。</li></ul> <h3 id="对比表格-lora-vs-adalora"><a href="#对比表格-lora-vs-adalora" class="header-anchor">#</a> 对比表格：LoRA vs. AdaLoRA</h3> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">LoRA</th> <th style="text-align:left;">AdaLoRA</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>核心思想</strong></td> <td style="text-align:left;">为所有适配模块<strong>固定</strong>一个低秩。</td> <td style="text-align:left;"><strong>动态、自适应</strong>地为不同模块分配不同的秩。</td></tr> <tr><td style="text-align:left;"><strong>参数分配</strong></td> <td style="text-align:left;"><strong>均匀/静态</strong>：所有模块分配相同的参数量。</td> <td style="text-align:left;"><strong>非均匀/动态</strong>：重要模块分配更多参数，不重要模块分配更少。</td></tr> <tr><td style="text-align:left;"><strong>秩（r）</strong></td> <td style="text-align:left;">手动设置，训练中<strong>固定不变</strong>。</td> <td style="text-align:left;">自动调整，训练中<strong>动态变化</strong>。</td></tr> <tr><td style="text-align:left;"><strong>参数化形式</strong></td> <td style="text-align:left;">简单矩阵乘法 ( BA )。</td> <td style="text-align:left;">SVD形式 ( P \Lambda Q )。</td></tr> <tr><td style="text-align:left;"><strong>智能性</strong></td> <td style="text-align:left;">低，依赖先验知识选择秩。</td> <td style="text-align:left;">高，自动学习不同模块和参数的重要性。</td></tr> <tr><td style="text-align:left;"><strong>资源效率</strong></td> <td style="text-align:left;">可能在某些模块上浪费参数，在重要模块上参数不足。</td> <td style="text-align:left;"><strong>更高效</strong>，在相同参数预算下通常性能更好。</td></tr> <tr><td style="text-align:left;"><strong>超参数调优</strong></td> <td style="text-align:left;">需要为不同层尝试不同的 ( r )，调优成本高。</td> <td style="text-align:left;">只需设定总参数预算，调优更简单。</td></tr></tbody></table> <h3 id="总结与类比"><a href="#总结与类比" class="header-anchor">#</a> 总结与类比</h3> <ul><li><strong>LoRA</strong> 就像给公司每个部门分配<strong>固定且相同</strong>的预算，不管这个部门是核心研发还是后勤支持。</li> <li><strong>AdaLoRA</strong> 则像一位<strong>精明的CEO</strong>，他会根据每个部门的业绩（重要性分数）和公司总预算，定期进行审查：削减表现不佳部门的预算（修剪），并将资源重新分配给高绩效、高潜力的部门（生长）。</li></ul> <p>因此，AdaLoRA的主要优势在于其<strong>自适应性</strong>和<strong>效率</strong>。它通过动态资源分配，确保了有限的微调参数被用在“刀刃”上，从而在几乎所有NLP任务上都表现出优于或等同于标准LoRA的性能，尤其是在参数预算紧张的情况下，其优势更为明显。</p> <hr> <p>好的，我们来深入探讨一下<strong>稀疏微调</strong>。</p> <p>首先，要理解稀疏微调，最好先将其与它的对立面——完全微调进行对比。</p> <ul><li><strong>完全微调</strong>：更新预训练语言模型的所有参数（比如GPT-3有1750亿参数，就需要更新1750亿个参数）。</li> <li><strong>稀疏微调</strong>：<strong>只更新模型庞大参数中的一小部分（稀疏），而冻结其余大部分参数。</strong></li></ul> <p>它的核心思想是：<strong>大型预训练模型已经包含了丰富的通用知识，对于特定的下游任务，我们只需要激发或调整其中与之相关的一小部分神经元或参数子集就足够了，而不需要动整个网络。</strong></p> <p>稀疏微调的工作方式和步骤可以根据其“稀疏性”的实现方式分为几种不同的范式。下图清晰地展示了这三种主流的实现路径：</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">flowchart</span> TD
    A<span class="token text string">[稀疏微调&lt;br&gt;核心目标：只更新一小部分参数]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">{选择实现路径}</span>

    B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[路径一：基于固定子集]</span>
    C <span class="token arrow operator">--&gt;</span> D<span class="token text string">[方法：指定特定结构&lt;br&gt;（如注意力头/偏置项）]</span>
    D <span class="token arrow operator">--&gt;</span> E<span class="token text string">[特点：静态&lt;br&gt;固定不变]</span>

    B <span class="token arrow operator">--&gt;</span> F<span class="token text string">[路径二：基于动态选择]</span>
    F <span class="token arrow operator">--&gt;</span> G<span class="token text string">[方法：根据显著性评分&lt;br&gt;选择重要参数]</span>
    G <span class="token arrow operator">--&gt;</span> H<span class="token text string">[特点：动态&lt;br&gt;周期性更新]</span>

    B <span class="token arrow operator">--&gt;</span> I<span class="token text string">[路径三：引入稀疏旁路]</span>
    I <span class="token arrow operator">--&gt;</span> J<span class="token text string">[方法：添加可训练稀疏模块&lt;br&gt;（如Adapter/LoRA）]</span>
    J <span class="token arrow operator">--&gt;</span> K<span class="token text string">[特点：附加式&lt;br&gt;原模型冻结]</span>
</code></pre></div><p>下面，我们详细解析这三种路径下的具体方法和工作步骤。</p> <h3 id="方法一-基于固定结构化子集的稀疏微调"><a href="#方法一-基于固定结构化子集的稀疏微调" class="header-anchor">#</a> 方法一：基于固定结构化子集的稀疏微调</h3> <p>这种方法<strong>在训练开始前就人为地选定一类特定的、只占总数一小部分的参数</strong>进行更新。</p> <p><strong>工作原理：</strong></p> <ul><li>研究者根据经验或假设，选择模型中的某类参数作为“可训练”的。</li> <li>在微调过程中，只计算这些选定参数的梯度并更新它们，其余参数被冻结。</li></ul> <p><strong>常见示例与步骤：</strong></p> <ol><li><strong>只微调偏置项</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结模型中所有的权重矩阵（如Linear、LayerNorm的权重）。</li> <li>只将模型中所有的偏置项设置为可训练。</li> <li>进行训练。由于偏置项的数量远少于权重，实现了稀疏更新。</li></ul></li></ul></li> <li><strong>只微调某几层</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结模型的大部分层（例如，只更新最后4层Transformer块）。</li> <li>只解冻靠近输出端的少数几层进行微调。</li></ul></li></ul></li> <li><strong>只微调注意力模块中的特定部分</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结前馈神经网络。</li> <li>只更新自注意力机制中的参数（如Query, Key, Value投影矩阵）。</li></ul></li></ul></li></ol> <p><strong>特点：</strong></p> <ul><li><strong>静态</strong>：可训练参数集在训练过程中是固定不变的。</li> <li><strong>简单</strong>：实现起来非常简单，无需复杂算法。</li> <li><strong>可能不最优</strong>：人为选择可能无法找到对下游任务最重要的参数子集。</li></ul> <h3 id="方法二-基于动态参数选择的稀疏微调"><a href="#方法二-基于动态参数选择的稀疏微调" class="header-anchor">#</a> 方法二：基于动态参数选择的稀疏微调</h3> <p>这种方法<strong>根据参数的重要性评分，动态地选择一部分参数进行更新</strong>。这比方法一更智能，AdaLoRA中就包含了这种思想。</p> <p><strong>工作原理：</strong></p> <ul><li>为所有参数计算一个重要性分数（例如，基于梯度大小）。</li> <li>周期性地根据这个分数，选择排名靠前的一小部分参数作为可训练参数。</li></ul> <p><strong>步骤：</strong></p> <ol><li><strong>初始化</strong>：开始时，可以冻结所有参数，或者先进行几轮热身训练。</li> <li><strong>评分</strong>：在一个训练周期结束后，为每个参数 ( \theta_i ) 计算重要性分数 ( I_i )。一个常见的方法是：
[
I_i = | \theta_i \cdot \nabla_{\theta_i} \mathcal{L} |
]
（即参数的绝对值乘以它的梯度绝对值），这近似反映了参数变化对损失的影响。</li> <li><strong>选择/掩码</strong>：根据分数对所有参数进行排序，选择Top-K个最重要的参数，生成一个<strong>二进制掩码</strong> ( M )。
<ul><li>( M_i = 1 ) 表示该参数被选中（可训练）。</li> <li>( M_i = 0 ) 表示该参数被冻结。</li></ul></li> <li><strong>稀疏更新</strong>：在接下来的训练周期中，只更新那些 ( M_i = 1 ) 的参数。
<ul><li>梯度下降公式变为：( \theta_i \leftarrow \theta_i - \eta \cdot M_i \cdot \nabla_{\theta_i} \mathcal{L} )</li></ul></li> <li><strong>周期性重分配</strong>：每隔 ( N ) 个训练周期（Epoch），重复步骤2-4，重新评估参数重要性并更新掩码 ( M )。这允许模型根据学习进程动态调整哪些参数需要被优化。</li></ol> <p><strong>特点：</strong></p> <ul><li><strong>动态</strong>：可训练参数集在训练过程中是变化的。</li> <li><strong>智能</strong>：理论上能更高效地分配参数更新预算。</li> <li><strong>复杂</strong>：需要额外的计算来评估重要性，并管理参数的动态掩码。</li></ul> <h3 id="方法三-基于附加稀疏适配器的微调-目前最流行"><a href="#方法三-基于附加稀疏适配器的微调-目前最流行" class="header-anchor">#</a> 方法三：基于附加稀疏适配器的微调（目前最流行）</h3> <p>这是目前最主流的“稀疏微调”方式，也是<strong>Parameter-Efficient Fine-Tuning (PEFT)</strong> 的核心。它<strong>不直接更新原始模型参数</strong>，而是<strong>引入一小部分额外的、可训练的参数（适配器）</strong>，模型主体保持冻结。</p> <p><strong>工作原理：</strong></p> <ul><li>在预训练模型的架构中，插入一些小的、可训练的模块。</li> <li>在微调时，<strong>只训练这些新增的适配器</strong>，原始模型的<strong>所有参数都被冻结</strong>。从参数更新的角度看，这是“稀疏”的，因为只有新增的那一小部分参数被更新。</li></ul> <p><strong>常见示例与步骤：</strong></p> <ol><li><strong>LoRA及其变种</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结整个预训练模型。</li> <li>在原有的权重矩阵 ( W ) 旁，注入一个低秩适配器 ( \Delta W = BA )。</li> <li><strong>只训练 ( A ) 和 ( B ) 这两个小矩阵</strong>。前向传播变为：( h = Wx + BAx )。</li></ul></li></ul></li> <li><strong>Adapter模块</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结整个预训练模型。</li> <li>在Transformer块中的前馈网络或注意力模块之后，插入一个小的前馈神经网络（Adapter）。</li> <li><strong>只训练这些插入的Adapter模块</strong>。</li></ul></li></ul></li></ol> <p><strong>特点：</strong></p> <ul><li><strong>附加式</strong>：不改变原参数，而是增加新参数。</li> <li><strong>极高效</strong>：通常参数量极小（仅为原模型的0.01%~1%）。</li> <li><strong>模块化与安全</strong>：由于原模型不动，可以为一个模型创建多个适配器用于不同任务，且没有灾难性遗忘的风险。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>稀疏微调通过多种技术路径实现了一个共同目标：<strong>极大地减少微调时需要更新的参数量</strong>。其工作流程可以概括为：</p> <ol><li><strong>识别</strong>：通过固定规则、动态评分或引入外部结构的方式，确定一个远小于模型总规模的参数子集。</li> <li><strong>冻结</strong>：将不在这个子集中的绝大部分模型参数固定住，不计算其梯度或进行更新。</li> <li><strong>更新</strong>：仅对选定的这一小部分参数进行梯度下降优化。</li></ol> <p>这种方法带来了巨大的优势：</p> <ul><li><strong>计算效率</strong>：大幅降低显存消耗和计算需求。</li> <li><strong>降低过拟合</strong>：特别是在小数据集上，更新参数少，不易过拟合。</li> <li><strong>便捷部署</strong>：可以轻松地保存和切换多个小型适配器，而不需要保存整个模型的多个副本。</li></ul> <p>目前，<strong>基于适配器的方法（尤其是LoRA及其变种）</strong> 因其简单、高效和卓越的性能，已成为稀疏微调事实上的标准和最主流的选择。</p> <hr> <p>好的，这是一个在大型语言模型微调实践中非常常见且关键的问题。监督微调后模型表现下降，通常被称为 <strong>“灾难性遗忘”</strong> 或 <strong>“对齐税”</strong> 。其背后的原因是多方面的，可以归结为以下几个核心点：</p> <p>下图清晰地展示了导致SFT后模型表现下降的三大核心原因及其相互影响关系：</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">flowchart</span> TD
    A<span class="token text string">[SFT后模型表现下降]</span> <span class="token arrow operator">--&gt;</span> B1<span class="token text string">[数据层面原因]</span>
    A <span class="token arrow operator">--&gt;</span> B2<span class="token text string">[训练层面原因]</span>
    A <span class="token arrow operator">--&gt;</span> B3<span class="token text string">[模型能力与对齐的&lt;br&gt;根本性权衡]</span>

    B1 <span class="token arrow operator">--&gt;</span> C1<span class="token text string">[数据质量差&lt;br&gt;（噪音/错误/多样性低）]</span>
    B1 <span class="token arrow operator">--&gt;</span> C2<span class="token text string">[数据量不足&lt;br&gt;导致过拟合]</span>
    B1 <span class="token arrow operator">--&gt;</span> C3<span class="token text string">[指令分布不匹配&lt;br&gt;（暴露偏差）]</span>

    B2 <span class="token arrow operator">--&gt;</span> C4<span class="token text string">[过拟合&lt;br&gt;（学习数据而非指令）]</span>
    B2 <span class="token arrow operator">--&gt;</span> C5<span class="token text string">[超参数设置不当&lt;br&gt;（如学习率过高）]</span>
    B2 <span class="token arrow operator">--&gt;</span> C6<span class="token text string">[灾难性遗忘&lt;br&gt;（通用知识被覆盖）]</span>

    B3 <span class="token arrow operator">--&gt;</span> C7<span class="token text string">[“对齐税”&lt;br&gt;为安全和服从性&lt;br&gt;牺牲部分原始能力]</span>
</code></pre></div><p>下面我们详细解析图中的每一个方面。</p> <h3 id="_1-数据层面"><a href="#_1-数据层面" class="header-anchor">#</a> 1. 数据层面</h3> <p>这是最常见也是最根本的原因。</p> <ul><li><p><strong>数据质量低劣</strong></p> <ul><li><strong>噪声与错误</strong>：SFT数据中如果包含事实错误、语法问题或低质量的回复，模型会“学好”这些坏习惯。垃圾进，垃圾出。</li> <li><strong>格式不一致</strong>：同样的指令，回答的风格、格式、深度不一致，会让模型感到困惑，不知道到底要学习哪种模式。</li> <li><strong>错误的偏好</strong>：数据中可能包含了人类标注者的个人偏见或错误的推理过程，模型会内化这些偏好。</li></ul></li> <li><p><strong>数据多样性不足</strong></p> <ul><li><strong>任务单一</strong>：如果SFT数据只集中在某几个任务上（例如，只教它写邮件，不做数学题），模型在训练过程中就会“遗忘”如何在其他任务上表现出色。这本质上是灾难性遗忘的体现。</li> <li><strong>风格单一</strong>：数据如果全是正式文风，模型可能就会失去写诗歌、讲笑话的能力。</li></ul></li> <li><p><strong>数据分布不匹配 / 暴露偏差</strong></p> <ul><li>在预训练阶段，模型学习的是“下一个词预测”，它接触的是海量的、多样化的互联网文本。</li> <li>在SFT阶段，模型学习的是“给定一个指令，生成一个回复”。如果SFT数据的指令-回复对分布与预训练数据的分布差异巨大，模型就会脱离其强大的“基础”，向一个狭窄的分布偏移。这被称为 <strong>“分布偏移”</strong> 或 <strong>“暴露偏差”</strong>（在训练时总是看到正确的指令，而在推理时可能遇到各种奇怪的指令）。</li></ul></li> <li><p><strong>数据量不足</strong></p> <ul><li>相对于预训练的万亿级token，SFT数据通常只有几万到几十万条。用如此少的数据去覆盖一个拥有数百亿参数模型的原有知识，是非常困难的，极易导致过拟合。</li></ul></li></ul> <h3 id="_2-训练方法与超参数层面"><a href="#_2-训练方法与超参数层面" class="header-anchor">#</a> 2. 训练方法与超参数层面</h3> <ul><li><p><strong>过拟合</strong></p> <ul><li>这是最直接的技术原因。模型不是学会了“如何遵循指令”，而是<strong>死记硬背了训练集中的指令-回复对</strong>。当遇到训练集之外的指令时，它就无法泛化，表现僵化甚至胡言乱语。</li> <li><strong>迹象</strong>：在训练集上表现完美，在验证集或新任务上表现糟糕。</li></ul></li> <li><p><strong>灾难性遗忘</strong></p> <ul><li>这是过拟合的另一种表现形式。模型为了适应新的SFT任务，<strong>覆盖了在预训练阶段学到的通用知识和推理能力</strong>。</li> <li>例如，一个模型在预训练时学会了很好的数学推理能力，但在SFT时只学习诗歌创作，那么它可能就忘记了如何解方程。<strong>SFT过程“抹去”了它的一部分基础能力。</strong></li></ul></li> <li><p><strong>超参数设置不当</strong></p> <ul><li><strong>学习率过高</strong>：这是导致灾难性遗忘的元凶之一。过高的学习率会导致参数发生剧烈变化，粗暴地覆盖掉预训练的知识。通常SFT会使用较小的学习率（例如5e-6到5e-5量级）。</li> <li><strong>训练轮数过多</strong>：同样会导致过拟合。模型一遍又一遍地学习SFT数据，直到它不再泛化。</li> <li><strong>错误的优化器</strong>：不使用与预训练阶段相似的优化器设置也可能带来问题。</li></ul></li></ul> <h3 id="_3-能力与对齐的根本性权衡"><a href="#_3-能力与对齐的根本性权衡" class="header-anchor">#</a> 3. 能力与对齐的根本性权衡</h3> <p>这是一个更深层、更哲学的原因，通常被称为 <strong>“对齐税”</strong>。</p> <ul><li><p><strong>“安全”与“能力”的冲突</strong>：预训练模型为了获得强大的能力，是在“未经审查”的互联网数据上训练的，其中包含了很多“不安全”、“不礼貌”但可能包含复杂逻辑或事实的内容。SFT的一个重要目标就是让模型变得安全、无害、对齐人类价值观。</p> <ul><li>在这个过程中，模型可能会变得<strong>过于保守</strong>。为了避免生成任何可能有害的内容，它可能会拒绝回答一些原本可以回答的、处于灰色地带的问题，或者其回答的创造性和丰富性下降。</li> <li><strong>例子</strong>：一个预训练模型可能会生动地描述一场虚构的战争场面；而经过安全SFT后的模型可能会拒绝回答，或者说“我不能描述暴力场景”。从安全角度看是进步，从文本生成能力角度看是退步。</li></ul></li> <li><p><strong>“服从性”与“创造性”的冲突</strong>：SFT教导模型要严格遵循指令。这有时会抑制模型的创造性。一个总是试图精确回答问题的模型，可能会失去在预训练中表现出的天马行空的联想和发散能力。</p></li></ul> <h3 id="如何缓解这些问题"><a href="#如何缓解这些问题" class="header-anchor">#</a> 如何缓解这些问题？</h3> <ol><li><strong>提升数据质量</strong>：精心清洗和构建SFT数据，确保正确性、多样性和高质量。<strong>“质量远胜于数量”</strong> 在SFT中尤其正确。</li> <li><strong>谨慎选择超参数</strong>：使用<strong>较低的学习率</strong>和<strong>较少的训练轮数</strong>（通常1-3个epoch）。始终使用验证集来监控训练，防止过拟合。</li> <li><strong>使用参数高效微调技术</strong>：如 <strong>LoRA</strong>。这种方法只更新一小部分参数，大部分预训练参数保持不变，从而极大地减轻了灾难性遗忘。</li> <li><strong>混合预训练目标</strong>：在SFT时，不仅计算指令回复的损失，也混入一部分传统的“下一个词预测”损失（在预训练数据上），这有助于锚定模型，不让其忘记基础知识。</li> <li><strong>课程学习与逐步训练</strong>：先在一个广泛、多样的指令数据集上进行SFT，再在特定任务的数据集上精调。</li> <li><strong>后期模型融合</strong>：将SFT后的模型与原始预训练模型进行融合，试图在保留基础能力和获得新指令遵循能力之间找到平衡。</li></ol> <p>总而言之，SFT后模型表现下降是一个典型的<strong>机器学习优化问题</strong>（过拟合、灾难性遗忘）和一个<strong>人工智能对齐问题</strong>（对齐税）的结合体。成功的SFT需要在教导模型新技能和保留其旧能力之间做出精妙的平衡。</p> <hr> <h1 id="多轮对话任务如何微调模型"><a href="#多轮对话任务如何微调模型" class="header-anchor">#</a> 多轮对话任务如何微调模型？</h1> <p>好的，多轮对话任务的微调是一个系统工程，需要从数据、方法和技巧等多个层面进行综合考虑。下面我将详细拆解其工作原理、步骤和最佳实践。</p> <h3 id="核心挑战-让模型理解-上下文"><a href="#核心挑战-让模型理解-上下文" class="header-anchor">#</a> 核心挑战：让模型理解“上下文”</h3> <p>与单轮指令微调不同，多轮对话微调的核心目标是让模型不仅理解当前的查询，还能<strong>记住、理解并有效利用整个对话历史</strong>中的信息。这包括：</p> <ul><li><strong>指代消解</strong>：理解“他”、“它”、“那个东西”指代的是什么。</li> <li><strong>对话状态跟踪</strong>：记住双方已经达成的一致意见、用户已经提供的信息等。</li> <li><strong>连贯性与一致性</strong>：确保回复与之前的对话在风格、角色和事实上保持一致。</li></ul> <hr> <h3 id="微调方法概览"><a href="#微调方法概览" class="header-anchor">#</a> 微调方法概览</h3> <p>主要有两种主流方法，其选择路径和关键技术如下所示：</p> <h4 id="方法一-全参数微调"><a href="#方法一-全参数微调" class="header-anchor">#</a> 方法一：全参数微调</h4> <p>这种方法使用多轮对话数据，直接对基础模型的所有参数进行微调。</p> <p><strong>关键技术：对话格式构建</strong></p> <p>这是最关键的一步。你不能简单地把多轮对话扔给模型，而是需要将其构建成一个结构化的文本序列，并明确标注<strong>说话人角色</strong>。</p> <ol><li><p><strong>角色标识符</strong>：使用特殊的令牌来区分不同发言者。</p> <ul><li>例如：<code>&lt;|user|&gt;</code>, <code>&lt;|assistant|&gt;</code>, <code>&lt;|system|&gt;</code></li> <li>开源模型如 ChatML 格式、LLama 2 的 Chat 格式都定义了这样的角色。</li></ul></li> <li><p><strong>对话拼接</strong>：将整个对话拼接成一个长的文本序列。</p></li></ol> <p><strong>一个标准的ChatML格式示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;|im_start|&gt;system
你是一个乐于助人的AI助手。&lt;|im_end|&gt;
&lt;|im_start|&gt;user
今天的天气怎么样？&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant
我不知道，因为我无法访问实时天气数据。但如果您告诉我您的位置，我可以给您一些一般性的建议。&lt;|im_end|&gt;
&lt;|im_start|&gt;user
我在北京。&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant
北京现在可能是晴天，但建议您查看本地天气预报以获取准确信息。&lt;|im_end|&gt;
</code></pre></div><p><strong>训练时的关键技巧：损失掩码</strong></p> <ul><li>在训练时，我们只计算 <strong><code>&lt;|assistant|&gt;</code></strong> 后面回复部分的损失函数。</li> <li>对于 <code>system</code>, <code>user</code> 部分的 tokens，我们将它们的损失掩码为 0，模型不会从这些部分学习生成文本。</li> <li><strong>目的</strong>：教会模型“在给定的对话历史下，如何生成一个合适的助理回复”，而不是学习如何生成用户的问题或系统提示。</li></ul> <h4 id="方法二-参数高效微调-peft"><a href="#方法二-参数高效微调-peft" class="header-anchor">#</a> 方法二：参数高效微调（PEFT）</h4> <p>这是目前最主流和推荐的方法，尤其是 <strong>LoRA</strong> 和 <strong>QLoRA</strong>。它在全参数微调的基础上，引入了可训练的旁路矩阵，极大地降低了计算成本。</p> <p><strong>工作原理：</strong></p> <ol><li>冻结预训练模型的所有参数。</li> <li>在模型的注意力层和全连接层旁，注入少量的可训练参数（LoRA 秩分解矩阵）。</li> <li>训练时，只更新这些新增的参数，而不触动原始模型的巨大参数库。</li></ol> <p><strong>为什么PEFT对多轮对话特别有益？</strong></p> <ul><li><strong>减轻灾难性遗忘</strong>：多轮对话数据通常远少于预训练数据。PEFT 能更好地保留模型在预训练阶段获得的世界知识和语言能力，防止其因过度专注于学习对话结构而遗忘根本。</li> <li><strong>高效且成本低</strong>：可以在消费级GPU上微调大模型。</li> <li><strong>模块化</strong>：可以为不同的对话风格或任务训练不同的 LoRA 适配器，灵活切换。</li></ul> <hr> <h3 id="微调步骤详解"><a href="#微调步骤详解" class="header-anchor">#</a> 微调步骤详解</h3> <p>无论选择哪种方法，其数据准备和训练流程是相似的。</p> <h4 id="第1步-数据准备与格式化"><a href="#第1步-数据准备与格式化" class="header-anchor">#</a> 第1步：数据准备与格式化</h4> <ol><li><strong>数据收集</strong>：获取多轮对话数据。来源可以是：
<ul><li>人工标注的高质量对话。</li> <li>从现有对话系统（如客服日志）中清洗和脱敏的数据。</li> <li>利用大模型（如 GPT-4）自动生成合成数据。</li></ul></li> <li><strong>数据清洗</strong>：去除无关信息、敏感信息，确保对话流畅自然。</li> <li><strong>格式转换</strong>：<strong>这是最关键的步骤。</strong> 将你的原始对话数据（可能是 JSON 格式），严格按照选定的<strong>对话模板</strong>（如上述的 ChatML 格式）转换成纯文本序列。必须确保角色标识符和结束符的正确使用。</li></ol> <h4 id="第2步-选择模型与模板"><a href="#第2步-选择模型与模板" class="header-anchor">#</a> 第2步：选择模型与模板</h4> <ol><li><strong>基础模型</strong>：选择一个合适的预训练基础模型。对于对话任务，选择已经在大量文本上预训练过的模型（如 LLaMA、Qwen、ChatGLM 等）效果更好。</li> <li><strong>对话模板</strong>：<strong>必须使用与基础模型相匹配的对话模板！</strong> 例如，如果你微调 <code>Llama-2-7b-chat-hf</code>，就必须使用 Llama 2 官方定义的聊天格式（以 <code>[INST]</code>、<code>&lt;&lt;SYS&gt;&gt;</code> 等为标识符）。混用模板会导致性能急剧下降。</li></ol> <h4 id="第3步-配置训练参数"><a href="#第3步-配置训练参数" class="header-anchor">#</a> 第3步：配置训练参数</h4> <ul><li><strong>学习率</strong>：由于任务相对复杂，学习率不宜过高。对于全参数微调，建议 <code>1e-5</code> 到 <code>5e-5</code>；对于 LoRA，可以稍高一些，如 <code>2e-4</code> 到 <code>3e-4</code>。</li> <li><strong>训练轮数</strong>：多轮对话容易过拟合，建议使用 <code>1-3</code> 个 epoch，并密切关注验证集损失。</li> <li><strong>批次大小</strong>：在显存允许的情况下尽可能大。</li> <li><strong>梯度累积</strong>：当显存不足时，使用梯度累积来模拟更大的批次大小。</li> <li><strong>长度裁剪</strong>：由于对话历史可能很长，需要设置一个最大长度（如 2048 或 4096）。对于超过长度的对话，可以采取“丢弃最老的轮次”或“滑动窗口”的策略。</li></ul> <h4 id="第4步-训练与评估"><a href="#第4步-训练与评估" class="header-anchor">#</a> 第4步：训练与评估</h4> <ol><li><strong>训练</strong>：开始训练过程。使用 PEFT（如 LoRA）会快得多。</li> <li><strong>评估</strong>：评估不能只看损失，必须进行<strong>人工评估</strong>或使用<strong>模型辅助评估</strong>。
<ul><li><strong>构建验证集</strong>：准备一组未在训练中使用的多轮对话。</li> <li><strong>人工评估指标</strong>：
<ul><li><strong>相关性</strong>：回复是否与当前问题和历史相关？</li> <li><strong>连贯性</strong>：回复在对话中是否自然流畅？</li> <li><strong>信息量</strong>：回复是否提供了有价值的信息？</li> <li><strong>上下文理解</strong>：是否正确处理了指代和历史信息？</li></ul></li></ul></li></ol> <h3 id="高级技巧与注意事项"><a href="#高级技巧与注意事项" class="header-anchor">#</a> 高级技巧与注意事项</h3> <ol><li><strong>长上下文处理</strong>：如果您的对话非常长，考虑使用支持更长上下文的模型，或使用 <code>FlashAttention</code> 等技术来优化注意力计算。</li> <li><strong>系统提示词工程</strong>：在对话开头使用 <code>system</code> 提示词来设定助理的角色、性格和知识范围，这能极大地引导模型行为。</li> <li><strong>渐进式训练</strong>：可以先在大量的单轮指令数据上进行微调，让模型先学会“遵循指令”，然后再在多轮对话数据上进行精调，让模型学会“利用上下文”。</li> <li><strong>使用专门的库</strong>：利用 <code>TRL</code>、<code>Axolotl</code> 等专门为 LLM 微调设计的库，它们已经内置了对话模板、损失掩码和 PEFT 集成，能极大简化流程。</li></ol> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <p>微调模型进行多轮对话任务的成功关键在于：</p> <ul><li><strong>数据是王道</strong>：高质量、格式正确的多轮对话数据至关重要。</li> <li><strong>格式要匹配</strong>：严格使用与基础模型对齐的对话模板。</li> <li><strong>损失要掩码</strong>：确保只对助理的回复计算损失。</li> <li><strong>PEFT 是首选</strong>：使用 LoRA/QLoRA 等方法以高效且有效的方式微调，保留模型原有知识。</li> <li><strong>评估要全面</strong>：结合自动指标和人工评估，重点关注模型对上下文的理解能力。</li> <li></li></ul> <h3 id="transformer-基本流程"><a href="#transformer-基本流程" class="header-anchor">#</a> Transformer 基本流程</h3> <p>好的，我们以一个简单的<strong>英译中</strong>任务为例，简述 Transformer 的基本流程，核心在于其独特的 <strong>“编码器-解码器”</strong> 架构和 <strong>“自注意力机制”</strong>。</p> <p>假设输入是 <code>&quot;I love you&quot;</code>，目标是输出 <code>&quot;我爱你&quot;</code>。</p> <p>为了更直观地理解这个信息流动过程，我们可以参考下面的流程图，它描绘了从输入到输出的完整路径：</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">flowchart</span> TD
    A<span class="token text string">[输入:“I love you”]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">[“编码器&lt;br&gt;处理输入序列”]</span>

    B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[“生成带掩码的&lt;br&gt;目标序列”]</span>

    B <span class="token arrow operator">--&gt;</span> D
    <span class="token keyword">subgraph</span> D <span class="token text string">[编码器]</span>
        D1<span class="token text string">[“输入嵌入&lt;br&gt;+ 位置编码”]</span> <span class="token arrow operator">--&gt;</span> D2<span class="token text string">[“多头自注意力&lt;br&gt;计算输入词间关系”]</span> <span class="token arrow operator">--&gt;</span> D3<span class="token text string">[“前馈神经网络&lt;br&gt;进一步处理特征”]</span>
    <span class="token keyword">end</span>

    C <span class="token arrow operator">--&gt;</span> E
    <span class="token keyword">subgraph</span> E <span class="token text string">[解码器]</span>
        E1<span class="token text string">[“输出嵌入&lt;br&gt;+ 位置编码”]</span> <span class="token arrow operator">--&gt;</span> E2<span class="token text string">[“掩码多头自注意力&lt;br&gt;关注已生成输出”]</span> <span class="token arrow operator">--&gt;</span> E3<span class="token text string">[“多头交叉注意力&lt;br&gt;关注编码器输出”]</span> <span class="token arrow operator">--&gt;</span> E4<span class="token text string">[“前馈神经网络&lt;br&gt;进一步处理特征”]</span>
    <span class="token keyword">end</span>

    D3 <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span> <span class="token label property">“编码器输出&lt;br&gt;（源序列的深层表示）”</span> <span class="token arrow operator">--&gt;</span></span> E3

    E4 <span class="token arrow operator">--&gt;</span> F<span class="token text string">[“线性层&lt;br&gt;转换为词汇表概率”]</span>
    F <span class="token arrow operator">--&gt;</span> G<span class="token text string">[“Softmax&lt;br&gt;生成下一个词的概率”]</span>
    G <span class="token arrow operator">--&gt;</span> H<span class="token text string">{选择概率最高的词}</span>
    
    H <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span> <span class="token label property">“循环: 将新词追加到输出序列&lt;br&gt;继续预测下一个词， 直到生成结束符”</span> <span class="token arrow operator">--&gt;</span></span> C
    H <span class="token arrow operator">--&gt;</span> I<span class="token text string">[“最终输出: &lt;br&gt;我爱你”]</span>
</code></pre></div><p>下面，我们来详细分解图中的每一个关键步骤。</p> <hr> <h3 id="第零步-输入与输出表示"><a href="#第零步-输入与输出表示" class="header-anchor">#</a> <strong>第零步：输入与输出表示</strong></h3> <ol><li><p><strong>输入（编码器端）</strong>：</p> <ul><li>输入句子 <code>&quot;I love you&quot;</code> 被分解为三个单词 <code>[&quot;I&quot;, &quot;love&quot;, &quot;you&quot;]</code>。</li> <li><strong>输入嵌入</strong>：每个单词通过一个查找表被转换成一个向量（一个数字列表）。所以，<code>&quot;I&quot;</code> -&gt; 向量1，<code>&quot;love&quot;</code> -&gt; 向量2，<code>&quot;you&quot;</code> -&gt; 向量3。</li> <li><strong>位置编码</strong>：由于 Transformer 不像 RNN 那样天然地处理顺序，它需要手动添加位置信息。<strong>位置编码</strong> 是一个独特的向量，被加到每个单词的嵌入向量上，告诉模型每个单词在序列中的位置（例如，<code>&quot;I&quot;</code> 是第一个词，<code>&quot;love&quot;</code> 是第二个）。</li></ul></li> <li><p><strong>输出（解码器端）</strong>：</p> <ul><li>训练时，我们知道正确答案是 <code>&quot;我爱你&quot;</code>。</li> <li>我们会将 <code>&quot;我爱你&quot;</code> 也做类似的嵌入和位置编码，然后输入给解码器。</li> <li><strong>关键：掩码</strong>：在训练时，为了防止模型“作弊”（直接看到要预测的答案），解码器会使用一个<strong>掩码</strong>。当模型预测第 <code>t</code> 个词时，它只能看到第 <code>1</code> 到第 <code>t-1</code> 个词。例如，在预测 <code>&quot;爱&quot;</code> 时，它只能看到 <code>&quot;我&quot;</code>。</li></ul></li></ol> <hr> <h3 id="第一步-编码器处理输入"><a href="#第一步-编码器处理输入" class="header-anchor">#</a> <strong>第一步：编码器处理输入</strong></h3> <p>编码器由 <code>N</code> 个（例如，原论文是6个）相同的层堆叠而成。每一层都有两个核心子层：</p> <ol><li><p><strong>多头自注意力层</strong>：</p> <ul><li><strong>目的</strong>：让序列中的每个词都能与其他所有词进行“交流”，从而根据上下文来更好地理解自己。</li> <li><strong>过程</strong>：对于 <code>&quot;I love you&quot;</code>，自注意力机制会计算：
<ul><li><code>&quot;I&quot;</code> 与 <code>&quot;love&quot;</code> 和 <code>&quot;you&quot;</code> 的关联度。</li> <li><code>&quot;love&quot;</code> 与 <code>&quot;I&quot;</code> 和 <code>&quot;you&quot;</code> 的关联度。</li> <li><code>&quot;you&quot;</code> 与 <code>&quot;I&quot;</code> 和 <code>&quot;love&quot;</code> 的关联度。</li></ul></li> <li>这样，模型就能知道在这个句子里，<code>&quot;love&quot;</code> 是核心动词，<code>&quot;I&quot;</code> 是主语，<code>&quot;you&quot;</code> 是宾语。</li></ul></li> <li><p><strong>前馈神经网络层</strong>：</p> <ul><li><strong>目的</strong>：对自注意力层的输出进行进一步的非线性变换和处理。</li> <li><strong>特点</strong>：这个层对每个位置的向量是<strong>独立</strong>处理的。</li></ul></li></ol> <p>每个子层周围都有一个 <strong>“残差连接”</strong> 和 <strong>“层归一化”</strong>，这有助于稳定和加速训练。</p> <p><strong>经过所有编码器层后，输入序列 <code>&quot;I love you&quot;</code> 被转换为一组富含上下文信息的向量表示。</strong> 我们可以将其理解为源句子的一种“深层语义编码”。</p> <hr> <h3 id="第二步-解码器生成输出"><a href="#第二步-解码器生成输出" class="header-anchor">#</a> <strong>第二步：解码器生成输出</strong></h3> <p>解码器也由 <code>N</code> 个相同的层堆叠而成。每一层都有<strong>三个</strong>核心子层：</p> <ol><li><p><strong>掩码多头自注意力层</strong>：</p> <ul><li><strong>目的</strong>：让解码器关注<strong>已经生成</strong>的输出序列部分。</li> <li>例如，在生成 <code>&quot;我爱你&quot;</code> 时，当预测第三个字 <code>&quot;你&quot;</code>，这个层只允许模型关注 <code>&quot;我&quot;</code> 和 <code>&quot;爱&quot;</code>。</li></ul></li> <li><p><strong>多头交叉注意力层</strong>：</p> <ul><li><strong>目的</strong>：这是连接编码器和解码器的桥梁！让解码器在生成当前词时，能够<strong>关注输入序列中最相关的部分</strong>。</li> <li><strong>过程</strong>：这个层的 <strong>Query</strong> 来自上一层解码器的输出，而 <strong>Key</strong> 和 <strong>Value</strong> 来自<strong>编码器的最终输出</strong>。</li> <li>在我们的例子中，当解码器要生成 <code>&quot;爱&quot;</code> 时，它会通过交叉注意力去询问编码器：“基于我目前生成了 <code>‘我’</code>，输入 <code>‘I love you’</code> 中哪个部分最值得我关注？” 模型很可能会将注意力集中在 <code>&quot;love&quot;</code> 这个词上。</li></ul></li> <li><p><strong>前馈神经网络层</strong>：</p> <ul><li>与编码器中的前馈网络作用相同。</li></ul></li></ol> <p>同样，每个子层都有残差连接和层归一化。</p> <hr> <h3 id="第三步-输出预测"><a href="#第三步-输出预测" class="header-anchor">#</a> <strong>第三步：输出预测</strong></h3> <ol><li>最后一个解码器层的输出是一个向量序列（每个词对应一个向量）。</li> <li>这个向量通过一个 <strong>线性层</strong>，被映射到一个非常长的向量上，这个向量的长度等于整个词汇表的大小（例如5万个词）。这个操作可以看作是为每个可能的词计算一个“分数”。</li> <li>然后通过 <strong>Softmax 层</strong> 将这些“分数”转换为概率，所有词的概率之和为1。</li> <li>模型选择概率最高的那个词，作为下一个输出词。</li> <li>这个新生成的词会被添加回解码器的输入中，用于预测下一个词，如此循环，直到模型输出一个代表句子结束的特殊符号（如 <code>&lt;eos&gt;</code>）。</li></ol> <p><strong>最终，我们就得到了完整的翻译结果：<code>&quot;我爱你&quot;</code>。</strong></p> <h3 id="核心总结"><a href="#核心总结" class="header-anchor">#</a> <strong>核心总结</strong></h3> <p>Transformer 的基本流程可以简化为：
<strong>输入</strong> -&gt; <strong>编码（通过自注意力理解源序列）</strong> -&gt; <strong>解码（通过交叉注意力参考编码结果，并通过掩码自注意力生成目标序列）</strong> -&gt; <strong>输出</strong>。</p> <p>其革命性在于完全依赖<strong>注意力机制</strong>来建立全局依赖关系，并行处理序列，从而实现了前所未有的效率和性能。</p> <h3 id="为什么需要多头注意力"><a href="#为什么需要多头注意力" class="header-anchor">#</a> 为什么需要多头注意力</h3> <p>非常好的问题！多头注意力机制是Transformer架构的一个核心创新，它绝非可有可无的设计。简单来说，<strong>多头机制允许模型同时从不同的“表示子空间”和不同“角度”关注输入信息，极大地增强了模型的表征能力和泛化能力。</strong></p> <p>我们可以用一个生动的比喻来理解：</p> <blockquote><p><strong>想象一下，你作为一个主编在审阅一份复杂的报告（输入序列）。你不会只让一位专家（一个头）从头读到尾给出一个整体印象。相反，你会把报告分发给不同领域的专家：</strong></p> <ul><li><strong>一位专家负责检查事实和数据的准确性（“是什么”）。</strong></li> <li><strong>一位专家负责分析文章的逻辑结构和论证（“为什么”）。</strong></li> <li><strong>一位专家负责评估文笔和修辞（“如何表达”）。</strong></li></ul> <p><strong>最后，你（模型）会综合所有专家的意见（多个头的输出），形成一个更全面、更深刻、更可靠的整体判断。</strong></p></blockquote> <p>下面我们从技术层面详细拆解为什么需要“多头”而不是“单头”。</p> <h3 id="_1-克服单头注意力的局限性-增强模型的-视角"><a href="#_1-克服单头注意力的局限性-增强模型的-视角" class="header-anchor">#</a> 1. 克服单头注意力的局限性：增强模型的“视角”</h3> <p>单头注意力就像只有一个专家的团队，它只能学习到一种固定的关注模式。</p> <ul><li><strong>单一表示空间的限制</strong>：在单头注意力中，所有的词都被投射到同一个注意力空间里。这意味着对于同一个词，模型只能学习到一种与其他词的依赖关系。然而，语言关系是复杂且多方面的。</li> <li><strong>举例说明</strong>：考虑句子 <code>“The animal didn’t cross the street because it was too tired.”</code> <ul><li>这里的 <code>“it”</code> 指代的是 <code>“animal”</code> 还是 <code>“street”</code>？这需要进行<strong>语法分析</strong>（主谓一致）。</li> <li>同时，<code>“tired”</code> 通常用来形容有生命的 <code>“animal”</code> 而不是 <code>“street”</code>，这需要进行<strong>语义分析</strong>。</li> <li>一个单头注意力可能很难同时捕获这两种不同类型的关系。而多头注意力可以：
<ul><li><strong>一个头</strong> 专门关注语法结构，成功将 <code>“it”</code> 指向 <code>“animal”</code>。</li> <li><strong>另一个头</strong> 专门关注语义关联，成功将 <code>“tired”</code> 与 <code>“animal”</code> 联系起来。</li> <li>其他头可能去关注其他方面，比如 <code>“didn’t cross”</code> 与 <code>“street”</code> 的关系。</li></ul></li></ul></li></ul> <h3 id="_2-并行捕捉多种类型的关系"><a href="#_2-并行捕捉多种类型的关系" class="header-anchor">#</a> 2. 并行捕捉多种类型的关系</h3> <p>多头机制使模型能够<strong>并行地</strong>学习多种不同类型的依赖关系。</p> <ul><li><strong>关系类型的多样性</strong>：
<ul><li><strong>语法关系</strong>：如主谓一致、动宾关系。</li> <li><strong>语义关系</strong>：如同义、反义、因果关系。</li> <li><strong>指代关系</strong>：如上文的代词指代消解。</li> <li><strong>韵律或风格关系</strong>：在生成文本时关注节奏和风格一致性。</li></ul></li> <li><strong>分工协作</strong>：每个头可以自主地学习并专注于一种或几种特定的关系模式，而不需要由一个“超级头”来强行学习所有模式。这种分工使得学习过程更高效、更专精。</li></ul> <h3 id="_3-增加模型的表征能力和稳健性"><a href="#_3-增加模型的表征能力和稳健性" class="header-anchor">#</a> 3. 增加模型的表征能力和稳健性</h3> <ul><li><strong>分布式表征</strong>：通过将输入投影到多个不同的子空间，模型创建了输入的多种分布式表示。这大大丰富了模型的表征能力，使其能够表达更复杂的功能。</li> <li><strong>类似集成学习</strong>：多头注意力在精神上类似于机器学习中的<strong>集成学习</strong>。通过组合多个相对独立的“弱学习者”（每个头），最终模型会变得更强大、更稳健。即使某个头的注意力计算出现了偏差或错误，其他头的正确信息也可以对其进行补偿，从而提高了模型的容错能力。</li></ul> <h3 id="技术实现简述"><a href="#技术实现简述" class="header-anchor">#</a> 技术实现简述</h3> <p>在技术上，多头注意力的实现非常优雅：</p> <ol><li><strong>线性投影</strong>：对于给定的输入，通过 <code>h</code> 个（头的数量）不同的线性投影矩阵，分别生成 <code>h</code> 套 <strong>Query、Key、Value</strong> 向量。</li> <li><strong>并行计算</strong>：在这 <code>h</code> 套投影上并行地执行缩放点积注意力计算，得到 <code>h</code> 个输出矩阵。</li> <li><strong>拼接与融合</strong>：将这 <code>h</code> 个输出矩阵拼接起来，最后通过一个线性层进行融合，将信息整合回原始的维度。</li></ol> <p>这个过程确保了每个头都有自己独立的参数，可以学习不同的投影方式，从而关注信息的不同方面。</p> <h3 id="总结-为什么需要-多头"><a href="#总结-为什么需要-多头" class="header-anchor">#</a> 总结：为什么需要“多头”？</h3> <table><thead><tr><th style="text-align:left;">方面</th> <th style="text-align:left;">单头注意力</th> <th style="text-align:left;">多头注意力</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>视角</strong></td> <td style="text-align:left;">单一视角，一种关注模式</td> <td style="text-align:left;"><strong>多视角</strong>，多种关注模式</td></tr> <tr><td style="text-align:left;"><strong>关系捕捉</strong></td> <td style="text-align:left;">可能混淆或无法同时捕捉多种关系</td> <td style="text-align:left;"><strong>并行捕捉</strong>语法、语义、指代等多种关系</td></tr> <tr><td style="text-align:left;"><strong>稳健性</strong></td> <td style="text-align:left;">相对脆弱，容易受个别错误影响</td> <td style="text-align:left;"><strong>更稳健</strong>，类似集成学习，容错性强</td></tr> <tr><td style="text-align:left;"><strong>表征能力</strong></td> <td style="text-align:left;">有限</td> <td style="text-align:left;"><strong>显著增强</strong>，通过分布式表征</td></tr></tbody></table> <p><strong>总而言之，多头注意力机制为模型提供了同时从不同角度审视和理解输入序列的能力。它是对单一注意力机制的强大扩展，是Transformer能够深刻理解复杂语言结构和语义关系，并在众多NLP任务中取得突破性成果的关键原因之一。</strong></p> <h3 id="编码-解码"><a href="#编码-解码" class="header-anchor">#</a> 编码  解码</h3> <p>好的，这是一个非常核心的概念。在大型语言模型中，“编码器”、“解码器”和“编解码器”代表了三种根本不同的架构设计，它们决定了模型的<strong>训练目标</strong>、<strong>工作原理</strong>和<strong>适用场景</strong>。</p> <p>简单来说，它们的区别源于对 <strong>“注意力机制”的不同使用方式</strong>。</p> <p>为了更直观地理解这三者的工作流程和适用场景，可以参考下面的流程图：</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">flowchart</span> TD
    <span class="token keyword">subgraph</span> A <span class="token text string">[编码器-仅编码架构]</span>
        <span class="token keyword">direction</span> LR
        A1<span class="token text string">[输入文本]</span> <span class="token arrow operator">--&gt;</span> A2<span class="token text string">[“编码器&lt;br&gt;（双向注意力）”]</span> <span class="token arrow operator">--&gt;</span> A3<span class="token text string">[“输出: 每个token的&lt;br&gt;上下文表征”]</span>
    <span class="token keyword">end</span>

    <span class="token keyword">subgraph</span> B <span class="token text string">[解码器-仅解码架构]</span>
        <span class="token keyword">direction</span> LR
        B1<span class="token text string">[“输入: 自动回归&lt;br&gt;（如上文）”]</span> <span class="token arrow operator">--&gt;</span> B2<span class="token text string">[“解码器&lt;br&gt;（因果掩码注意力）”]</span> <span class="token arrow operator">--&gt;</span> B3<span class="token text string">[“输出: 下一个token的概率”]</span>
    <span class="token keyword">end</span>
    
    <span class="token keyword">subgraph</span> C <span class="token text string">[编码器-解码器架构]</span>
        <span class="token keyword">direction</span> LR
        C1<span class="token text string">[源文本]</span> <span class="token arrow operator">--&gt;</span> C2<span class="token text string">[“编码器&lt;br&gt;（双向注意力）”]</span>
        C2 <span class="token arrow operator">--&gt;</span> C3<span class="token text string">[“上下文向量”]</span>
        C3 <span class="token arrow operator">--&gt;</span> C4<span class="token text string">[“解码器&lt;br&gt;（因果掩码注意力）”]</span>
        C4 <span class="token arrow operator">--&gt;</span> C5<span class="token text string">[目标文本]</span>
    <span class="token keyword">end</span>

    A ~~~ B ~~~ C
    
    A <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span> <span class="token label property">“适用: 文本分类， 命名实体识别， 情感分析”</span> <span class="token arrow operator">--&gt;</span></span> A_Scene<span class="token text string">[“理解任务”]</span>
    B <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span> <span class="token label property">“适用: 文本生成， 代码补全， 创意写作”</span> <span class="token arrow operator">--&gt;</span></span> B_Scene<span class="token text string">[“生成任务”]</span>
    C <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span> <span class="token label property">“适用: 翻译， 摘要， 问答”</span> <span class="token arrow operator">--&gt;</span></span> C_Scene<span class="token text string">[“转换任务”]</span>
</code></pre></div><p>下面，我们详细解析这三种架构。</p> <hr> <h3 id="_1-编码器-仅编码架构"><a href="#_1-编码器-仅编码架构" class="header-anchor">#</a> 1. 编码器-仅编码架构</h3> <ul><li><strong>核心特征</strong>：使用<strong>双向注意力</strong>。在处理一个词时，它可以同时关注到<strong>输入序列中所有位置</strong>的词，包括它左边和右边的词。</li> <li><strong>训练目标</strong>：通常采用 <strong>“掩码语言建模”</strong>。随机遮盖输入中的一些词（例如，把“我爱吃苹果”中的“吃”遮住），然后让模型根据上下文（“我”、“爱”、“<MASK>”、“苹果”）来预测被遮盖的词。</MASK></li> <li><strong>工作方式</strong>：
<ol><li>读取整个输入序列。</li> <li>为序列中的每个词生成一个<strong>富含上下文信息</strong>的向量表示。</li></ol></li> <li><strong>代表模型</strong>：<strong>BERT</strong>、<strong>RoBERTa</strong>。</li> <li><strong>优势</strong>：非常擅长<strong>理解任务</strong>。因为它能同时看到整个上下文，所以对语言的理解非常深刻。</li> <li><strong>典型应用</strong>：
<ul><li><strong>文本分类</strong>（如情感分析、垃圾邮件识别）</li> <li><strong>自然语言推理</strong>（判断两个句子的逻辑关系）</li> <li><strong>命名实体识别</strong>（从文本中提取人名、地名等）</li> <li><strong>问答</strong>（从给定的段落中抽取答案）</li></ul></li></ul> <hr> <h3 id="_2-解码器-仅解码架构"><a href="#_2-解码器-仅解码架构" class="header-anchor">#</a> 2. 解码器-仅解码架构</h3> <ul><li><strong>核心特征</strong>：使用<strong>因果注意力</strong>或<strong>掩码注意力</strong>。在处理一个词时，它只能关注到<strong>该词之前（左边）</strong> 的所有词，而不能看到未来的词。</li> <li><strong>训练目标</strong>：通常采用 <strong>“自回归语言建模”</strong>。给定前文，预测下一个词。例如，输入“我”，预测“爱”；输入“我爱”，预测“吃”；输入“我爱吃”，预测“苹果”。</li> <li><strong>工作方式</strong>：
<ol><li>从一个起始符（如 <code>&lt;s&gt;</code>) 开始。</li> <li>根据之前生成的所有词，逐个预测下一个词。</li> <li>将新生成的词作为输入的一部分，继续预测，直到生成结束符。</li></ol></li> <li><strong>代表模型</strong>：<strong>GPT系列</strong>（GPT-3, ChatGPT）、<strong>LLaMA</strong>、<strong>Bloom</strong>。</li> <li><strong>优势</strong>：非常擅长<strong>生成任务</strong>。由于其自回归的特性，它天生适合生成连贯的、逐字输出的文本。</li> <li><strong>典型应用</strong>：
<ul><li><strong>文本生成</strong>（写文章、写故事、写邮件）</li> <li><strong>代码补全</strong></li> <li><strong>对话系统</strong>（ChatGPT）</li> <li><strong>创意写作</strong></li></ul></li></ul> <hr> <h3 id="_3-编码器-解码器架构"><a href="#_3-编码器-解码器架构" class="header-anchor">#</a> 3. 编码器-解码器架构</h3> <ul><li><strong>核心特征</strong>：<strong>结合了前两者</strong>。编码器使用双向注意力读取源序列，解码器使用因果注意力生成目标序列。两者之间通过一个<strong>交叉注意力</strong> 层连接。</li> <li><strong>训练目标</strong>：通常采用 <strong>“序列到序列”</strong> 学习。给定一个输入序列，生成一个对应的输出序列。</li> <li><strong>工作方式</strong>：
<ol><li><strong>编码器</strong>：读取并理解整个<strong>源序列</strong>（如英文句子“I love you”），将其编码为一组上下文向量。</li> <li><strong>解码器</strong>：利用编码器提供的信息，并基于<strong>自回归</strong>的方式，逐步生成<strong>目标序列</strong>（如中文句子“我爱你”）。</li> <li><strong>交叉注意力</strong>：在解码器生成每一个词时，它会通过交叉注意力机制去“询问”编码器：“基于我目前生成的内容，源序列中的哪些部分最值得关注？”</li></ol></li> <li><strong>代表模型</strong>：<strong>T5</strong>、<strong>BART</strong>、<strong>原始Transformer</strong>（论文中用于机器翻译的模型）。</li> <li><strong>优势</strong>：非常擅长<strong>转换任务</strong>。需要根据一个序列，生成另一个不同长度、不同结构或不同语言的序列。</li> <li><strong>典型应用</strong>：
<ul><li><strong>机器翻译</strong></li> <li><strong>文本摘要</strong>（长文本 -&gt; 短摘要）</li> <li><strong>问答生成</strong>（根据文档生成问题和答案）</li> <li><strong>语义解析</strong>（自然语言 -&gt; SQL查询语句）</li></ul></li></ul> <hr> <h3 id="总结对比表格"><a href="#总结对比表格" class="header-anchor">#</a> 总结对比表格</h3> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">编码器-仅编码</th> <th style="text-align:left;">解码器-仅解码</th> <th style="text-align:left;">编码器-解码器</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>核心注意力</strong></td> <td style="text-align:left;">双向注意力</td> <td style="text-align:left;">因果/掩码注意力</td> <td style="text-align:left;">编码器：双向<br>解码器：因果 + <strong>交叉注意力</strong></td></tr> <tr><td style="text-align:left;"><strong>训练目标</strong></td> <td style="text-align:left;">掩码语言建模</td> <td style="text-align:left;">自回归语言建模</td> <td style="text-align:left;">序列到序列学习</td></tr> <tr><td style="text-align:left;"><strong>信息流</strong></td> <td style="text-align:left;">看到整个输入</td> <td style="text-align:left;">只能看到左侧上下文</td> <td style="text-align:left;">编码器看全源序列，解码器自回归生成目标序列</td></tr> <tr><td style="text-align:left;"><strong>核心能力</strong></td> <td style="text-align:left;"><strong>理解</strong></td> <td style="text-align:left;"><strong>生成</strong></td> <td style="text-align:left;"><strong>转换</strong></td></tr> <tr><td style="text-align:left;"><strong>代表模型</strong></td> <td style="text-align:left;">BERT, RoBERTa</td> <td style="text-align:left;">GPT系列, LLaMA</td> <td style="text-align:left;">T5, BART, 原始Transformer</td></tr> <tr><td style="text-align:left;"><strong>类比</strong></td> <td style="text-align:left;"><strong>阅读理解专家</strong></td> <td style="text-align:left;"><strong>故事讲述者</strong></td> <td style="text-align:left;"><strong>翻译官</strong></td></tr></tbody></table> <h3 id="现代llm的发展趋势"><a href="#现代llm的发展趋势" class="header-anchor">#</a> 现代LLM的发展趋势</h3> <p>近年来，一个明显的趋势是<strong>解码器-仅解码架构</strong>成为了大型语言模型的主流选择（如GPT、LLaMA）。原因是：</p> <ol><li><strong>生成是更通用的能力</strong>：一个强大的生成模型，可以通过提示工程来完成理解任务（例如，情感分类可以通过让模型生成“正面”或“负面”来实现），但一个纯粹的理解模型很难完成流畅的生成任务。</li> <li><strong>扩展性定律</strong>：解码器架构在模型规模、数据量扩大时，展现出更优的性能 scaling law。</li></ol> <p>然而，编码器-解码器架构在特定的序列到序列任务（如翻译、摘要）上依然具有其独特优势和价值。理解它们的区别，有助于我们根据具体任务选择合适的模型。</p> <h3 id="在gpt-模型中-什么是温度系数"><a href="#在gpt-模型中-什么是温度系数" class="header-anchor">#</a> 在GPT 模型中，什么是温度系数？</h3> <p>这是一个非常关键的概念，特别是在使用像GPT这样的生成式模型时。温度系数是一个控制生成文本<strong>随机性和创造性</strong>的超参数。</p> <p>我们可以用一个非常形象的比喻来理解它：</p> <blockquote><p><strong>温度系数就像是控制模型“想象力”的旋钮。</strong></p></blockquote> <p>下面我们来详细分解这个旋钮的作用。</p> <h3 id="_1-它在哪里起作用"><a href="#_1-它在哪里起作用" class="header-anchor">#</a> 1. 它在哪里起作用？</h3> <p>在GPT模型生成每个新词（token）时，它都会计算词汇表中所有可能的下一个词的概率分布。例如，在句子 <code>“今天天气真”</code> 后面，可能的概率分布是：</p> <ul><li><code>“好”</code>：0.7</li> <li><code>“不错”</code>：0.15</li> <li><code>“坏”</code>：0.1</li> <li><code>“糟糕”</code>：0.05</li></ul> <p><strong>温度系数就是在模型计算出这个原始概率分布之后，但在最终根据这个分布抽样选择下一个词之前，施加的一个调整步骤。</strong></p> <h3 id="_2-它是如何工作的"><a href="#_2-它是如何工作的" class="header-anchor">#</a> 2. 它是如何工作的？</h3> <p>温度系数的数学操作很简单：它<strong>重新调整</strong>这个概率分布，改变其“形状”。</p> <ul><li><strong>给定原始概率分布 ( P(x) )</strong></li> <li><strong>应用温度 ( T ) 后的新分布 ( P_T(x) ) 为：</strong>
[
P_T(x) = \frac{\exp(\log(P(x)) / T)}{\sum \exp(\log(P(x)) / T)}
]
你可以简单理解为：<strong>用原始概率的 ( \frac{1}{T} ) 次方，然后再重新归一化，确保所有概率之和为1。</strong></li></ul> <h3 id="_3-不同温度值下的效果"><a href="#_3-不同温度值下的效果" class="header-anchor">#</a> 3. 不同温度值下的效果</h3> <p>温度系数的取值通常大于0。我们可以分为三种情况来看：</p> <p>为了更直观地对比不同温度系数的效果，我们可以看下面这个示意图，它展示了同一概率分布在不同温度下的变化：</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code>xychart-beta
    title “下一个词”的概率分布受温度系数影响示意图
    <span class="token arrow operator">x-</span>axis <span class="token text string">[“好”， “不错”， “坏”， “糟糕”]</span>
    y-axis “概率” 0 <span class="token arrow operator">--&gt;</span> 100
    bar <span class="token text string">[70， 15， 10， 5]</span>
    line <span class="token text string">[90， 7， 2， 1]</span>
</code></pre></div><p>结合上图，我们来分析三种典型情况：</p> <h4 id="a-低温-t-1-例如-t-0-2"><a href="#a-低温-t-1-例如-t-0-2" class="header-anchor">#</a> <strong>a) 低温（ ( T &lt; 1 )，例如 ( T = 0.2 ) ）</strong></h4> <ul><li><strong>效果</strong>：<strong>“锐化”概率分布</strong>。如图中蓝色条形所示，高概率的词（“好”）的概率被显著增大，而低概率的词（“糟糕”）的概率被进一步压制。</li> <li><strong>生成文本特点</strong>：
<ul><li><strong>确定性高，更保守、可靠</strong>。</li> <li>模型会选择最安全、最常见的词。</li> <li>输出非常一致和集中，如果你多次生成，结果会非常相似。</li></ul></li> <li><strong>适用场景</strong>：
<ul><li><strong>事实性问答</strong>（你需要一个准确的答案）。</li> <li><strong>代码生成</strong>（需要准确、可预测的语法）。</li> <li>任何需要高确定性和一致性的任务。</li></ul></li></ul> <h4 id="b-高温-t-1-例如-t-1-5"><a href="#b-高温-t-1-例如-t-1-5" class="header-anchor">#</a> <strong>b) 高温（ ( T &gt; 1 )，例如 ( T = 1.5 ) ）</strong></h4> <ul><li><strong>效果</strong>：<strong>“平滑”概率分布</strong>。如图中红色曲线所示，概率分布变得平缓。高概率词的权重下降，低概率词的权重上升。</li> <li><strong>生成文本特点</strong>：
<ul><li><strong>随机性高，更创造性、多样化</strong>。</li> <li>模型更愿意选择一些不寻常的词，输出可能更出人意料、更有趣，但也可能更不连贯甚至荒谬。</li> <li>如果你多次生成，结果会差异很大。</li></ul></li> <li><strong>适用场景</strong>：
<ul><li><strong>创意写作</strong>（写诗歌、故事、构思）。</li> <li><strong>头脑风暴</strong>。</li> <li><strong>对话机器人</strong>（希望回复更自然、不那么机械）。</li></ul></li></ul> <h4 id="c-温度-1-t-1"><a href="#c-温度-1-t-1" class="header-anchor">#</a> <strong>c) 温度 = 1（ ( T = 1 ) ）</strong></h4> <ul><li><strong>效果</strong>：<strong>不改变原始分布</strong>。这是模型的“原始”状态，不进行任何调整。</li> <li><strong>生成文本特点</strong>：平衡了确定性和随机性。</li></ul> <h3 id="总结与类比-2"><a href="#总结与类比-2" class="header-anchor">#</a> 总结与类比</h3> <table><thead><tr><th style="text-align:left;">温度设置</th> <th style="text-align:left;">概率分布变化</th> <th style="text-align:left;">模型行为</th> <th style="text-align:left;">好比是...</th> <th style="text-align:left;">适用场景</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>低温度（T &lt; 1）</strong></td> <td style="text-align:left;">被锐化</td> <td style="text-align:left;"><strong>保守的专家</strong></td> <td style="text-align:left;">一个总是给出标准答案的学霸</td> <td style="text-align:left;">代码生成、事实问答</td></tr> <tr><td style="text-align:left;"><strong>高温度（T &gt; 1）</strong></td> <td style="text-align:left;">被平滑</td> <td style="text-align:left;"><strong>狂放的艺术家</strong></td> <td style="text-align:left;">一个天马行空的诗人</td> <td style="text-align:left;">创意写作、构思</td></tr> <tr><td style="text-align:left;"><strong>温度 = 1</strong></td> <td style="text-align:left;">不变</td> <td style="text-align:left;"><strong>平衡的助手</strong></td> <td style="text-align:left;">一个正常的对话者</td> <td style="text-align:left;">通用聊天、内容创作</td></tr></tbody></table> <h3 id="另一个相关概念-top-p-核采样"><a href="#另一个相关概念-top-p-核采样" class="header-anchor">#</a> 另一个相关概念：Top-p（核采样）</h3> <p>在实际应用中，温度系数常常与另一个叫做 <strong>Top-p</strong> 或 <strong>核采样</strong> 的参数配合使用。Top-p 的作用是从概率分布中截取一个候选集合（累积概率刚刚超过p的最高概率词），然后从这个集合中抽样。</p> <ul><li><strong>温度</strong> 控制<strong>整个分布</strong>的形状。</li> <li><strong>Top-p</strong> 控制<strong>候选词的范围</strong>。</li></ul> <p>通常，<strong>较低的温度（如0.7）和较低的Top-p（如0.9）</strong> 组合使用，可以在保持创造性的同时，避免选择那些概率极低、毫无意义的词，从而得到质量较高的输出。</p> <p><strong>结论：</strong> 温度系数是一个强大的工具，让你能够根据具体任务，在模型的“确定性”和“创造性”之间找到最佳平衡点。</p> <h3 id="旋转位置编码"><a href="#旋转位置编码" class="header-anchor">#</a> 旋转位置编码：</h3> <p>好的，我们来详细讲解一下<strong>旋转位置编码</strong>，它正是目前引领潮流的大型语言模型（如 <strong>LLaMA</strong>、<strong>GPT-NeoX</strong>、<strong>ChatGLM</strong> 等）所采用的位置编码技术。</p> <h3 id="核心思想-用-旋转-来注入位置信息"><a href="#核心思想-用-旋转-来注入位置信息" class="header-anchor">#</a> 核心思想：用“旋转”来注入位置信息</h3> <p>RoPE 的灵感非常巧妙。它的基本思想是：<strong>通过绝对位置的形式，实现相对位置的依赖关系。</strong></p> <p>换句话说，它给每个位置一个独特的“旋转”，使得模型在计算注意力时，两个词之间的注意力分数能够自然地体现出它们之间的距离（相对位置），而不仅仅是它们各自在哪里（绝对位置）。</p> <hr> <h3 id="_1-它要解决什么问题"><a href="#_1-它要解决什么问题" class="header-anchor">#</a> 1. 它要解决什么问题？</h3> <p>在 Transformer 中，自注意力机制本身是<strong>置换不变</strong>的。这意味着打乱输入序列的顺序，输出序列的注意力权重总和是不变的。这显然不符合语言线性依赖的特性。因此，我们需要一种方法将词在序列中的<strong>位置信息</strong>注入到模型中。</p> <ul><li><strong>绝对位置信息</strong>：一个词是序列中的第几个。</li> <li><strong>相对位置信息</strong>：两个词之间相隔多远。</li></ul> <p>相对位置信息对于理解语言至关重要。例如，在判断代词 <code>“它”</code> 指代什么时，模型需要知道 <code>“它”</code> 和候选名词之间的相对距离。</p> <p>RoPE 的优雅之处在于，它同时提供了<strong>绝对位置</strong>和<strong>相对位置</strong>的编码。</p> <hr> <h3 id="_2-rope-是如何工作的-直观理解"><a href="#_2-rope-是如何工作的-直观理解" class="header-anchor">#</a> 2. RoPE 是如何工作的？（直观理解）</h3> <p>想象一下，我们将每个词的嵌入向量（一组数字）放置在一个高维的坐标系中。RoPE 的做法是：<strong>根据词在序列中的位置，来“旋转”这个向量的每一维</strong>。</p> <ul><li><strong>位置 1</strong> 的词向量旋转一个角度 <code>θ₁</code>。</li> <li><strong>位置 2</strong> 的词向量旋转一个角度 <code>2 * θ₁</code>。</li> <li><strong>位置 m</strong> 的词向量旋转一个角度 <code>m * θ₁</code>。</li></ul> <p><strong>这个“旋转”操作是在向量的二维子空间上进行的。</strong> 一个高维向量可以被看作是由许多个二维平面组成的。RoPE 对每一个这样的二维平面都执行独立的旋转操作，旋转的角度由词的位置决定。</p> <hr> <h3 id="_3-数学上的巧妙之处"><a href="#_3-数学上的巧妙之处" class="header-anchor">#</a> 3. 数学上的巧妙之处</h3> <p>现在来看最精彩的部分：当模型计算注意力分数（通过 Query 和 Key 向量的点积）时。</p> <ul><li>一个在位置 <code>m</code> 的词 <code>q</code> 的 Query 向量是 <code>q_m</code>。</li> <li>一个在位置 <code>n</code> 的词 <code>k</code> 的 Key 向量是 <code>k_n</code>。</li></ul> <p>在应用了 RoPE 之后，它们的点积变为：
[
\langle f(q, m), f(k, n) \rangle = g(q, k, m-n)
]</p> <p><strong>这个公式告诉我们：</strong> 加入了 RoPE 位置编码后的 Query 和 Key 的点积，<strong>只依赖于原始向量 <code>q</code> 和 <code>k</code>，以及它们之间的相对位置 <code>(m-n)</code></strong>。</p> <p>这正是我们想要的！注意力机制现在可以感知到相对位置了。两个词相隔 <code>(m-n)</code> 个位置，无论它们出现在文本的哪个绝对位置，它们之间的注意力模式都是一致的。</p> <hr> <h3 id="_4-rope-的主要优势"><a href="#_4-rope-的主要优势" class="header-anchor">#</a> 4. RoPE 的主要优势</h3> <ol><li><p><strong>强大的外推性</strong></p> <ul><li>这是 RoPE 相对于传统正弦位置编码（如原始 Transformer 使用的）的一个巨大优势。模型在训练时只看到了某个长度（如 2048）的序列，但在推理时，如果给它一个更长的序列（如 4096），RoPE 仍然可以为这些没见过的位置生成合理的编码。这是因为旋转操作（<code>m * θ</code>）对于更大的 <code>m</code> 在数学上是定义良好的，尽管性能可能会逐渐下降。后来的 <strong>NTK-aware Scaled RoPE</strong> 等技术进一步增强了长文本外推能力。</li></ul></li> <li><p><strong>可学习的相对位置依赖</strong></p> <ul><li>由于相对位置信息 <code>(m-n)</code> 被编码在了注意力分数中，模型可以学习到复杂的依赖模式。例如，它可以学到“相邻的词通常关系更紧密”，或者“动词应该关注它前面不远的主语”。</li></ul></li> <li><p><strong>理论上的优雅与实现的稳定性</strong></p> <ul><li>整个过程是线性的、可逆的，没有需要学习的参数（在基础形式中）。它不会破坏原始向量空间的信息，只是进行了旋转。这使得训练更加稳定。</li></ul></li></ol> <hr> <h3 id="总结与类比-3"><a href="#总结与类比-3" class="header-anchor">#</a> 总结与类比</h3> <p>你可以把 RoPE 想象成一个 <strong>“文字的时钟”</strong>：</p> <ul><li>序列中的每个词都根据其位置，被分配了一个独特的“时间”（旋转角度）。</li> <li>当两个词要计算关联度时（Query 和 Key 的点积），模型就像在计算两个时钟的“时差”。</li> <li>这个“时差”（相对位置）决定了它们之间的关联强度，而不管这两个词出现在文章的“开头”还是“结尾”。</li></ul> <p>正是因为这种巧妙的设计，RoPE 成为了当今大型语言模型位置编码的事实标准，它完美地平衡了理论上的优雅和实际效果的卓越。</p> <hr> <h3 id="提示工程"><a href="#提示工程" class="header-anchor">#</a> 提示工程</h3> <p>这是一个至关重要的问题。对于ChatGPT而言，提示工程的重要性怎么强调都不过分。您可以将它理解为<strong>与这个强大但“陌生”的AI大脑进行高效、准确沟通的“用户手册”或“通用语言”</strong>。</p> <p>为什么它如此关键？主要有以下几个层面的原因：</p> <h3 id="_1-chatgpt的本质-一个-无状态-的预测引擎"><a href="#_1-chatgpt的本质-一个-无状态-的预测引擎" class="header-anchor">#</a> 1. ChatGPT的本质：一个“无状态”的预测引擎</h3> <p>首先要理解，ChatGPT没有真正的记忆或持续的“意识”。每次交互，它都只根据<strong>当前提示（Prompt）</strong> 来生成下一个词。提示是它理解你意图的<strong>唯一上下文</strong>。</p> <ul><li><strong>糟糕的提示</strong>：<code>&quot;总结一下。&quot;</code> (模型会困惑：总结什么？)</li> <li><strong>良好的提示</strong>：<code>&quot;请用三段话总结以下文章的核心观点：[粘贴文章内容]&quot;</code></li></ul> <p>提示工程就是学习如何为这个“无状态”的引擎提供最清晰、最完整的指令和背景信息。</p> <h3 id="_2-弥补-思维链-的缺口-引导模型展示推理过程"><a href="#_2-弥补-思维链-的缺口-引导模型展示推理过程" class="header-anchor">#</a> 2. 弥补“思维链”的缺口：引导模型展示推理过程</h3> <p>人类在解决复杂问题时会一步步思考，但模型的内部推理过程对用户是黑箱。提示工程可以引导模型<strong>将其“思维链”外化</strong>。</p> <ul><li><strong>直接提问</strong>：<code>&quot;小明有5个苹果，吃了2个，又买了3个，他现在有几个苹果？&quot;</code> <ul><li><em>模型可能直接回答：<code>&quot;6个&quot;</code></em> (对，但不知道它是否蒙对的)</li></ul></li> <li><strong>工程化提示</strong>：<code>&quot;请按步骤推理：小明有5个苹果。他吃了2个，所以剩下5-2=3个。他又买了3个，所以现在有3+3=6个。因此，他现在有6个苹果。&quot;</code> <ul><li><em>模型会模仿这种逐步推理的模式，输出过程后再给出答案。</em> 这不仅提高了答案的准确性，也让你能验证它的逻辑。</li></ul></li></ul> <h3 id="_3-设定角色与人格-控制输出的风格和立场"><a href="#_3-设定角色与人格-控制输出的风格和立场" class="header-anchor">#</a> 3. 设定角色与人格：控制输出的风格和立场</h3> <p>ChatGPT具有很强的可塑性。通过提示，你可以让它扮演任何角色，从而极大地改变输出的风格和内容。</p> <ul><li><strong>普通提问</strong>：<code>&quot;解释一下黑洞。&quot;</code></li> <li><strong>角色扮演提示</strong>：<code>&quot;你是一位顶尖的 astrophysicist，正在为一位充满好奇的10岁小孩解释黑洞。请使用生动形象的比喻，避免复杂的数学公式。&quot;</code></li></ul> <p>通过角色设定，你锁定了模型的回答视角、知识深度和语言风格，使其输出更符合你的特定需求。</p> <h3 id="_4-应对-幻觉-与提高事实准确性"><a href="#_4-应对-幻觉-与提高事实准确性" class="header-anchor">#</a> 4. 应对“幻觉”与提高事实准确性</h3> <p>模型有时会自信地编造信息（幻觉）。提示工程是约束模型、让其忠于事实的强大工具。</p> <ul><li><strong>风险提示</strong>：<code>&quot;介绍一下XYZ公司的历史。&quot;</code> (如果XYZ公司不存在或不著名，模型可能会编造)</li> <li><strong>安全提示</strong>：<code>&quot;根据已知的公开信息，介绍一下XYZ公司的历史。如果你不确定或没有相关信息，请明确说明。&quot;</code> <ul><li>你还可以附加指令：<code>&quot;请仅基于以下提供的资料回答：[粘贴可靠资料]&quot;</code>，这能将模型的知识范围限定在你提供的可信信息内。</li></ul></li></ul> <h3 id="_5-实现复杂、多步骤的任务分解"><a href="#_5-实现复杂、多步骤的任务分解" class="header-anchor">#</a> 5. 实现复杂、多步骤的任务分解</h3> <p>对于复杂任务，一个简单的指令会让模型不知所措。提示工程教你如何将大任务拆解为清晰的、可执行的步骤。</p> <ul><li><strong>混乱的提示</strong>：<code>&quot;帮我写一份市场计划，要关于新产品，包括社交媒体、预算和竞争对手分析。&quot;</code></li> <li><strong>工程化的提示</strong>：
<ol><li><strong>目标</strong>：<code>&quot;为一款新的环保水瓶制定一份简要的市场计划。&quot;</code></li> <li><strong>步骤一</strong>：<code>&quot;首先，分析当前市场上3个主要竞争对手及其优劣势。&quot;</code></li> <li><strong>步骤二</strong>：<code>&quot;其次，提出一个针对千禧一代的社交媒体推广策略，包括建议使用的平台和内容类型。&quot;</code></li> <li><strong>步骤三</strong>：<code>&quot;最后，草拟一个初步的月度预算分配表。&quot;</code></li></ol></li></ul> <p>通过结构化提示，你引导模型有序地完成任务，确保不遗漏任何关键部分。</p> <h3 id="总结-提示工程是解锁潜力的钥匙"><a href="#总结-提示工程是解锁潜力的钥匙" class="header-anchor">#</a> 总结：提示工程是解锁潜力的钥匙</h3> <p>想象一下，ChatGPT是一个功能无比强大的瑞士军刀，但如果没有说明书，你可能只会用它来开瓶盖。提示工程就是那份说明书，它教你如何：</p> <ul><li><strong>使用正确的工具（角色设定）</strong></li> <li><strong>以正确的顺序和力道使用（任务分解与思维链）</strong></li> <li><strong>确保你的操作安全有效（减少幻觉）</strong></li></ul> <p><strong>最终，提示工程的重要性在于：它将在你和AI之间单向的、模糊的指令，转变为一种双向的、精确的“协作”。</strong> 它让你从一个被动的用户，转变为一个主动的“导演”，能够精准地引导这个庞大的计算资源，为你产出最高价值的结果。在AI能力既定的情况下，提示工程的好坏直接决定了输出质量的成败。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-prompt-design-提示设计-提示工程" class="sidebar-link reco-side-_1-prompt-design-提示设计-提示工程" data-v-b57cc07c>1. Prompt Design（提示设计 / 提示工程）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-prompt-tuning-提示微调" class="sidebar-link reco-side-_2-prompt-tuning-提示微调" data-v-b57cc07c>2. Prompt Tuning（提示微调）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-fine-tuning-微调-通常指全量微调" class="sidebar-link reco-side-_3-fine-tuning-微调-通常指全量微调" data-v-b57cc07c>3. Fine-Tuning（微调，通常指全量微调）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#三者的直观对比" class="sidebar-link reco-side-三者的直观对比" data-v-b57cc07c>三者的直观对比</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结与关系" class="sidebar-link reco-side-总结与关系" data-v-b57cc07c>总结与关系</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-prefix-tuning" class="sidebar-link reco-side-_3-prefix-tuning" data-v-b57cc07c>3. Prefix Tuning</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_4-相比lora-adalora的改进点是什么" class="sidebar-link reco-side-_4-相比lora-adalora的改进点是什么" data-v-b57cc07c>4. 相比LORA，AdaLoRA的改进点是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#标准lora的简要回顾" class="sidebar-link reco-side-标准lora的简要回顾" data-v-b57cc07c>标准LoRA的简要回顾</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#adalora的核心改进" class="sidebar-link reco-side-adalora的核心改进" data-v-b57cc07c>AdaLoRA的核心改进</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#对比表格-lora-vs-adalora" class="sidebar-link reco-side-对比表格-lora-vs-adalora" data-v-b57cc07c>对比表格：LoRA vs. AdaLoRA</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结与类比" class="sidebar-link reco-side-总结与类比" data-v-b57cc07c>总结与类比</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#方法一-基于固定结构化子集的稀疏微调" class="sidebar-link reco-side-方法一-基于固定结构化子集的稀疏微调" data-v-b57cc07c>方法一：基于固定结构化子集的稀疏微调</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#方法二-基于动态参数选择的稀疏微调" class="sidebar-link reco-side-方法二-基于动态参数选择的稀疏微调" data-v-b57cc07c>方法二：基于动态参数选择的稀疏微调</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#方法三-基于附加稀疏适配器的微调-目前最流行" class="sidebar-link reco-side-方法三-基于附加稀疏适配器的微调-目前最流行" data-v-b57cc07c>方法三：基于附加稀疏适配器的微调（目前最流行）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-数据层面" class="sidebar-link reco-side-_1-数据层面" data-v-b57cc07c>1. 数据层面</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-训练方法与超参数层面" class="sidebar-link reco-side-_2-训练方法与超参数层面" data-v-b57cc07c>2. 训练方法与超参数层面</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-能力与对齐的根本性权衡" class="sidebar-link reco-side-_3-能力与对齐的根本性权衡" data-v-b57cc07c>3. 能力与对齐的根本性权衡</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#如何缓解这些问题" class="sidebar-link reco-side-如何缓解这些问题" data-v-b57cc07c>如何缓解这些问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#核心挑战-让模型理解-上下文" class="sidebar-link reco-side-核心挑战-让模型理解-上下文" data-v-b57cc07c>核心挑战：让模型理解“上下文”</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#微调方法概览" class="sidebar-link reco-side-微调方法概览" data-v-b57cc07c>微调方法概览</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#微调步骤详解" class="sidebar-link reco-side-微调步骤详解" data-v-b57cc07c>微调步骤详解</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#高级技巧与注意事项" class="sidebar-link reco-side-高级技巧与注意事项" data-v-b57cc07c>高级技巧与注意事项</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结-2" class="sidebar-link reco-side-总结-2" data-v-b57cc07c>总结</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#transformer-基本流程" class="sidebar-link reco-side-transformer-基本流程" data-v-b57cc07c>Transformer 基本流程</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#第零步-输入与输出表示" class="sidebar-link reco-side-第零步-输入与输出表示" data-v-b57cc07c>第零步：输入与输出表示</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#第一步-编码器处理输入" class="sidebar-link reco-side-第一步-编码器处理输入" data-v-b57cc07c>第一步：编码器处理输入</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#第二步-解码器生成输出" class="sidebar-link reco-side-第二步-解码器生成输出" data-v-b57cc07c>第二步：解码器生成输出</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#第三步-输出预测" class="sidebar-link reco-side-第三步-输出预测" data-v-b57cc07c>第三步：输出预测</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#核心总结" class="sidebar-link reco-side-核心总结" data-v-b57cc07c>核心总结</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#为什么需要多头注意力" class="sidebar-link reco-side-为什么需要多头注意力" data-v-b57cc07c>为什么需要多头注意力</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-克服单头注意力的局限性-增强模型的-视角" class="sidebar-link reco-side-_1-克服单头注意力的局限性-增强模型的-视角" data-v-b57cc07c>1. 克服单头注意力的局限性：增强模型的“视角”</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-并行捕捉多种类型的关系" class="sidebar-link reco-side-_2-并行捕捉多种类型的关系" data-v-b57cc07c>2. 并行捕捉多种类型的关系</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-增加模型的表征能力和稳健性" class="sidebar-link reco-side-_3-增加模型的表征能力和稳健性" data-v-b57cc07c>3. 增加模型的表征能力和稳健性</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#技术实现简述" class="sidebar-link reco-side-技术实现简述" data-v-b57cc07c>技术实现简述</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结-为什么需要-多头" class="sidebar-link reco-side-总结-为什么需要-多头" data-v-b57cc07c>总结：为什么需要“多头”？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#编码-解码" class="sidebar-link reco-side-编码-解码" data-v-b57cc07c>编码  解码</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-编码器-仅编码架构" class="sidebar-link reco-side-_1-编码器-仅编码架构" data-v-b57cc07c>1. 编码器-仅编码架构</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-解码器-仅解码架构" class="sidebar-link reco-side-_2-解码器-仅解码架构" data-v-b57cc07c>2. 解码器-仅解码架构</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-编码器-解码器架构" class="sidebar-link reco-side-_3-编码器-解码器架构" data-v-b57cc07c>3. 编码器-解码器架构</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结对比表格" class="sidebar-link reco-side-总结对比表格" data-v-b57cc07c>总结对比表格</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#现代llm的发展趋势" class="sidebar-link reco-side-现代llm的发展趋势" data-v-b57cc07c>现代LLM的发展趋势</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#在gpt-模型中-什么是温度系数" class="sidebar-link reco-side-在gpt-模型中-什么是温度系数" data-v-b57cc07c>在GPT 模型中，什么是温度系数？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-它在哪里起作用" class="sidebar-link reco-side-_1-它在哪里起作用" data-v-b57cc07c>1. 它在哪里起作用？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-它是如何工作的" class="sidebar-link reco-side-_2-它是如何工作的" data-v-b57cc07c>2. 它是如何工作的？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-不同温度值下的效果" class="sidebar-link reco-side-_3-不同温度值下的效果" data-v-b57cc07c>3. 不同温度值下的效果</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结与类比-2" class="sidebar-link reco-side-总结与类比-2" data-v-b57cc07c>总结与类比</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#另一个相关概念-top-p-核采样" class="sidebar-link reco-side-另一个相关概念-top-p-核采样" data-v-b57cc07c>另一个相关概念：Top-p（核采样）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#旋转位置编码" class="sidebar-link reco-side-旋转位置编码" data-v-b57cc07c>旋转位置编码：</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#核心思想-用-旋转-来注入位置信息" class="sidebar-link reco-side-核心思想-用-旋转-来注入位置信息" data-v-b57cc07c>核心思想：用“旋转”来注入位置信息</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-它要解决什么问题" class="sidebar-link reco-side-_1-它要解决什么问题" data-v-b57cc07c>1. 它要解决什么问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-rope-是如何工作的-直观理解" class="sidebar-link reco-side-_2-rope-是如何工作的-直观理解" data-v-b57cc07c>2. RoPE 是如何工作的？（直观理解）</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-数学上的巧妙之处" class="sidebar-link reco-side-_3-数学上的巧妙之处" data-v-b57cc07c>3. 数学上的巧妙之处</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_4-rope-的主要优势" class="sidebar-link reco-side-_4-rope-的主要优势" data-v-b57cc07c>4. RoPE 的主要优势</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结与类比-3" class="sidebar-link reco-side-总结与类比-3" data-v-b57cc07c>总结与类比</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#提示工程" class="sidebar-link reco-side-提示工程" data-v-b57cc07c>提示工程</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_1-chatgpt的本质-一个-无状态-的预测引擎" class="sidebar-link reco-side-_1-chatgpt的本质-一个-无状态-的预测引擎" data-v-b57cc07c>1. ChatGPT的本质：一个“无状态”的预测引擎</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_2-弥补-思维链-的缺口-引导模型展示推理过程" class="sidebar-link reco-side-_2-弥补-思维链-的缺口-引导模型展示推理过程" data-v-b57cc07c>2. 弥补“思维链”的缺口：引导模型展示推理过程</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_3-设定角色与人格-控制输出的风格和立场" class="sidebar-link reco-side-_3-设定角色与人格-控制输出的风格和立场" data-v-b57cc07c>3. 设定角色与人格：控制输出的风格和立场</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_4-应对-幻觉-与提高事实准确性" class="sidebar-link reco-side-_4-应对-幻觉-与提高事实准确性" data-v-b57cc07c>4. 应对“幻觉”与提高事实准确性</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#_5-实现复杂、多步骤的任务分解" class="sidebar-link reco-side-_5-实现复杂、多步骤的任务分解" data-v-b57cc07c>5. 实现复杂、多步骤的任务分解</a></li><li class="level-3" data-v-b57cc07c><a href="/hmblog/modelstudy/deepseek-search.html#总结-提示工程是解锁潜力的钥匙" class="sidebar-link reco-side-总结-提示工程是解锁潜力的钥匙" data-v-b57cc07c>总结：提示工程是解锁潜力的钥匙</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/hmblog/assets/js/app.252ae38c.js" defer></script><script src="/hmblog/assets/js/7.5041dce4.js" defer></script><script src="/hmblog/assets/js/2.79670d2b.js" defer></script><script src="/hmblog/assets/js/1.1d6abb18.js" defer></script><script src="/hmblog/assets/js/72.194abe8d.js" defer></script><script src="/hmblog/assets/js/34.b26cede8.js" defer></script>
  </body>
</html>
