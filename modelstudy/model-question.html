<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>阶段一 | 寒梦的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/hmblog/logo.png">
    <meta name="description" content="宝剑锋从磨砺出，梅花香自苦寒来。">
    
    <link rel="preload" href="/hmblog/assets/css/0.styles.e7d53aa5.css" as="style"><link rel="preload" href="/hmblog/assets/js/app.252ae38c.js" as="script"><link rel="preload" href="/hmblog/assets/js/7.5041dce4.js" as="script"><link rel="preload" href="/hmblog/assets/js/2.79670d2b.js" as="script"><link rel="preload" href="/hmblog/assets/js/1.1d6abb18.js" as="script"><link rel="preload" href="/hmblog/assets/js/104.4e73c56a.js" as="script"><link rel="preload" href="/hmblog/assets/js/34.b26cede8.js" as="script"><link rel="prefetch" href="/hmblog/assets/js/10.63d0ad8f.js"><link rel="prefetch" href="/hmblog/assets/js/100.5613e6ba.js"><link rel="prefetch" href="/hmblog/assets/js/101.b8eb0459.js"><link rel="prefetch" href="/hmblog/assets/js/102.40868c51.js"><link rel="prefetch" href="/hmblog/assets/js/103.1f40d097.js"><link rel="prefetch" href="/hmblog/assets/js/105.cb525ef5.js"><link rel="prefetch" href="/hmblog/assets/js/106.252f49ca.js"><link rel="prefetch" href="/hmblog/assets/js/107.91d170e8.js"><link rel="prefetch" href="/hmblog/assets/js/108.8a514186.js"><link rel="prefetch" href="/hmblog/assets/js/109.f15844d7.js"><link rel="prefetch" href="/hmblog/assets/js/11.08937b90.js"><link rel="prefetch" href="/hmblog/assets/js/110.a0e27b36.js"><link rel="prefetch" href="/hmblog/assets/js/111.1c542559.js"><link rel="prefetch" href="/hmblog/assets/js/112.5fa57e84.js"><link rel="prefetch" href="/hmblog/assets/js/113.bfbfcd5a.js"><link rel="prefetch" href="/hmblog/assets/js/114.2e526e4d.js"><link rel="prefetch" href="/hmblog/assets/js/115.221e2f65.js"><link rel="prefetch" href="/hmblog/assets/js/116.a7726179.js"><link rel="prefetch" href="/hmblog/assets/js/117.22075f73.js"><link rel="prefetch" href="/hmblog/assets/js/118.459f31e3.js"><link rel="prefetch" href="/hmblog/assets/js/119.f7a33a09.js"><link rel="prefetch" href="/hmblog/assets/js/120.8b58a340.js"><link rel="prefetch" href="/hmblog/assets/js/121.277e1f1e.js"><link rel="prefetch" href="/hmblog/assets/js/122.ec3ae934.js"><link rel="prefetch" href="/hmblog/assets/js/123.514ade54.js"><link rel="prefetch" href="/hmblog/assets/js/124.6b6c2b7d.js"><link rel="prefetch" href="/hmblog/assets/js/125.a7fb1fbe.js"><link rel="prefetch" href="/hmblog/assets/js/126.b5ef252a.js"><link rel="prefetch" href="/hmblog/assets/js/127.d8121d6d.js"><link rel="prefetch" href="/hmblog/assets/js/128.40963707.js"><link rel="prefetch" href="/hmblog/assets/js/129.bf256481.js"><link rel="prefetch" href="/hmblog/assets/js/130.0031ec91.js"><link rel="prefetch" href="/hmblog/assets/js/131.4fe99cc5.js"><link rel="prefetch" href="/hmblog/assets/js/132.fcf1a74b.js"><link rel="prefetch" href="/hmblog/assets/js/133.ff8e24a1.js"><link rel="prefetch" href="/hmblog/assets/js/134.db2d31f5.js"><link rel="prefetch" href="/hmblog/assets/js/135.b152d9b0.js"><link rel="prefetch" href="/hmblog/assets/js/136.936be57e.js"><link rel="prefetch" href="/hmblog/assets/js/137.48f9d2b5.js"><link rel="prefetch" href="/hmblog/assets/js/138.3bdb70b7.js"><link rel="prefetch" href="/hmblog/assets/js/139.2c511f09.js"><link rel="prefetch" href="/hmblog/assets/js/14.0ac4aea5.js"><link rel="prefetch" href="/hmblog/assets/js/140.5f00d305.js"><link rel="prefetch" href="/hmblog/assets/js/141.41c9f925.js"><link rel="prefetch" href="/hmblog/assets/js/142.b37e8f1d.js"><link rel="prefetch" href="/hmblog/assets/js/143.20c71a9e.js"><link rel="prefetch" href="/hmblog/assets/js/144.17cece65.js"><link rel="prefetch" href="/hmblog/assets/js/145.978e7516.js"><link rel="prefetch" href="/hmblog/assets/js/146.94bdfed5.js"><link rel="prefetch" href="/hmblog/assets/js/147.f9c95b0c.js"><link rel="prefetch" href="/hmblog/assets/js/148.355cbcf5.js"><link rel="prefetch" href="/hmblog/assets/js/149.b1e46aaf.js"><link rel="prefetch" href="/hmblog/assets/js/15.2cac15c3.js"><link rel="prefetch" href="/hmblog/assets/js/150.b5a35472.js"><link rel="prefetch" href="/hmblog/assets/js/151.d309c32e.js"><link rel="prefetch" href="/hmblog/assets/js/152.fb9a950d.js"><link rel="prefetch" href="/hmblog/assets/js/153.c231397c.js"><link rel="prefetch" href="/hmblog/assets/js/154.2c76a2e9.js"><link rel="prefetch" href="/hmblog/assets/js/155.ad43ee17.js"><link rel="prefetch" href="/hmblog/assets/js/156.b0fe3a29.js"><link rel="prefetch" href="/hmblog/assets/js/157.d085315f.js"><link rel="prefetch" href="/hmblog/assets/js/158.9f11fbf4.js"><link rel="prefetch" href="/hmblog/assets/js/159.178d8a8a.js"><link rel="prefetch" href="/hmblog/assets/js/16.41c97ec9.js"><link rel="prefetch" href="/hmblog/assets/js/160.e6a3b7e3.js"><link rel="prefetch" href="/hmblog/assets/js/161.b897eab6.js"><link rel="prefetch" href="/hmblog/assets/js/162.54114dbe.js"><link rel="prefetch" href="/hmblog/assets/js/163.156fce2c.js"><link rel="prefetch" href="/hmblog/assets/js/164.e44a107d.js"><link rel="prefetch" href="/hmblog/assets/js/165.50843d9b.js"><link rel="prefetch" href="/hmblog/assets/js/166.51cc166e.js"><link rel="prefetch" href="/hmblog/assets/js/167.1e241fd0.js"><link rel="prefetch" href="/hmblog/assets/js/168.1f0c33e5.js"><link rel="prefetch" href="/hmblog/assets/js/169.62546341.js"><link rel="prefetch" href="/hmblog/assets/js/17.29a60e10.js"><link rel="prefetch" href="/hmblog/assets/js/170.3e1d4983.js"><link rel="prefetch" href="/hmblog/assets/js/171.5975c042.js"><link rel="prefetch" href="/hmblog/assets/js/172.a172fe4f.js"><link rel="prefetch" href="/hmblog/assets/js/173.b7f30ce1.js"><link rel="prefetch" href="/hmblog/assets/js/174.cf213ee7.js"><link rel="prefetch" href="/hmblog/assets/js/175.fead80ee.js"><link rel="prefetch" href="/hmblog/assets/js/176.d8597cdf.js"><link rel="prefetch" href="/hmblog/assets/js/177.72596ae1.js"><link rel="prefetch" href="/hmblog/assets/js/178.d0c48b18.js"><link rel="prefetch" href="/hmblog/assets/js/179.d5c444fc.js"><link rel="prefetch" href="/hmblog/assets/js/18.27fd2b83.js"><link rel="prefetch" href="/hmblog/assets/js/180.2f29e719.js"><link rel="prefetch" href="/hmblog/assets/js/181.bb359567.js"><link rel="prefetch" href="/hmblog/assets/js/182.e140022f.js"><link rel="prefetch" href="/hmblog/assets/js/183.88c88131.js"><link rel="prefetch" href="/hmblog/assets/js/184.7dafb863.js"><link rel="prefetch" href="/hmblog/assets/js/185.6ee6fee4.js"><link rel="prefetch" href="/hmblog/assets/js/186.a58d3091.js"><link rel="prefetch" href="/hmblog/assets/js/187.06e4ac29.js"><link rel="prefetch" href="/hmblog/assets/js/188.4f58b234.js"><link rel="prefetch" href="/hmblog/assets/js/189.b7fcaad5.js"><link rel="prefetch" href="/hmblog/assets/js/19.e7351a57.js"><link rel="prefetch" href="/hmblog/assets/js/190.1ee24f3f.js"><link rel="prefetch" href="/hmblog/assets/js/191.71d1ed44.js"><link rel="prefetch" href="/hmblog/assets/js/192.8e13dbd5.js"><link rel="prefetch" href="/hmblog/assets/js/193.6ffdbe3c.js"><link rel="prefetch" href="/hmblog/assets/js/194.f3092777.js"><link rel="prefetch" href="/hmblog/assets/js/195.61518c26.js"><link rel="prefetch" href="/hmblog/assets/js/196.4749bfe4.js"><link rel="prefetch" href="/hmblog/assets/js/197.02f293f5.js"><link rel="prefetch" href="/hmblog/assets/js/198.66d067f8.js"><link rel="prefetch" href="/hmblog/assets/js/199.e713626b.js"><link rel="prefetch" href="/hmblog/assets/js/20.20706f57.js"><link rel="prefetch" href="/hmblog/assets/js/200.a0428ce1.js"><link rel="prefetch" href="/hmblog/assets/js/201.10f94064.js"><link rel="prefetch" href="/hmblog/assets/js/202.85104aab.js"><link rel="prefetch" href="/hmblog/assets/js/203.610baaad.js"><link rel="prefetch" href="/hmblog/assets/js/204.d7a56285.js"><link rel="prefetch" href="/hmblog/assets/js/205.e9c3d532.js"><link rel="prefetch" href="/hmblog/assets/js/21.0feb36e8.js"><link rel="prefetch" href="/hmblog/assets/js/22.40bc0c74.js"><link rel="prefetch" href="/hmblog/assets/js/23.3f7042f4.js"><link rel="prefetch" href="/hmblog/assets/js/24.ed563c46.js"><link rel="prefetch" href="/hmblog/assets/js/25.ac1b0e72.js"><link rel="prefetch" href="/hmblog/assets/js/26.683143d5.js"><link rel="prefetch" href="/hmblog/assets/js/27.f0066995.js"><link rel="prefetch" href="/hmblog/assets/js/28.d8aebbf6.js"><link rel="prefetch" href="/hmblog/assets/js/29.411fc063.js"><link rel="prefetch" href="/hmblog/assets/js/3.1300dadf.js"><link rel="prefetch" href="/hmblog/assets/js/30.2f75779a.js"><link rel="prefetch" href="/hmblog/assets/js/31.a195dbd7.js"><link rel="prefetch" href="/hmblog/assets/js/32.a4da846d.js"><link rel="prefetch" href="/hmblog/assets/js/33.cbaf45e6.js"><link rel="prefetch" href="/hmblog/assets/js/35.b991843f.js"><link rel="prefetch" href="/hmblog/assets/js/36.ae8fa883.js"><link rel="prefetch" href="/hmblog/assets/js/37.dc5b3f34.js"><link rel="prefetch" href="/hmblog/assets/js/38.2acfc275.js"><link rel="prefetch" href="/hmblog/assets/js/39.c2783769.js"><link rel="prefetch" href="/hmblog/assets/js/4.a36b649a.js"><link rel="prefetch" href="/hmblog/assets/js/40.b6871f20.js"><link rel="prefetch" href="/hmblog/assets/js/41.b9269303.js"><link rel="prefetch" href="/hmblog/assets/js/42.e8164e0c.js"><link rel="prefetch" href="/hmblog/assets/js/43.70ef46e5.js"><link rel="prefetch" href="/hmblog/assets/js/44.9331e0b2.js"><link rel="prefetch" href="/hmblog/assets/js/45.5feef070.js"><link rel="prefetch" href="/hmblog/assets/js/46.cbe15db5.js"><link rel="prefetch" href="/hmblog/assets/js/47.13b797de.js"><link rel="prefetch" href="/hmblog/assets/js/48.7030d96f.js"><link rel="prefetch" href="/hmblog/assets/js/49.21360ca4.js"><link rel="prefetch" href="/hmblog/assets/js/5.ade88313.js"><link rel="prefetch" href="/hmblog/assets/js/50.2278b4f1.js"><link rel="prefetch" href="/hmblog/assets/js/51.dfcce7fa.js"><link rel="prefetch" href="/hmblog/assets/js/52.411e6b71.js"><link rel="prefetch" href="/hmblog/assets/js/53.9f14e863.js"><link rel="prefetch" href="/hmblog/assets/js/54.ae21c7a9.js"><link rel="prefetch" href="/hmblog/assets/js/55.0b0dbecf.js"><link rel="prefetch" href="/hmblog/assets/js/56.2b3b9c9e.js"><link rel="prefetch" href="/hmblog/assets/js/57.eb5c4857.js"><link rel="prefetch" href="/hmblog/assets/js/58.5bb642a4.js"><link rel="prefetch" href="/hmblog/assets/js/59.310d4748.js"><link rel="prefetch" href="/hmblog/assets/js/6.3551780c.js"><link rel="prefetch" href="/hmblog/assets/js/60.43f50fd6.js"><link rel="prefetch" href="/hmblog/assets/js/61.bf7359ad.js"><link rel="prefetch" href="/hmblog/assets/js/62.bbc1a63f.js"><link rel="prefetch" href="/hmblog/assets/js/63.4f514386.js"><link rel="prefetch" href="/hmblog/assets/js/64.75891b13.js"><link rel="prefetch" href="/hmblog/assets/js/65.c594c5f0.js"><link rel="prefetch" href="/hmblog/assets/js/66.3b2e8434.js"><link rel="prefetch" href="/hmblog/assets/js/67.d21dd018.js"><link rel="prefetch" href="/hmblog/assets/js/68.3a1952eb.js"><link rel="prefetch" href="/hmblog/assets/js/69.4a9f3de5.js"><link rel="prefetch" href="/hmblog/assets/js/70.79851ca4.js"><link rel="prefetch" href="/hmblog/assets/js/71.6b0dd684.js"><link rel="prefetch" href="/hmblog/assets/js/72.194abe8d.js"><link rel="prefetch" href="/hmblog/assets/js/73.57d7aacb.js"><link rel="prefetch" href="/hmblog/assets/js/74.21d325f3.js"><link rel="prefetch" href="/hmblog/assets/js/75.5db4d81f.js"><link rel="prefetch" href="/hmblog/assets/js/76.f614fd28.js"><link rel="prefetch" href="/hmblog/assets/js/77.5fb8fe74.js"><link rel="prefetch" href="/hmblog/assets/js/78.cbf908d6.js"><link rel="prefetch" href="/hmblog/assets/js/79.16b13beb.js"><link rel="prefetch" href="/hmblog/assets/js/8.1407b990.js"><link rel="prefetch" href="/hmblog/assets/js/80.b7f99985.js"><link rel="prefetch" href="/hmblog/assets/js/81.c5c33a8c.js"><link rel="prefetch" href="/hmblog/assets/js/82.1bb32711.js"><link rel="prefetch" href="/hmblog/assets/js/83.0126cbfc.js"><link rel="prefetch" href="/hmblog/assets/js/84.bf184586.js"><link rel="prefetch" href="/hmblog/assets/js/85.ed882d02.js"><link rel="prefetch" href="/hmblog/assets/js/86.00a6c023.js"><link rel="prefetch" href="/hmblog/assets/js/87.19ec978b.js"><link rel="prefetch" href="/hmblog/assets/js/88.da0b0fce.js"><link rel="prefetch" href="/hmblog/assets/js/89.1b3f0dc7.js"><link rel="prefetch" href="/hmblog/assets/js/9.7b6dd5b4.js"><link rel="prefetch" href="/hmblog/assets/js/90.5b446b43.js"><link rel="prefetch" href="/hmblog/assets/js/91.b7568648.js"><link rel="prefetch" href="/hmblog/assets/js/92.41c96c2a.js"><link rel="prefetch" href="/hmblog/assets/js/93.c88897c2.js"><link rel="prefetch" href="/hmblog/assets/js/94.1b8ca6ee.js"><link rel="prefetch" href="/hmblog/assets/js/95.ad838784.js"><link rel="prefetch" href="/hmblog/assets/js/96.8d479f68.js"><link rel="prefetch" href="/hmblog/assets/js/97.50826eb1.js"><link rel="prefetch" href="/hmblog/assets/js/98.bdb338cb.js"><link rel="prefetch" href="/hmblog/assets/js/99.4842effa.js"><link rel="prefetch" href="/hmblog/assets/js/vendors~docsearch.e480d9b8.js">
    <link rel="stylesheet" href="/hmblog/assets/css/0.styles.e7d53aa5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>寒梦的博客</h3> <p class="description" data-v-59e6cb88>宝剑锋从磨砺出，梅花香自苦寒来。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>寒梦</span>
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hmblog/" class="home-link router-link-active"><!----> <span class="site-name">寒梦的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Python
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/basic.html" class="nav-link"><i class="undefined"></i>
  Python 基础
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/builtin-function.html" class="nav-link"><i class="undefined"></i>
  Python 内置函数的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/function.html" class="nav-link"><i class="undefined"></i>
  Python 函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/numpy.html" class="nav-link"><i class="undefined"></i>
  Python numpy
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/array-operation.html" class="nav-link"><i class="undefined"></i>
  Python 数组操作
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-library.html" class="nav-link"><i class="undefined"></i>
  Python 常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/string-function.html" class="nav-link"><i class="undefined"></i>
  Python 字符串函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-pip-install.html" class="nav-link"><i class="undefined"></i>
  pip 那些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/line-continue.html" class="nav-link"><i class="undefined"></i>
  Python 中的行续行符
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/pandas-study.html" class="nav-link"><i class="undefined"></i>
  pandas 库的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-important.html" class="nav-link"><i class="undefined"></i>
  python 几个常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-collect.html" class="nav-link"><i class="undefined"></i>
  python 汇总
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-web.html" class="nav-link"><i class="undefined"></i>
  Python Web框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      大模型应用开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/transformer-basic.html" class="nav-link"><i class="undefined"></i>
  Transformer 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-knowledge.html" class="nav-link"><i class="undefined"></i>
  大模型基础概念
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/prompts.html" class="nav-link"><i class="undefined"></i>
  提示词工程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rag.html" class="nav-link"><i class="undefined"></i>
  检索增强生成RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/data-chunk.html" class="nav-link"><i class="undefined"></i>
  数据分块
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-langchain-rag.html" class="nav-link"><i class="undefined"></i>
  Langchain &amp; RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag.html" class="nav-link"><i class="undefined"></i>
  RAG 知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag-pain.html" class="nav-link"><i class="undefined"></i>
  RAG 痛点分析
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-study.html" class="nav-link"><i class="undefined"></i>
  Langchain use
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vector-database.html" class="nav-link"><i class="undefined"></i>
  向量数据库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/first-model-project.html" class="nav-link"><i class="undefined"></i>
  RAG 项目实战
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-function-calling.html" class="nav-link"><i class="undefined"></i>
  Function Calling
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/agent.html" class="nav-link"><i class="undefined"></i>
  Agent 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-prompt.html" class="nav-link"><i class="undefined"></i>
  LangChain Prompt的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-english.html" class="nav-link"><i class="undefined"></i>
  大模型相关的英语词汇
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rl.html" class="nav-link"><i class="undefined"></i>
  强化学习
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/peft.html" class="nav-link"><i class="undefined"></i>
  大模型微调
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/quantization.html" class="nav-link"><i class="undefined"></i>
  模型量化
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vLLM-intro.html" class="nav-link"><i class="undefined"></i>
  vLLM
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-pytorch.html" class="nav-link"><i class="undefined"></i>
  PyTorch Dataset VS Huggingface Dataset
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-train-process.html" class="nav-link"><i class="undefined"></i>
  从零训练一个大模型的完整流程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-aigc.html" class="nav-link"><i class="undefined"></i>
  生成式AI
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      强大的MCP
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-knowledge.html" class="nav-link"><i class="undefined"></i>
  MCP 是什么
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/ide-mcp-server.html" class="nav-link"><i class="undefined"></i>
  IDE 使用MCP Server实操
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-tool.html" class="nav-link"><i class="undefined"></i>
  常见的MCP工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      算法
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/sort.html" class="nav-link"><i class="undefined"></i>
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/double-pointer.html" class="nav-link"><i class="undefined"></i>
  双指针算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-tree.html" class="nav-link"><i class="undefined"></i>
  二叉树
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/receive-rain.html" class="nav-link"><i class="undefined"></i>
  接雨水
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/dynamic-plan.html" class="nav-link"><i class="undefined"></i>
  动态规划
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/greedy.html" class="nav-link"><i class="undefined"></i>
  贪心算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/longasc-sequence.html" class="nav-link"><i class="undefined"></i>
  最长上升子序列
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-search.html" class="nav-link"><i class="undefined"></i>
  二分查找
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/reverse-list.html" class="nav-link"><i class="undefined"></i>
  反转链表
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/del-single-list.html" class="nav-link"><i class="undefined"></i>
  删除单链表-集合
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/other.html" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/compare-al.html" class="nav-link"><i class="undefined"></i>
  m个数，最多用n次比较，找出第二大的数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/effect-bracket.html" class="nav-link"><i class="undefined"></i>
  有效的括号
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/other/ai-agent.html" class="nav-link"><i class="undefined"></i>
  AI项目
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/conda.html" class="nav-link"><i class="undefined"></i>
  Conda 使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/using-packages.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/pytorch-know.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-learn.html" class="nav-link"><i class="undefined"></i>
  transformer库中那些常用函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-collect.html" class="nav-link"><i class="undefined"></i>
  transformer库学习哪些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-1.html" class="nav-link"><i class="undefined"></i>
  transformer 使用T5模型
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-2.html" class="nav-link"><i class="undefined"></i>
  torch DataLoader
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-3.html" class="nav-link"><i class="undefined"></i>
  设置随机种子
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/model-refrence.html" class="nav-link"><i class="undefined"></i>
  优秀的参考文档
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/git-operate.html" class="nav-link"><i class="undefined"></i>
  git 操作命令
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/fine-tuning-adapters.html" class="nav-link"><i class="undefined"></i>
  PEFT 之Adapters
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/swanLab-info.html" class="nav-link"><i class="undefined"></i>
  深度学习之SwanLab
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/lora-0-1.html" class="nav-link"><i class="undefined"></i>
  从0到1手撕LoRA类
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/rag-question-compare.html" class="nav-link"><i class="undefined"></i>
  临时
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hmyjyghh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/ghh_" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/cool-62-29/columns" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://hmyjyghh.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <h3 class="name" data-v-1fad0c41>
    寒梦
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>129</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Python
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/basic.html" class="nav-link"><i class="undefined"></i>
  Python 基础
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/builtin-function.html" class="nav-link"><i class="undefined"></i>
  Python 内置函数的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/function.html" class="nav-link"><i class="undefined"></i>
  Python 函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/numpy.html" class="nav-link"><i class="undefined"></i>
  Python numpy
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/array-operation.html" class="nav-link"><i class="undefined"></i>
  Python 数组操作
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-library.html" class="nav-link"><i class="undefined"></i>
  Python 常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/string-function.html" class="nav-link"><i class="undefined"></i>
  Python 字符串函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/use-pip-install.html" class="nav-link"><i class="undefined"></i>
  pip 那些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/line-continue.html" class="nav-link"><i class="undefined"></i>
  Python 中的行续行符
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/pandas-study.html" class="nav-link"><i class="undefined"></i>
  pandas 库的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-important.html" class="nav-link"><i class="undefined"></i>
  python 几个常用库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-collect.html" class="nav-link"><i class="undefined"></i>
  python 汇总
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/pystudy/python-web.html" class="nav-link"><i class="undefined"></i>
  Python Web框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      大模型应用开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/transformer-basic.html" class="nav-link"><i class="undefined"></i>
  Transformer 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-knowledge.html" class="nav-link"><i class="undefined"></i>
  大模型基础概念
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/prompts.html" class="nav-link"><i class="undefined"></i>
  提示词工程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rag.html" class="nav-link"><i class="undefined"></i>
  检索增强生成RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/data-chunk.html" class="nav-link"><i class="undefined"></i>
  数据分块
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-langchain-rag.html" class="nav-link"><i class="undefined"></i>
  Langchain &amp; RAG
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag.html" class="nav-link"><i class="undefined"></i>
  RAG 知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-rag-pain.html" class="nav-link"><i class="undefined"></i>
  RAG 痛点分析
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-study.html" class="nav-link"><i class="undefined"></i>
  Langchain use
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vector-database.html" class="nav-link"><i class="undefined"></i>
  向量数据库
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/first-model-project.html" class="nav-link"><i class="undefined"></i>
  RAG 项目实战
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-function-calling.html" class="nav-link"><i class="undefined"></i>
  Function Calling
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/agent.html" class="nav-link"><i class="undefined"></i>
  Agent 相关
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/langchain-prompt.html" class="nav-link"><i class="undefined"></i>
  LangChain Prompt的使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-english.html" class="nav-link"><i class="undefined"></i>
  大模型相关的英语词汇
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/rl.html" class="nav-link"><i class="undefined"></i>
  强化学习
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/peft.html" class="nav-link"><i class="undefined"></i>
  大模型微调
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/quantization.html" class="nav-link"><i class="undefined"></i>
  模型量化
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/vLLM-intro.html" class="nav-link"><i class="undefined"></i>
  vLLM
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-pytorch.html" class="nav-link"><i class="undefined"></i>
  PyTorch Dataset VS Huggingface Dataset
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/model-train-process.html" class="nav-link"><i class="undefined"></i>
  从零训练一个大模型的完整流程
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/modelstudy/basic-aigc.html" class="nav-link"><i class="undefined"></i>
  生成式AI
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      强大的MCP
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-knowledge.html" class="nav-link"><i class="undefined"></i>
  MCP 是什么
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/ide-mcp-server.html" class="nav-link"><i class="undefined"></i>
  IDE 使用MCP Server实操
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/mcpstudy/mcp-tool.html" class="nav-link"><i class="undefined"></i>
  常见的MCP工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      算法
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/sort.html" class="nav-link"><i class="undefined"></i>
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/double-pointer.html" class="nav-link"><i class="undefined"></i>
  双指针算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-tree.html" class="nav-link"><i class="undefined"></i>
  二叉树
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/receive-rain.html" class="nav-link"><i class="undefined"></i>
  接雨水
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/dynamic-plan.html" class="nav-link"><i class="undefined"></i>
  动态规划
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/greedy.html" class="nav-link"><i class="undefined"></i>
  贪心算法
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/longasc-sequence.html" class="nav-link"><i class="undefined"></i>
  最长上升子序列
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/binary-search.html" class="nav-link"><i class="undefined"></i>
  二分查找
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/reverse-list.html" class="nav-link"><i class="undefined"></i>
  反转链表
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/del-single-list.html" class="nav-link"><i class="undefined"></i>
  删除单链表-集合
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/other.html" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/compare-al.html" class="nav-link"><i class="undefined"></i>
  m个数，最多用n次比较，找出第二大的数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/algorithm/effect-bracket.html" class="nav-link"><i class="undefined"></i>
  有效的括号
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      其他
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hmblog/other/ai-agent.html" class="nav-link"><i class="undefined"></i>
  AI项目
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/conda.html" class="nav-link"><i class="undefined"></i>
  Conda 使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/using-packages.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架使用
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/pytorch-know.html" class="nav-link"><i class="undefined"></i>
  Pytorch 框架知识点
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-learn.html" class="nav-link"><i class="undefined"></i>
  transformer库中那些常用函数
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-collect.html" class="nav-link"><i class="undefined"></i>
  transformer库学习哪些事
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-1.html" class="nav-link"><i class="undefined"></i>
  transformer 使用T5模型
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-2.html" class="nav-link"><i class="undefined"></i>
  torch DataLoader
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/transformer-3.html" class="nav-link"><i class="undefined"></i>
  设置随机种子
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/model-refrence.html" class="nav-link"><i class="undefined"></i>
  优秀的参考文档
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/git-operate.html" class="nav-link"><i class="undefined"></i>
  git 操作命令
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/fine-tuning-adapters.html" class="nav-link"><i class="undefined"></i>
  PEFT 之Adapters
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/swanLab-info.html" class="nav-link"><i class="undefined"></i>
  深度学习之SwanLab
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/lora-0-1.html" class="nav-link"><i class="undefined"></i>
  从0到1手撕LoRA类
</a></li><li class="dropdown-item"><!----> <a href="/hmblog/other/rag-question-compare.html" class="nav-link"><i class="undefined"></i>
  临时
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hmyjyghh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/ghh_" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/cool-62-29/columns" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://hmyjyghh.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>寒梦</span>
          
        <!---->
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">阶段一</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>寒梦</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="阶段一"><a href="#阶段一" class="header-anchor">#</a> 阶段一</h2> <ol><li>说一下ChatGPT的优缺点</li></ol> <ul><li>优点：
<ul><li>强大的语言理解和生成能力</li> <li>广泛的应用场景</li> <li>出色的上下文理解和多轮对话能力</li> <li>多功能性与通用性</li> <li>大幅提升效率</li></ul></li> <li>缺点：
<ul><li>模型&quot;幻觉&quot;</li> <li>训练数据有截止日期、知识陈旧与缺乏实时性</li> <li>计算资源需求高</li> <li>可能产生偏见与有害内容</li> <li>在专业领域深度不足</li> <li>上下文长度限制</li> <li>会让人们对它产生依赖，渐渐地缺乏独立思考的能力</li></ul></li></ul> <ol start="2"><li>请简述下Transformer基本流程</li></ol> <blockquote><p>简化流程: 输入 -&gt; 编码（通过自注意力理解源序列） -&gt; 解码（通过交叉注意力参考编码结果，并通过掩码自注意力生成目标序列） -&gt; 输出。</p></blockquote> <ul><li>输入层：将输入的文本序列转换为向量表示</li> <li>编码器层：将输入向量编码为上下文表示</li> <li>解码器层：根据上下文表示生成输出序列</li> <li>输出层：将输出向量转换为文本序列</li> <li>位置编码：为了保留序列中单词的位置信息，引入位置编码</li> <li>自注意力机制：模型通过自注意力机制来学习输入序列中不同位置之间的依赖关系</li> <li>多头注意力机制：模型通过多头注意力机制来学习输入序列中不同位置之间的依赖关系</li> <li>前馈神经网络：每个位置的表示通过前馈神经网络进行处理</li> <li>层归一化：在每个子层之间引入层归一化，提高模型的训练稳定性</li> <li>残差连接：引入残差连接，解决深度神经网络训练中的梯度消失问题</li></ul> <ol start="3"><li>为什么基于Transformer的架构需要多头注意力机制？</li></ol> <ul><li>考察点，多头注意力机制，多头，多个专家，多个角度去分析和理解</li></ul> <blockquote><p>简单来说，<strong>多头机制允许模型同时从不同的“表示子空间”和不同“角度”关注输入信息，极大地增强了模型的表征能力和泛化能力。</strong></p></blockquote> <ol><li>克服单头注意力的局限性：增强模型的“视角”</li> <li>并行捕捉多种类型的关系</li> <li>增加模型的表征能力和稳健性</li></ol> <p>#技术实现简述</p> <p>在技术上，多头注意力的实现非常优雅：</p> <ol><li><p><strong>线性投影</strong>：对于给定的输入，通过 <code>h</code> 个（头的数量）不同的线性投影矩阵，分别生成 <code>h</code> 套 <strong>Query、Key、Value</strong> 向量。</p></li> <li><p><strong>并行计算</strong>：在这 <code>h</code> 套投影上并行地执行缩放点积注意力计算，得到 <code>h</code> 个输出矩阵。</p></li> <li><p><strong>拼接与融合</strong>：将这 <code>h</code> 个输出矩阵拼接起来，最后通过一个线性层进行融合，将信息整合回原始的维度。</p></li> <li><p>编码器，解码器，编解码LLM的区别？</p> <ul><li>编码器：将输入序列编码为上下文表示</li> <li>解码器：根据上下文表示生成输出序列</li> <li>编解码LLM：同时进行编码和解码，生成输出序列</li></ul></li></ol> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">编码器-仅编码</th> <th style="text-align:left;">解码器-仅解码</th> <th style="text-align:left;">编码器-解码器</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>核心注意力</strong></td> <td style="text-align:left;">双向注意力</td> <td style="text-align:left;">因果/掩码注意力</td> <td style="text-align:left;">编码器：双向<br>解码器：因果 + <strong>交叉注意力</strong></td></tr> <tr><td style="text-align:left;"><strong>训练目标</strong></td> <td style="text-align:left;">掩码语言建模</td> <td style="text-align:left;">自回归语言建模</td> <td style="text-align:left;">序列到序列学习</td></tr> <tr><td style="text-align:left;"><strong>信息流</strong></td> <td style="text-align:left;">看到整个输入</td> <td style="text-align:left;">只能看到左侧上下文</td> <td style="text-align:left;">编码器看全源序列，解码器自回归生成目标序列</td></tr> <tr><td style="text-align:left;"><strong>核心能力</strong></td> <td style="text-align:left;"><strong>理解</strong></td> <td style="text-align:left;"><strong>生成</strong></td> <td style="text-align:left;"><strong>转换</strong></td></tr> <tr><td style="text-align:left;"><strong>代表模型</strong></td> <td style="text-align:left;">BERT, RoBERTa</td> <td style="text-align:left;">GPT系列, LLaMA</td> <td style="text-align:left;">T5, BART, 原始Transformer</td></tr> <tr><td style="text-align:left;"><strong>类比</strong></td> <td style="text-align:left;"><strong>阅读理解专家</strong></td> <td style="text-align:left;"><strong>故事讲述者</strong></td> <td style="text-align:left;"><strong>翻译官</strong></td></tr></tbody></table> <ol start="5"><li><p>在语言模型中强化学习的概念?它如何应用于ChatGPT？</p> <ul><li>强化学习里面包含，Action、State、Reward Model、Policy、Value Function等</li> <li>Action：模型可以执行的操作</li> <li>State：模型当前的状态</li> <li>Reward Model：用于评估模型执行 Action 后的奖励</li> <li>Policy：模型的策略，用于选择 Action</li> <li>Value Function：模型的价值函数，用于评估模型在当前状态下的价值</li> <li>强化学习，可以根据用户反馈或动作，根据得分及时更新策略，以循序渐进地形式，得到最大期望回报</li> <li>强化学习里面的奖励信号可以是用户的反馈，也可以是模型自己的反馈</li> <li>强化学习是一种通过奖励信号来训练模型的方法</li> <li>强化学习可以应用于ChatGPT，通过与用户的交互来训练模型，使模型能够生成更符合用户需求的文本</li></ul></li> <li><p>在GPT模型中，什么是温度系数？</p></li></ol> <blockquote><p>温度系数是一个控制生成文本随机性和创造性的超参数。</p></blockquote> <ul><li>温度系数是一个超参数，用于控制模型的输出分布的多样性</li> <li>温度系数越小，模型的输出分布越集中，模型的输出结果越确定</li> <li>温度系数越大，模型的输出分布越分散，模型的输出结果越随机</li></ul> <ol start="7"><li>什么是旋转位置编码(Rotary Position Encoding)，简称ROPE？</li></ol> <ul><li><p>旋转位置编码是一种用于Transformer模型的位置编码方法</p></li> <li><p>旋转位置编码的核心思想是，将位置编码的维度分为两部分，分别对这两部分进行旋转</p></li> <li><p>旋转位置编码的优势是，它可以保持模型的平移不变性，同时也可以保持模型的旋转不变性</p></li> <li><p>旋转位置编码的劣势是，它的计算复杂度较高</p></li> <li><p>旋转位置编码是一种能将相对位置信息集成到 <code>self-attention</code> 中, 进而<strong>提升 transformer 架构性能的位置编码方式</strong>, 和绝对位置编码相比, RoPE 具有很好的<code>外推性</code>, 是目前的主流位置编码方式.</p></li> <li><p>外推性的解释, 通俗来说就是训练的时候限制了 512 的上下文长度，那么推理时如果面对超过该长度的文本，LLM 可能无法正确处理.</p></li></ul> <p>绝对位置编码（比如Transformer原始的正弦余弦编码）是给每个位置一个“专属身份证”，比如位置0、1、2……511各有唯一编码。<strong>但训练时没见过512及以后的位置，推理时遇到更长文本</strong>，就只能用“新身份证”（比如重复编码或随机编码），<strong>模型自然不认识，导致性能下降。</strong></p> <p>而RoPE的核心是用“相对位置”代替“绝对位置”：它通过三角函数计算位置之间的相对距离，比如位置i和j的编码差异只和（i-j）有关，和i、j的绝对数值关系不大。就像两个人站成一排，RoPE记的是“你在我左边第3个”，而不是“你站在第100号位置”。</p> <p>这样一来，即使推理时文本长度超过训练时的512（比如到1000），<strong>模型依然能通过相对距离判断位置关系</strong>，不会因为遇到“没见过的绝对位置号”而混乱，这就是<strong>外推性好的直观体现</strong>——<strong>能更好地处理比训练时更长的文本</strong>。</p> <ol start="8"><li>为什么现在的大模型大多是decoder-only的架构？</li></ol> <ul><li><p><strong>Decoder 的天然属性</strong>：Decoder-only 架构本身就是为自回归生成而设计的。它的核心机制是<strong>因果掩码</strong>，确保在生成每个词时，只能看到它之前的词，而无法看到未来的词。这与文本生成的过程完全一致。</p></li> <li><p><strong>计算效率</strong>：Decoder-only 模型架构<strong>高度统一和简化</strong>。无论是预训练还是微调，它都在执行同一个核心任务：预测下一个词。这意味着整个计算图非常高效，可以更好地利用大规模并行计算（如 GPU/TPU）。</p></li> <li><p><strong>参数效率</strong>：在 Encoder-Decoder 架构中，参数被分摊到两个结构不同的组件中。而有研究表明，在计算预算固定的情况下，<strong>将所有参数集中在一个庞大的、统一的 Decoder 中，比将其分割给 Encoder 和 Decoder 能带来更好的性能。</strong> 即“大力出奇迹”的策略在 Decoder-only 模型上更有效。</p></li> <li><p>scaling Laws（缩放定律）：OpenAI 等机构提出的缩放定律表明，模型的性能与模型大小、数据量和计算量之间存在可预测的幂律关系。<strong>Decoder-only 架构被证明是沿着这条 scaling law 进行扩展的最直接、最可靠的路径。</strong></p></li></ul> <p>总之，Decoder-only 架构成为主流，本质上<strong>是因为它在“生成能力”这个核心目标上，与任务本身最匹配</strong>，并且在当今“算力为王”的时代，<strong>提供了最优的扩展性、效率和性能平衡。</strong></p> <ol start="9"><li>ChatGPT的训练步骤有哪些？</li></ol> <p><img src="/hmblog/images/chat-gpt/chat-gpt-train.png" alt="ChatGPT的训练步骤"></p> <ol><li><p>第1步：预训练 - 构建知识基础</p></li> <li><p>第2步：监督微调 - 学会对话格式</p></li> <li><p>第3步：从人类反馈中强化学习 - 对齐人类偏好</p> <ul><li>3.1 训练奖励模型</li> <li>3.2 使用强化学习优化策略</li></ul></li> <li><p>为什么Transformer模型需要位置编码？</p></li></ol> <ul><li>在 Transformer 模型中，由于不是循环（RNN）结构，模型本身无法捕捉输入序列中元素的位置信息。</li> <li>因为Transformer的核心自注意力机制本身是“位置无关”的，它无法感知词语的顺序信息，而顺序对于理解语言至关重要。</li></ul> <ol start="11"><li>为什么对于ChatGPT而言，提示工程很重要？</li></ol> <ul><li>帮助模型理解用户的意图，从而生成符合用户需求的文本</li> <li>设定角色与人格：控制输出的风格和立场</li> <li>提示工程是约束模型、让其忠于事实的强大工具。</li> <li>实现复杂、多步骤的任务分解</li></ul> <p>对于复杂任务，一个简单的指令会让模型不知所措。提示工程教你如何将大任务拆解为清晰的、可执行的步骤。</p> <ul><li><strong>混乱的提示</strong>：<code>&quot;帮我写一份市场计划，要关于新产品，包括社交媒体、预算和竞争对手分析。&quot;</code></li> <li><strong>工程化的提示</strong>：
<ol><li><strong>目标</strong>：<code>&quot;为一款新的环保水瓶制定一份简要的市场计划。&quot;</code></li> <li><strong>步骤一</strong>：<code>&quot;首先，分析当前市场上3个主要竞争对手及其优劣势。&quot;</code></li> <li><strong>步骤二</strong>：<code>&quot;其次，提出一个针对千禧一代的社交媒体推广策略，包括建议使用的平台和内容类型。&quot;</code></li> <li><strong>步骤三</strong>：<code>&quot;最后，草拟一个初步的月度预算分配表。&quot;</code></li></ol></li></ul> <ol start="12"><li>如何缓解LLMs复读机问题？</li></ol> <p>要缓解这个问题，我们需要一个多管齐下的策略，主要从<strong>解码策略</strong>、<strong>提示工程</strong>和<strong>模型层面</strong>入手。</p> <p><img src="/hmblog/images/chat-gpt/LLM-repeat.png" alt=""></p> <ul><li>因为LLMs模型的输出结果，是根据输入的提示词，生成的文本</li> <li>所以，为了避免LLMs模型重复输出相同的文本，我们可以在提示词中，加入一些随机的噪声，如添加随机的单词、句子、段落等</li> <li>这样，就可以避免LLMs模型重复输出相同的文本</li> <li>同时，也可以避免LLMs模型输出重复的句子</li></ul> <h2 id="阶段二"><a href="#阶段二" class="header-anchor">#</a> 阶段二</h2> <ol><li>解释下langchain Agent的概念？</li></ol> <blockquote><p>LangChain Agent核心是让大模型<code>自主决策</code>、<code>调用工具解决复杂任务</code>, 而非单纯生成文本。</p></blockquote> <ul><li>可以根据用户的输入决定调用哪个工具。</li> <li>帮助构建复杂的应用程序, 这些应用程序需要自适应和物特定于上下文的响应。</li> <li>LLM 作为代理的“大脑”，负责推理、规划和决策，而工具则是它完成任务所依赖的外部手段。</li> <li>具有 记忆能力 和  推理能力</li> <li>LangChain提供了执行器(Agent Executor)，用来运行代理并执行其决策的工具。</li></ul> <ol><li>langchain的6大核心组件是什么，它们的作用分别是什么？</li></ol> <ul><li><p>LLM 和提示:LangChain使管理提示、优化它们以及为所有LLM1创建通用界面变得容易。此外,它还包括
一些用于处理 LLM 的便捷实用程序。</p></li> <li><p>链(Chain): 这些是对LLM或其他实用程序的调用序列。LangChain为链提供标准接口,与各种工具集成, 为流行应用提供端到端的链。</p></li> <li><p>数据增强生成:LangChain使链能够与外部数据源交互以收集生成步骤的数据。例如,它可以帮助总结长文本或使用特定数据源回答问题。</p></li> <li><p>Agents: Agents让LLM做出有关行动的决定, 采取这些行动, 检查结果, 并继续前进直到工作完成。
LangChain提供了代理的标准接口,多种代理可供选择,以及端到端的代理示例。</p></li> <li><p>内存（Memory）:LangChain有一个标准的内存接口,有助于维护链或代理调用之间的状态。它还提供了一系列内存实现和使用内存的链或代理的示例。</p></li> <li><p>模型（Models）：包含各大语言模型的LangChain接口和调用细节，以及输出解析机制。</p></li> <li><p>提示模板（Prompts）：使提示工程流线化，进一步激发大语言模型的潜力。</p></li> <li><p>数据检索（Indexes）：构建并操作文档的方法，接受用户的查询并返回最相关的文档，轻松搭建本地知识库。</p></li> <li><p>记忆（Memory）：通过短时记忆和长时记忆，在对话过程中存储和检索数据，让ChatBot记住你。</p></li> <li><p>链（Chains），以特定方式封装各种功能，并通过一系列的组合，自动而灵活地完成任务。</p></li> <li><p>代理（Agents）：通过“代理”让大模型自主调用外部工具和内部工具，使智能Agent成为可能。</p></li></ul> <ol><li>langchain有哪些优点和明显的缺点？</li></ol> <blockquote><p>优点</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>1. 提供了大量的预置组件，让开发者可以快速构建应用
2. 组件生态丰富
3. LangChain提出的Chain、Agent、Tool、Memory等概念已经成为行业标准
4. 社区活跃，文档完善
</code></pre></div><ol><li>快速原型开发能力</li></ol> <ul><li>它提供了高度抽象的概念和大量预制组件，让开发者可以像搭乐高一样快速构建LLM应用。</li> <li>几行代码就能构建一个完整的RAG系统.</li></ul> <ol start="2"><li>组件生态丰富</li></ol> <ul><li>50+ 文档加载器（PDF、HTML、Word、Notion等）</li> <li>20+ 文本分割策略</li> <li>30+ 向量数据库集成</li> <li>10+ LLM提供商支持</li></ul> <ol start="3"><li>LangChain提出的Chain、Agent、Tool、Memory等概念已经成为行业标准，帮助开发者建立心智模型：</li></ol> <ul><li><code>Chain</code>：可复用的任务流水线</li> <li><code>Agent</code>：LLM驱动的决策系统</li> <li><code>Tool</code>：Agent可调用的函数</li> <li><code>Memory</code>：对话状态管理</li></ul> <ol start="4"><li><strong>社区活跃和文档完善</strong></li></ol> <ul><li>GitHub 80k+ stars，庞大的用户社区</li> <li>详细的文档和示例代码</li> <li>遇到问题容易找到解决方案</li></ul> <blockquote><p>缺点</p></blockquote> <ul><li><strong>调试困难, 很难追踪问题</strong></li> <li>性能开销</li> <li>API 不稳定与快速迭代
<ul><li>LangChain 的 API 变化非常频繁，导致代码很容易过时，维护成本高。</li></ul></li> <li>灵活性不够
<ul><li>当需要实现一个非常定制化、非标准的功能时，LangChain 的“框框”可能会限制你。</li></ul></li></ul> <ol start="4"><li>langchain有哪些替代方案？</li></ol> <p>轻量级替代品的出现：像 LlamaIndex（更专注于 RAG 场景）和 LangGraph（由 LangChain 官方推出，用于构建有状态、多参与者的 Agent 应用）等工具，提供了更专注、更清晰的范式。</p> <ol><li>LlamaIndex</li> <li>Haystack</li> <li>Semantic Kernel（微软出品）</li></ol> <p>#横向对比总结</p> <table><thead><tr><th>维度</th> <th>LangChain</th> <th>LlamaIndex</th> <th>Haystack</th> <th>Semantic Kernel</th></tr></thead> <tbody><tr><td><strong>核心定位</strong></td> <td>通用LLM应用框架</td> <td><strong>专业RAG框架</strong></td> <td>NLP生产流水线</td> <td>AI规划与集成框架</td></tr> <tr><td><strong>设计哲学</strong></td> <td>模块化组合</td> <td>数据与检索优化</td> <td><strong>稳定流水线</strong></td> <td>传统代码+AI规划</td></tr> <tr><td><strong>学习曲线</strong></td> <td>陡峭</td> <td>中等</td> <td>中等</td> <td>较陡峭（概念独特）</td></tr> <tr><td><strong>调试难度</strong></td> <td>高（黑盒）</td> <td>中等</td> <td><strong>低（清晰流水线）</strong></td> <td>中等</td></tr> <tr><td><strong>生产就绪</strong></td> <td>中等</td> <td>中等</td> <td><strong>高</strong></td> <td>中等</td></tr> <tr><td><strong>RAG专业性</strong></td> <td>通用</td> <td><strong>最优</strong></td> <td>良好</td> <td>基础</td></tr> <tr><td><strong>Agent支持</strong></td> <td><strong>强大</strong></td> <td>有限</td> <td>有限</td> <td>独特规划方式</td></tr> <tr><td><strong>生态集成</strong></td> <td><strong>最丰富</strong></td> <td>专注数据源</td> <td>良好</td> <td>微软生态</td></tr></tbody></table> <p>#如何选择？</p> <p><strong>选择 LlamaIndex 如果：</strong></p> <ul><li>你主要就是做 RAG 应用</li> <li>对检索质量有很高要求</li> <li>想要更简单直接的 API</li></ul> <p><strong>选择 Haystack 如果：</strong></p> <ul><li>需要稳定部署到生产环境</li> <li>重视可观测性和可维护性</li> <li>构建的是复杂、多步骤的 NLP 流水线</li></ul> <p><strong>选择 Semantic Kernel 如果：</strong></p> <ul><li>你是微软技术栈用户</li> <li>需要将 AI 深度集成到现有业务系统中</li> <li>需要 AI 进行复杂的任务规划和分解</li></ul> <ol start="5"><li>什么是检索增强生成(RAG)？</li></ol> <blockquote><p>通过检索外部数据，增强⼤模型的⽣成效果。</p></blockquote> <ul><li>RAG即检索增强⽣成，为LLM提供了从某些数据源检索到的信息，并基于此修正⽣成的答案。</li> <li>RAG 基本上是Search + LLM 提示，可以通过⼤模型回答查询，并将搜索算法所找到的信息作为⼤模型的上下⽂。</li> <li>查询和检索到的上下⽂都会被注⼊到发送到 LLM 的提示语中</li></ul> <ol start="6"><li>在做知识增强检索时，文本切分有哪些方法？</li></ol> <ul><li>按照句⼦来切分</li> <li>按照字符数来切分</li> <li>按固定字符数 结合overlap</li> <li>递归⽅法：RecursiveCharacterTextSplitter</li></ul> <ol start="7"><li>目前主流的中文向量模型有哪些？</li></ol> <table><thead><tr><th style="text-align:left;">模型系列 / 来源</th> <th style="text-align:left;">代表性模型举例</th> <th style="text-align:left;">核心特点与适用场景</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>阿里通义千问 (Qwen)</strong></td> <td style="text-align:left;"><code>Qwen3-Embedding</code>系列 (如8B, 4B版本)</td> <td style="text-align:left;">专注于<strong>纯文本任务</strong>，在MTEB等权威榜单上表现优异，支持超100种语言，适合智能搜索、文本分类和RAG 。</td></tr> <tr><td style="text-align:left;"><strong>智源研究院 (BGE)</strong></td> <td style="text-align:left;"><code>BGE-Code-v1</code>, <code>BGE-VL-v1.5</code>, <code>BGE-VL-Screenshot</code></td> <td style="text-align:left;">生态丰富，覆盖<strong>代码、图文、截图</strong>等多模态检索，在特定领域基准测试中成绩领先，适合需要处理非纯文本数据的场景 。</td></tr> <tr><td style="text-align:left;"><strong>火山引擎 (Seed)</strong></td> <td style="text-align:left;"><code>Seed1.6-Embedding</code></td> <td style="text-align:left;">强调<strong>全模态</strong>能力，支持文本、图像、视频的混合检索，提供自定义指令功能，适合复杂的多模态和跨模态搜索需求 。</td></tr></tbody></table> <blockquote><p>如果您的主要目的是构建一个高效的语义检索系统（例如用于RAG），那么选择BGE或Qwen-Embedding这类专用模型是更直接、更有效的方案。</p></blockquote> <ol start="8"><li>相比模型直接生成，RAG的优势是什么？</li></ol> <ul><li>因为RAG是基于检索外部知识来生成的的，可以提高模型回答问题的准确性</li> <li>直接生成是模型凭“记忆”和“直觉”回答问题，而 RAG 是让模型先“查阅资料”再回答问题。</li></ul> <blockquote><p>解决了直接生成的三大核心痛点</p></blockquote> <ol><li><p>知识滞后与事实性错误（幻觉）</p></li> <li><p>无法溯源，可信度低</p></li> <li><p>处理私有/领域知识时能力不足</p></li> <li><p>SELF-RAG 是什么，SELF-RAG如何提升大型语言模型的质量和准确性？</p></li></ol> <ul><li><strong>SELF-RAG</strong> 是一种让LLM在生成过程中<strong>自我评估</strong>、<strong>自我纠正</strong>的框架。</li> <li>与传统RAG不同，SELF-RAG让模型在生成每个段落时都主动决定是否需要检索、如何利用检索结果，以及评估生成内容的质量。</li></ul> <blockquote><p>SELF-RAG 流程</p></blockquote> <p>用户提问 → 检索相关文档 → LLM 对文档进行批判性评估（反思） → 根据评估结果，有选择地、智能地利用文档 → 生成最终答案。</p> <p>“反思”步骤是通过生成特殊的<strong>反思令牌（Special Tokens）</strong> 来实现的。这些令牌分为以下几类：</p> <ol><li><p><strong>检索令牌 - “要不要检索？”</strong></p> <ul><li>在生成答案的每一个阶段，模型会先自问：“我需要检索外部文档来帮助生成下一个段落吗？”</li></ul></li> <li><p><strong>相关性令牌 - “检索到的东西有用吗？”</strong></p> <ul><li>如果执行了检索，模型会评估每一篇检索到的文档。</li></ul></li> <li><p><strong>支持令牌 - “检索到的信息支持我的说法吗？”</strong></p> <ul><li>模型在生成具体陈述时，会判断该陈述是否得到了检索文档的支持。</li></ul></li> <li><p><strong>效用令牌 - “我生成的答案整体好吗？”</strong></p> <ul><li>最后，模型会对生成的完整段落进行整体评估。</li> <li>评判标准：<code>Good</code>， <code>Fair</code>， <code>Poor</code>。这确保了最终输出的综合质量。</li></ul></li></ol> <blockquote><p>SELF-RAG 如何提升LLM的质量和准确性？</p></blockquote> <ol><li><p><strong>SELF-RAG</strong>：通过 “支持令牌” ，模型只会生成有证据支持的陈述。如果证据不足或存在矛盾，模型会选择不生成或明确指出来，从而避免了传播错误信息。</p></li> <li><ul><li>模型不再是信息的被动接收者，而是主动的<strong>评估者</strong>。它只会筛选并利用那些被它判定为 <strong>“相关”</strong> 和 <strong>“准确”</strong> 的信息，使得最终答案的根基更加牢固。</li></ul></li> <li><ul><li>而SELF-RAG可以识别出哪几篇是高度相关的，并<strong>重点利用</strong>这些高质量信息，同时忽略或减少使用低质量信息。</li></ul></li> <li><ul><li>SELF-RAG 的输出可以附带其反思过程（例如，标注出哪些陈述有充分支持）。这为用户提供了<strong>可验证的线索</strong>，让用户知道答案的来源和可信度，增强了模型的透明度和可信度。</li></ul></li> <li><ul><li>当模型自身知识足够时，它选择 <code>No Retrieve</code>，自信地回答；当不确定时，它主动检索 <code>Retrieve</code>；当检索结果不好时，它承认知识的局限性。这使得模型表现得更像一位严谨的专家，而不是一个不懂装懂的学生。</li></ul></li> <li><p>RAG 和 微调的区别是什么？</p></li></ol> <ul><li><p>RAG（检索增强⽣成）是把内部的⽂档数据先进⾏embedding，借助检索先获得⼤致的知识范围答案，再结合prompt给到LLM，让LLM⽣成最终的答案</p></li> <li><p>Fine-tuning（微调）是⽤⼀定量的数据集对LLM进⾏局部参数的调整，以期望LLM更加理解我们的业务逻辑，有更好的zero-shot能⼒。</p></li></ul> <ol start="11"><li>什么是GraphRAG？</li></ol> <p>GraphRAG 的核心思想是：将文档库中的信息提取并构建成<strong>一个结构化的知识图谱</strong>，然后利用这个图谱来增强大模型的检索和推理能力。</p> <ul><li><strong>GraphRAG</strong>：先从文档中提取实体（如人物、地点、概念、事件）和它们之间的关系，构建一个知识图谱。检索时进行图遍历和关系推理。</li></ul> <blockquote><p>GraphRAG VS RAG</p></blockquote> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">传统 RAG</th> <th style="text-align:left;">GraphRAG</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>信息组织</strong></td> <td style="text-align:left;">扁平的文本片段</td> <td style="text-align:left;">结构化的关系网络</td></tr> <tr><td style="text-align:left;"><strong>检索方式</strong></td> <td style="text-align:left;">向量相似度</td> <td style="text-align:left;"><strong>关系与结构推理</strong></td></tr> <tr><td style="text-align:left;"><strong>推理能力</strong></td> <td style="text-align:left;">弱，基于局部上下文</td> <td style="text-align:left;"><strong>强，基于全局关系</strong></td></tr> <tr><td style="text-align:left;"><strong>可解释性</strong></td> <td style="text-align:left;">低（为什么检索这些片段？）</td> <td style="text-align:left;"><strong>高（答案路径清晰可见）</strong></td></tr></tbody></table> <blockquote><p>GraphRAG 的典型应用场景
GraphRAG 的优势决定了它更适合 “关联密集、需要推理” 的场景，而非简单的 “文本问答”：</p></blockquote> <ul><li><strong>知识图谱问答（KGQA）</strong>：如 “查询某明星的合作导演及其代表作”“某药物的适应症和禁忌症关联的疾病”；</li> <li><strong>商业情报分析</strong>：如 “梳理某行业的产业链关系（上游原材料→中游制造→下游品牌）”“分析某公司的投资版图和竞争对手网络”；</li> <li><strong>事件脉络梳理</strong>：如 “还原某历史事件的关键人物、时间线和因果关系（如‘二战主要战役的发起方和影响’）”；</li> <li><strong>合规与风控</strong>：如 “核查某企业的股权穿透关系（是否存在关联交易）”“识别金融诈骗中的人物 - 账户 - 资金流向关联”。</li></ul> <h2 id="阶段三"><a href="#阶段三" class="header-anchor">#</a> 阶段三</h2> <ol><li>Prompt design, Prompt Tuning， Fine-tuning 有什么区别？</li></ol> <blockquote><p>Prompt design：提示设计，或者叫<code>提示工程</code></p></blockquote> <ol><li>**学习如何向模型“提问”。**你不动模型本身，只优化你的指令。</li></ol> <blockquote><p>Prompt Tuning：提示微调，即微调模型的提示词</p></blockquote> <ol><li>**教模型学会一种新的“内部提问方式”。**你给模型一些可以学习的“软提示”，而不是修改它的核心知识。</li> <li>软提示有2种，1种是：soft prompt  1种是：hard prompt</li></ol> <blockquote><p>Fine-tuning：微调，即微调模型的参数</p></blockquote> <ul><li>全量微调的话: **给模型“回炉重造”，学习新专业。**你直接修改模型的核心参数，让它适应新任务。</li></ul> <ol><li><p>基于开源大模型进行微调，有全量参数微调，和 PEFT: 参数高效微调，也就是只有微调少量参数</p></li> <li><p>参数高效的fine-tuning(PEFT)是什么？
Parameter-Efficient Fine-Tuning</p> <ul><li>用一些策略，仅训练少量参数，大部分模型参数冻结</li> <li>方法有：
<ul><li>适配器(Adapter)、软提示(Soft Prompts): Prompt Tuning、P-Tuning、Prefix-Tuning</li> <li>模型参数冻结</li> <li>LORA</li></ul></li></ul></li> <li><p>介绍一下Prompt-tuning 技术？</p></li></ol> <p>它的核心思想是：<strong>冻结主模型参数，在训练数据前，加入一小段Prompt（只通过优化一小段可学习的“软提示”（Soft Prompt）），来激发模型解决特定任务的潜能。</strong></p> <ul><li><p>只训练Prompt 的表示层，也就是一个Embedding 模块。</p></li> <li><p>其中， Prompt 有两种形式， 一种是: hard prompt ， 一种是: soft prompt</p></li></ul> <p>#代码演示</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">from</span> peft <span class="token keyword">import</span> PromptTuningConfig<span class="token punctuation">,</span> get_peft_model<span class="token punctuation">,</span> TaskType<span class="token punctuation">,</span> PromptTuningInit

<span class="token comment"># Soft Prompt 不需要显示指定 prompt</span>
<span class="token comment"># config = PromptTuningConfig(task_type=TaskType.CAUSAL_LM, num_virtual_tokens=10)</span>

<span class="token comment"># Hard Prompt</span>
config <span class="token operator">=</span> PromptTuningConfig<span class="token punctuation">(</span>
   task_type<span class="token operator">=</span>TaskType<span class="token punctuation">.</span>CAUSAL_LM<span class="token punctuation">,</span>
   prompt_tuning_init<span class="token operator">=</span>PromptTuningInit<span class="token punctuation">.</span>TEXT<span class="token punctuation">,</span>
   prompt_tuning_init_text<span class="token operator">=</span><span class="token string">&quot;下面是一段人与机器人的对话。&quot;</span><span class="token punctuation">,</span>
   num_virtual_tokens<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>tokenizer<span class="token punctuation">(</span><span class="token string">&quot;下面是一段人与机器人的对话。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">&quot;input_ids&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   tokenizer_name_or_path<span class="token operator">=</span><span class="token string">&quot;Langboat/bloom-1b4-zh&quot;</span>
<span class="token punctuation">)</span>
</code></pre></div><ol start="4"><li>什么是Prefix Tuning？</li></ol> <ul><li>核心思想：在每一层之前添加可学习的“前缀”。</li> <li>相较于Prompt-Tuning和P-tuning,
<ul><li>Prefix-Tuning不再将Prompt加在输入的Embedding层,</li> <li>而是将其作为可学习的前缀, 放置在Transsformer模型中的每一层中, 具体表现形式为past_key_values。</li></ul></li></ul> <p><img src="/hmblog/images/fine-tuning/Prefix-Tuning.png" alt="Prefix Tuning"></p> <ul><li>图中的Prefix Encoder 不会跟 右边的 Embedding 拼起来，而是会放到Transformer Blocks 层里，参与计算，</li> <li>它是通过past_key_values 形式放进去的</li></ul> <p><img src="/hmblog/images/fine-tuning/past_key_values.png" alt="past_key_values"></p> <ul><li><strong>普通Prompt-Tuning</strong>：只在模型的<strong>输入嵌入层（Input Embedding Layer）</strong> 添加可训练的提示向量。这相当于在对话开始时给模型一个总体的指令。</li> <li><strong>Prefix-Tuning</strong>：不仅在输入层，而是在<strong>模型的每一层（或某几层）的激活（activation）之前</strong>，都添加一组可训练的前缀向量。这相当于在模型思考的每一个步骤、每一个阶段都不断地进行引导和提醒，确保它不偏离轨道。</li></ul> <hr> <p><strong>Prompt Tuning</strong> VS <strong>Prefix Tuning</strong></p> <ul><li><strong>思想</strong>：不修改模型本身，而是在输入序列前添加一些可训练的<strong>软提示向量</strong>。模型通过这些提示向量来适应下游任务。</li> <li><strong>区别</strong>:
<ul><li>Prompt Tuning 直接训练这些向量；</li> <li>Prefix Tuning 通过一个小型的前馈网络来生成这些向量，训练的是这个网络的参数。</li></ul></li></ul> <hr> <ol start="5"><li>介绍下LORA微调？</li></ol> <ul><li>在每一个要计算的大的矩阵(权重)旁边，新起一条分支，</li> <li>这个分支的话，是由两个小矩阵组成, LoRA_A  和  LoRA_B</li> <li>那我更新的时候只更新这两个小矩阵</li> <li>训练完成之后，再把它合并回去，这就是LoRA</li></ul> <p><img src="/hmblog/images/fine-tuning/Lora1.png" alt="LoRA 的思想"></p> <ul><li>LoRA 原理</li></ul> <p><img src="/hmblog/images/fine-tuning/Lora2.png" alt="Lora"></p> <ol start="6"><li>相比LORA，AdaLoRA的改进点是什么？</li></ol> <ul><li><strong>思想</strong>：LoRA 的自适应版本。它不是为所有选定的层分配固定的秩，而是根据重要性评分<code>动态地调整每个 LoRA 模块的秩（参数预算）</code>，将更多的参数分配给更重要的模块。</li> <li><strong>优势</strong>：在相同的参数预算下，通常能获得比标准 LoRA 更好的性能。</li></ul> <blockquote><p>引入了3种关键技术</p></blockquote> <ol><li><strong>参数重要性评分</strong></li> <li><strong>动态的预算分配和秩调整</strong></li> <li><strong>通过SVD参数化进行高效调整</strong></li></ol> <p>#总结与类比</p> <ul><li><strong>LoRA</strong> 就像给公司每个部门分配<strong>固定且相同</strong>的预算，不管这个部门是核心研发还是后勤支持。</li> <li><strong>AdaLoRA</strong> 则像一位<strong>精明的CEO</strong>，他会根据每个部门的业绩（重要性分数）和公司总预算，定期进行审查：削减表现不佳部门的预算（修剪），并将资源重新分配给高绩效、高潜力的部门（生长）。</li></ul> <p>因此，AdaLoRA的主要优势在于其<strong>自适应性</strong>和<strong>效率</strong>。</p> <ol start="7"><li><p>QLORA模型有什么创新点？</p></li> <li><p>稀疏微调是怎么工作的，有哪几个步骤？</p></li></ol> <p><strong>只更新模型庞大参数中的一小部分（稀疏），而冻结其余大部分参数。</strong></p> <p>目标： 极大地减少微调时需要更新的参数量。</p> <ul><li>核心思想是：<strong>大型预训练模型已经包含了丰富的通用知识，对于特定的下游任务，我们只需要激发或调整其中与之相关的一小部分神经元或参数子集就足够了，而不需要动整个网络。</strong></li></ul> <p><strong>常见示例与步骤：</strong></p> <ol><li><strong>只微调偏置项</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结模型中所有的权重矩阵（如Linear、LayerNorm的权重）。</li> <li>只将模型中所有的偏置项设置为可训练。</li> <li>进行训练。由于偏置项的数量远少于权重，实现了稀疏更新。</li></ul></li></ul></li> <li><strong>只微调某几层</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结模型的大部分层（例如，只更新最后4层Transformer块）。</li> <li>只解冻靠近输出端的少数几层进行微调。</li></ul></li></ul></li> <li><strong>只微调注意力模块中的特定部分</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结前馈神经网络。</li> <li>只更新自注意力机制中的参数（如Query, Key, Value投影矩阵）。</li></ul></li></ul></li></ol> <p>方法三：基于附加稀疏适配器的微调（目前最流行）</p> <p>这是目前最主流的“稀疏微调”方式，也是<strong>Parameter-Efficient Fine-Tuning (PEFT)</strong> 的核心。它<strong>不直接更新原始模型参数</strong>，而是<strong>引入一小部分额外的、可训练的参数（适配器）</strong>，模型主体保持冻结。</p> <p><strong>工作原理：</strong></p> <ul><li>在预训练模型的架构中，插入一些小的、可训练的模块。</li> <li>在微调时，<strong>只训练这些新增的适配器</strong>，原始模型的<strong>所有参数都被冻结</strong>。从参数更新的角度看，这是“稀疏”的，因为只有新增的那一小部分参数被更新。</li></ul> <p><strong>常见示例与步骤：</strong></p> <ol><li><strong>LoRA及其变种</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结整个预训练模型。</li> <li>在原有的权重矩阵 ( W ) 旁，注入一个低秩适配器 ΔW = BA。</li> <li><strong>只训练 ( A ) 和 ( B ) 这两个小矩阵</strong>。前向传播变为：( h = Wx + BAx )。</li></ul></li></ul></li> <li><strong>Adapter模块</strong> <ul><li><strong>步骤</strong>：
<ul><li>冻结整个预训练模型。</li> <li>在Transformer块中的前馈网络或注意力模块之后，插入一个小的前馈神经网络（Adapter）。</li> <li><strong>只训练这些插入的Adapter模块</strong>。</li></ul></li></ul></li></ol> <p><strong>特点：</strong></p> <ul><li><strong>附加式</strong>：不改变原参数，而是增加新参数。</li> <li><strong>极高效</strong>：通常参数量极小（仅为原模型的0.01%~1%）。</li> <li><strong>模块化与安全</strong>：由于原模型不动，可以为一个模型创建多个适配器用于不同任务，且没有灾难性遗忘的风险。</li></ul> <ol start="9"><li>监督微调SFT后LLM表现下降的原因？</li></ol> <ul><li>监督微调后模型表现下降，通常被称为 “灾难性遗忘” 或 “对齐税” 。</li></ul> <p><img src="/hmblog/images/question/SFT-LLM.png" alt="SFT 后LLM表现下降的原因分析"></p> <p>#如何缓解这些问题？</p> <ol><li><p><strong>提升数据质量</strong>：精心清洗和构建SFT数据，确保正确性、多样性和高质量。<strong>“质量远胜于数量”</strong> 在SFT中尤其正确。</p></li> <li><p><strong>谨慎选择超参数</strong>：使用<strong>较低的学习率</strong>和<strong>较少的训练轮数</strong>（通常1-3个epoch）。始终使用验证集来监控训练，防止过拟合。</p></li> <li><p><strong>使用参数高效微调技术</strong>：如 <strong>LoRA</strong>。这种方法只更新一小部分参数，大部分预训练参数保持不变，从而极大地减轻了灾难性遗忘。</p></li> <li><p>什么是P-Tuning？</p></li></ol> <p>P-Tuning的思想: 在Prompt-Tuning的基础上,对Prompt部分进行进一步的编码计算,加速收敛。</p> <ul><li>PEFT中支持两种编码方式,一种是LSTM,一种是MLP。</li> <li>与Prompt-Tuning不同的是, Prompt的形式只有Soft Prompt。
<ul><li>MLP: 全连接层，3层全连接层</li> <li>LSTM： 一层LSTM，2层全连接层</li></ul></li></ul> <p><img src="/hmblog/images/fine-tuning/P-Tuning.png" alt="P-Tuning"></p> <ol start="11"><li>多轮对话任务如何微调模型？</li></ol> <p>一. 选择PEFT 参数高效微调</p> <ol><li>选择 LoRA / QLoRA  或者 <code>Adapter</code></li> <li>对话格式构建与损失计算</li> <li>step1: 构建带角色的对话模版</li> <li>step2: 计算仅针对助理回复的损失</li> <li>模型学会在上下文中生成回复</li></ol> <p><strong>LoRA</strong> 和 <strong>QLoRA</strong>。它在全参数微调的基础上，引入了可训练的旁路矩阵，极大地降低了计算成本。</p> <p><strong>工作原理：</strong></p> <ol><li>冻结预训练模型的所有参数。</li> <li>在模型的注意力层和全连接层旁，注入少量的可训练参数（LoRA 秩分解矩阵）。</li> <li>训练时，只更新这些新增的参数，而不触动原始模型的巨大参数库。</li></ol> <p><strong>为什么PEFT对多轮对话特别有益？</strong></p> <ul><li><strong>减轻灾难性遗忘</strong>：多轮对话数据通常远少于预训练数据。PEFT 能更好地保留模型在预训练阶段获得的世界知识和语言能力，防止其因过度专注于学习对话结构而遗忘根本。</li> <li><strong>高效且成本低</strong>：可以在消费级GPU上微调大模型。</li> <li><strong>模块化</strong>：可以为不同的对话风格或任务训练不同的 LoRA 适配器，灵活切换。</li></ul> <h2 id="阶段四"><a href="#阶段四" class="header-anchor">#</a> 阶段四</h2> <ol><li>请简述下PPO算法。</li></ol> <ul><li><p>它是一种近端策略优化，核心思想是：避免策略更新幅度过大，不要一次改变太多。</p></li> <li><p><strong>工作流程</strong>：</p> <ul><li>用当前策略与环境交互，收集数据（状态、动作、奖励）。</li> <li>利用收集的数据，根据“新/旧”策略的概率比和优势函数（衡量动作好坏）计算目标。</li> <li>优化时，通过裁剪概率比，限制更新幅度，防止模型训歪。</li></ul></li> <li><p><strong>价值函数</strong>：用于计算优势函数，评估状态或动作的相对价值，指导策略应向哪些方向更新。</p></li> <li><p>四个主要模型：</p> <ul><li>Actor Model（目标语言模型）</li> <li>Critic Model（预估未来期望收益Vt）</li> <li>Reward Model（计算即时收益Rt）</li> <li>Reference Model（约束语言模型行为）  ，参考模型</li></ul></li> <li><p>模型约束，会加入：<code>KL散度惩罚</code> 这个惩罚项</p></li> <li><p>在训练过程中新旧策略的的变化差异如果过大则不利于学习。</p></li></ul> <ol><li>介绍一下基于人类反馈的强化学习流程</li></ol> <ul><li>构造用于RL的数据集，</li> <li>采用DPO(直接偏好学习优化)</li> <li>PPO  或者  GRPO 算法 去不断优化模型行为</li></ul> <ol start="3"><li>奖励模型的数据收集要满足什么要求?</li></ol> <ul><li><strong>一致性</strong>：标注人员对相同或相似的回答，给出的评分标准必须一致。</li> <li><strong>覆盖性</strong>：数据要覆盖模型可能遇到的各种输入（包括刁钻、古怪的提问）和各种类型的回答（优秀、一般、有害、胡言乱语等）。</li> <li><strong>高质量</strong>：标注结果必须准确反映人类的真实偏好，避免噪音和错误标签。这需要清晰的标注指南和合格的标注员。</li> <li><strong>无偏见</strong>：要尽量避免数据集中包含标注者个人的强烈偏见或共同的社会偏见。</li></ul> <ol start="4"><li>奖励模型是如何训练的, 它的损失函数是什么?</li></ol> <p><strong>奖励模型的训练通常基于人类偏好数据，通过优化损失函数来学习对生成内容的评分能力。</strong></p> <p>其核心流程和损失函数设计如下：</p> <p>一、训练流程</p> <ol><li><p><strong>数据准备</strong><br>
首先通过监督微调（SFT）的语言模型生成多个候选响应。例如，对每个提示（prompt）生成4-9个不同的回答，然后由人类评估者根据质量、相关性等标准进行排序，形成成对比较数据（如“响应A优于响应B”）。
这些数据以三元组形式存储：<code>(prompt, better_response, worse_response)</code>。</p></li> <li><p><strong>模型架构</strong><br>
奖励模型通常基于SFT模型改造，将原模型的下一词分类层替换为回归层，输出单个标量奖励值。例如，Transformer架构的奖励模型会将最后一层隐藏状态通过线性层映射为标量。</p></li> <li><p><strong>训练过程</strong><br>
使用成对比较数据进行训练，目标是使模型对人类偏好的响应（better_response）的评分显著高于非偏好响应（worse_response）。训练时，将prompt与响应拼接后输入模型，计算两者的奖励差值，并通过损失函数反向传播更新参数。</p></li></ol> <p>二、损失函数类型
#1. <strong>成对排序损失（Pairwise Ranking Loss）</strong></p> <ul><li><strong>核心思想</strong>：确保偏好响应的奖励值严格高于非偏好响应。</li> <li><strong>公式</strong>：<br>
[
\text{loss} = -\frac{1}{\binom{K}{2}} \sum_{(y_w, y_l) \in \text{pair}} \log \sigma(r_\theta(x, y_w) - r_\theta(x, y_l))
]
其中，(K)为每个prompt对应的响应数量，(\sigma)为sigmoid函数，(y_w)和(y_l)分别表示排序高和低的响应。</li> <li><strong>实现细节</strong>：<br>
通常使用<code>BCEWithLogitsLoss</code>（带logits的二分类交叉熵），将奖励差值作为logits，目标标签设为1（表示偏好关系成立）。例如：<div class="language-python extra-class"><pre class="language-python"><code>logits <span class="token operator">=</span> r_better <span class="token operator">-</span> r_worse
loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>logits<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>logits<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>这种方法将排序问题转化为二分类问题，计算高效且稳定。</li></ul> <p>#2. <strong>Bradley-Terry模型</strong></p> <ul><li><strong>概率建模</strong>：假设人类选择响应A而非B的概率为：<br>
[
P(y_w &gt; y_l) = \frac{\exp(r_\theta(x, y_w))}{\exp(r_\theta(x, y_w)) + \exp(r_\theta(x, y_l))}
]</li> <li><strong>损失函数</strong>：最大化数据的对数似然，等价于最小化负对数似然（NLL）：<br>
[
\text{loss} = -\sum_{(y_w, y_l)} \log P(y_w &gt; y_l)
]
该模型直接建模偏好概率，适用于成对比较数据。</li></ul> <p>#3. <strong>Margin Loss（带偏好强度的损失）</strong></p> <ul><li><strong>动机</strong>：区分“显著好”和“略好”的偏好强度。</li> <li><strong>公式</strong>：<br>
[
\text{loss} = -\log \sigma(r_\theta(x, y_w) - r_\theta(x, y_l) - m)
]
其中，(m)为人工标注的偏好强度（如0.1表示“略好”，0.5表示“显著好”）。当(r_\theta(x, y_w) - r_\theta(x, y_l))不足以超过(m)时，损失增大，迫使模型学习更显著的差异。</li> <li><strong>应用场景</strong>：Llama 2等模型采用此方法，通过动态调整(m)来强化梯度信号，提升模型对偏好强度的捕捉能力。</li></ul> <p>#4. <strong>KL散度约束</strong></p> <ul><li><strong>作用</strong>：在强化学习阶段（如PPO），奖励模型的输出需与策略模型的行为保持一致。此时会引入KL散度惩罚项：<br>
[
\text{loss}<em>{\text{kl}} = \beta \cdot \text{KL}(\pi</em>{\phi_{\text{RL}}}(y|x) | \pi_{\text{SFT}}(y|x))
]
防止策略模型过度偏离SFT模型的初始分布，避免训练不稳定。</li></ul> <p>三、关键优化策略</p> <ol><li><p><strong>数据效率</strong><br>
当每个prompt生成9个响应时，可通过组合生成36对比较数据，同时复用已计算的奖励值，减少计算量。</p></li> <li><p><strong>模型初始化</strong><br>
奖励模型常基于SFT模型初始化，利用其已学习的语言理解能力，加速收敛。</p></li> <li><p><strong>动态调整</strong><br>
在训练过程中动态调整学习率或Margin参数，平衡模型对不同偏好强度的学习速度。</p></li></ol> <p>四、应用场景与挑战</p> <ul><li><strong>场景</strong>：广泛用于大语言模型的对齐优化（如GPT-4、Llama 2）、推荐系统排序、对话生成等需人类偏好的任务。</li> <li><strong>挑战</strong>：
<ul><li><strong>数据标注成本高</strong>：需大量人工排序数据，且标注一致性难以保证。</li> <li><strong>偏好复杂性</strong>：人类偏好可能涉及多维度（如安全性、创造性），单一奖励模型难以全面捕捉。</li> <li><strong>泛化能力</strong>：训练好的奖励模型在未见过的领域可能失效，需结合领域自适应技术。</li></ul></li></ul> <p>通过上述方法，奖励模型能够将人类偏好转化为可计算的奖励信号，为强化学习提供有效指导，从而提升模型生成内容的质量和一致性。</p> <ol start="5"><li>目前RLHF方法有没有什么缺陷?如何改进?</li></ol> <p>RLHF（基于人类反馈的强化学习）方法存在一些缺陷，针对这些缺陷也有相应的改进措施，具体如下：</p> <p>RLHF方法的缺陷</p> <ul><li><strong>缺乏真正的强化学习特征</strong>：RLHF缺乏RL的核心特征，如持续的环境交互和长期目标的追求。它主要通过单步或几步优化来调整模型输出，而不是在动态环境中进行多步骤的策略调整，且通常是离线或半离线进行的，缺乏实时的环境反馈和策略更新。</li> <li><strong>训练过程复杂且成本高</strong>：RLHF涉及多个步骤，包括奖励模型训练和RL微调，计算成本高且步骤繁琐。它需要反复从策略模型采样生成回答，这也增加了计算开销。</li> <li><strong>训练稳定性差</strong>：RLHF对超参数敏感，如KL惩罚系数等，容易出现梯度爆炸或策略崩溃等问题，导致训练不稳定，可能出现奖励崩溃或过度优化的情况。</li> <li><strong>依赖奖励模型</strong>：奖励模型的质量直接影响RL微调的效果，但其可能无法完美拟合人类偏好，存在偏差，从而导致策略优化偏离真实目标，使模型行为失调。</li> <li><strong>数据质量问题</strong>：RLHF高度依赖人工反馈获取高质量标注数据，人力与时间成本巨大。同时，标注过程中评估者的主观性和不一致性会产生标注偏差，误导生成模型，且数据量不足时，奖励模型难以全面捕捉人类偏好细节。</li></ul> <ol start="6"><li>介绍一下LLM的直接偏好优化(DPO)</li></ol> <ul><li>是一种，通过正负样本进行学习的方法</li> <li>DPO本质上是在<strong>最大化正样本</strong>的奖励, 并最小化负样本的奖励</li> <li>其<strong>核心技巧</strong>是：通过一个数学推导，将奖励函数的最大化问题，转化为一个<strong>纯粹的策略损失函数</strong>，从而可以直接通过监督学习的方式优化模型。</li></ul> <ol start="7"><li>LLM训练中, 近端策略优化包含哪几个模型?</li></ol> <ul><li>Reference Model(参考模型) 、奖励模型、价值模型、Critic 模型、Actor模型(生成回答)</li></ul> <ol start="8"><li>什么是RLAIF?</li></ol> <blockquote><p>基于AI反馈的强化学习</p></blockquote> <ul><li>使用<strong>AI模型</strong>（通常是预训练的语言奖励模型）来提供反馈，而不直接依赖人类的人工标注。</li> <li>这里的“AI”也可以是某些规则奖励，例如数学答案/代码解释器...</li></ul> <table><thead><tr><th>类型</th> <th>裁判</th> <th>优点</th> <th>缺点</th></tr></thead> <tbody><tr><td>RLHF</td> <td>人类</td> <td>更贴近真实人类偏好</td> <td>成本高、效率低</td></tr> <tr><td>RLAIF</td> <td>模型</td> <td>自动化、可扩展性强</td> <td>可能偏离人类真实偏好</td></tr></tbody></table> <p>RLAIF的最大优势在于可扩展性和On-Policy的特点——不需要昂贵的人工标注，可以生成海量的训练样本，让模型在在线大量试错中快速进化。</p> <p>本质上，都是通过<strong>强化学习的方式</strong>，利用某种形式的&quot;<strong>反馈</strong>&quot;来优化模型的行为。</p> <ol start="9"><li>与有监督学习相比, 强化学习能够给大语言模型带来哪些好处?</li></ol> <ul><li>回答符合人类偏好的答案</li></ul> <ol start="10"><li>介绍一下RLHF中PPO微调过程?</li></ol> <ul><li></li></ul> <ol start="11"><li>你了解DeepMind提出的ReST对齐算法吗?</li></ol> <h2 id="阶段五"><a href="#阶段五" class="header-anchor">#</a> 阶段五</h2> <ol><li>说说你知道的大模型训练or推理的常用优化手段</li></ol> <ul><li>KV Cache</li> <li>静态批处理</li> <li>动态批处理</li> <li>连续批处理</li></ul> <ol start="2"><li><p>一般会对哪些大模型里面的算子做算子融合,说说你知道的</p></li> <li><p>什么是KV Cache技术, 它具体是如何实现的?</p></li></ol> <ul><li>在注意力计算的时候，对矩阵里面的K 和 V 进行缓存，</li> <li>将生成的前面的标记得到KV，进行缓存，在计算下一个标记的时候，直接拿缓存的值，不用去计算之前的值了</li></ul> <p><strong>先前标记的这些K和V的值可以被缓存</strong>, 这样我们就不必在每次调用这个计算的时候重新计算它们, 然后只需要进行一个非常轻量级的连接操作,
在这个操作中<strong>我们获取缓存的值, 附加新标记的新K和V值,进行注意力计算,重新缓存这些值,然后生成下一个标记。</strong></p> <ol start="4"><li>Paged Attention的原理是什么,它解决了大模型推理中的什么问题?</li></ol> <ul><li>核心的一点：把碎片化的显存利用起来，同时把显存的利用率，给利用起来，</li> <li>具体做法，就是把物理上不连续的片，通过内存分页的形式，在逻辑上把它做成一个连续的，这就是 Paged Attention 的一个主要的做法，包括它里面的一些Block 的设置呀，一般是取16
它的一些设置呀，包括对显存的一些预留，预留分片，进行中的分片
都是为了节省显存、提升显存的利用率而做的</li></ul> <ol start="5"><li><p>DeepSpeed推理对算子融合做了哪些优化?</p></li> <li><p>FlashAttention的空间复杂度和对HBM的访问次数是多少?</p></li> <li><p>FlashDecoding在FlashAttention2上做了哪些改进?</p></li> <li><p>FlashDecoding++做了什么优化?</p></li> <li><p>什么是子图融合优化技术,为什么他可以提升推理速度?</p></li> <li><p>MHA,GQA,MQA推理优化技术的区别是什么?</p></li> <li><p>Paged Attention 是如何有效管理具有分页的KV缓存的?</p></li></ol> <ul><li>可以理解为问的，具有分页的内存管理</li></ul> <p>Paged Attention 通过借鉴操作系统的虚拟内存分页技术，将 KV 缓存的管理从「连续内存预分配」重构为「动态分块与非连续存储」，其核心机制包括以下四个层面：</p> <ol start="12"><li>介绍一下动态批处理技术?</li></ol> <ul><li>当一个推理实例（如GPU）空闲时，它不会等待一个固定的批次，而是<strong>实时地从请求队列中取出尽可能多的请求，组成一个新批次</strong>进行处理。批次大小 <code>batch_size</code> 不再是固定的，而是根据当前队列长度动态变化的。</li> <li>但是一个批次内，<strong>如果某个请求需要生成的输出很长</strong>（比如1000个token），而其他请求很短（比如10个token），那么生成长文本的请求会拖累整个批次，导致短请求也要等待很久才能返回。</li></ul> <ol><li><p>请问什么是猜测推理技术? 请举例说明</p></li> <li><p>什么是continuous batching技术,为什么他的效率比动态batching效率高?</p></li></ol> <ul><li>连续批处理技术，它是做了迭代的Token级调度，一个Batch 完成，就在其位置插入一个新的，从而实现一个比静态批处理更高的一个GPU的利用率</li> <li>可以将continuous batching 类比为一列列车，token 是列车上的人，可以随时上车下车</li> <li>如果乘客是比较密集的，列车可以始终达到一个满员的状态，可以极大地提高GPU的利用率</li></ul> <p>动态批处理，一个批次里处理多个请求，但是遇到生成多个标记的请求， 其他请求需要等待这个多标记生成的请求，先完成</p> <ul><li><strong>优点</strong>：
<ul><li><strong>彻底解决了“木桶效应”</strong>：短请求可以快速完成并返回，不会被长请求阻塞。</li> <li><strong>极高的GPU利用率</strong>：GPU几乎在每个时刻都在处理满负荷的计算，因为新的请求可以立即填补已完成请求留下的空位。</li> <li><strong>显著降低延迟</strong>：尤其是对于短文本交互场景，用户体验大幅提升。</li></ul></li></ul> <ol start="15"><li>优化CUDA程序的访存效率, 你可以想到哪些?</li> <li>优化CUDA程序的计算效率, 你又可以想到哪些?</li></ol> <h2 id="阶段六"><a href="#阶段六" class="header-anchor">#</a> 阶段六</h2> <ol><li>ViT的大致原理</li></ol> <blockquote><p>ViT 将图像分割成n个patches，转化为Embedding数据后，<strong>通过 Transformer 编码器进行全局特征学习</strong>，最终完成分类等任务。</p></blockquote> <p>具体的流程：</p> <ol><li><p>首先将图片分成一个个patches</p></li> <li><p>然后通过embedding层得到对应的token</p></li> <li><p>然后再经过 Transformer encoder， 在输入Transformer Encoder之前需要加上[class]token，以及Position Embedding</p></li> <li><p>然后再通过MLP Head 得到最终的一个输出</p></li> <li><p>说一下CLIP模型是如何做图文对齐的</p></li></ol> <blockquote><p>CLIP 采用双编码器结构，分别将图像和文本转换成特征向量，</p></blockquote> <ul><li>文字Encoder</li> <li>图片Encoder</li></ul> <p>CLIP， 输入的是两路： 图片、文字, 将<strong>图片和文字编码</strong>， 然后将文字编码后的结果<strong>转秩</strong>一下，以便和 <strong>图片编码后得到的向量</strong>, <strong>做点积</strong>计算</p> <ul><li>输入的文字，要进行 Tokenizer 分词，Embedding</li> <li>image_embedding 和 text_embedding  做点积</li></ul> <ol start="3"><li>介绍一下stable diffusion的原理</li></ol> <blockquote><p>stable diffusion是：以文本为条件的扩散模型</p></blockquote> <ul><li>输入一个提示词，使用Text Encoder 编码器， 输出出来Embedding， 然后给 VAE 解码器，解码，输出图像</li></ul> <ol start="4"><li>Qwen-VL的三个训练流程分别是什么, 有什么作用</li></ol> <ul><li>预训练
<ul><li>核心作用： 赋予模型基础的视觉-语言关联与理解能力。</li></ul></li> <li>SFT
<ul><li>核心作用： 激发和塑造模型的特定能力，使其能遵循指令并完成复杂任务。</li></ul></li> <li>强化学习
<ul><li>GRPO 训练 or DPO</li> <li>核心作用： 优化模型的输出偏好，生成符合人类偏好的回答（更有用、诚实、无害）。</li></ul></li></ul> <ol start="5"><li>目前的文生图、图生图的方法有哪些?</li></ol> <ul><li>Google Imagen</li> <li>DALL-E</li> <li>VQGAN</li> <li>艺术创作型：Midjourney v6.1</li></ul> <table><thead><tr><th style="text-align:left;">技术方向</th> <th style="text-align:left;">核心功能</th> <th style="text-align:left;">代表性模型/工具</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>文生图 (Text-to-Image)</strong></td> <td style="text-align:left;">根据文本描述生成图像</td> <td style="text-align:left;">Stable Diffusion, DALL·E, Imagen, Nano Banana Pro</td></tr> <tr><td style="text-align:left;"><strong>图生图 (Image-to-Image)</strong></td> <td style="text-align:left;">以输入图像为参考进行生成或编辑</td> <td style="text-align:left;">Qwen-VLo, Nano Banana Pro 的图像编辑功能</td></tr></tbody></table> <ol start="6"><li>多模态大模型如何处理视频输入?</li></ol> <p>与图像相比，处理视频的难点在于：</p> <p>海量数据：一秒30帧的1080p视频，数据量是单张图像的30倍。直接处理所有帧计算成本无法承受。</p> <p>时间冗余：连续帧之间内容高度相似，存在大量冗余信息。</p> <p>时序建模：模型必须理解帧与帧之间的时序关系，才能捕捉动作、因果和故事线。</p> <p>计算瓶颈：无论是视觉编码还是LLM理解，处理长序列视频 token 对硬件要求极高。</p> <p>主流技术路线:</p> <h4 id="路线一-稀疏采样-图像编码器-主流且实用"><a href="#路线一-稀疏采样-图像编码器-主流且实用" class="header-anchor">#</a> 路线一：稀疏采样 + 图像编码器（主流且实用）</h4> <p>这是目前最流行、最实用的方法，许多开源模型（如 <strong>Video-LLaVA</strong>、<strong>LLaVA-NeXT</strong>）都采用此路线。</p> <ul><li><p><strong>思路</strong>：既然视频帧冗余度高，那就不全部处理，只<strong>智能地选取少量关键帧</strong>。</p></li> <li><p><strong>具体做法</strong>：</p> <ol><li><strong>均匀采样</strong>：最简单的方法，每隔N帧取一帧。</li> <li><strong>稀疏采样</strong>：使用更复杂的策略（如场景变化检测）来选取信息量最大的帧。</li> <li><strong>处理</strong>：将选取的每一帧都视为独立的图像，通过一个<strong>预训练的图像编码器</strong>（如 <strong>CLIP的ViT</strong>）进行编码，得到每个帧的视觉特征。</li> <li><strong>输入LLM</strong>：将这些帧的视觉特征序列（可能加上一个可学习的帧位置嵌入）与文本指令一起输入给大语言模型。</li></ol></li> <li><p><strong>优点</strong>：</p> <ul><li>充分利用了成熟的、强大的图像编码器（如CLIP）。</li> <li>计算高效，实现相对简单。</li></ul></li> <li><p><strong>缺点</strong>：</p> <ul><li>可能会丢失一些快速变化或细微的时序信息。</li> <li>对长时间视频的支持仍然有限。</li></ul></li></ul> <ol start="7"><li>ROPE位置编码如何扩展到多模态大模型?</li></ol> <ul><li>ROPE（Rotary Position Embedding，旋转位置编码）最初是为Transformer模型（如LLaMA、GPT-J）在NLP任务中设计的，<strong>但它可以非常优雅地扩展到多模态大模型中</strong>。</li></ul> <p>其核心思想是：<strong>将不同模态（如文本、图像、音频）的元素统一到一个共享的表示空间中，并在该空间中应用具有模态感知能力的旋转位置编码。</strong></p> <p>ROPE通过其<strong>可分解的旋转操作</strong>和<strong>对绝对与相对位置的优雅处理</strong>，使其能够非常灵活地扩展到多模态领域。</p> <p>通过<strong>为不同模态分配不同的旋转基频</strong>，<strong>ROPE成功地让多模态大模型能够理解和区分来自不同模态的元素的位置上下文</strong>，这是构建高效、高性能多模态理解系统的关键一环。</p> <ol start="8"><li>了解MM-RLHF吗, 是怎么做的?</li></ol> <p>简单来说，它是 <code>RLHF</code> 在多模态领域的扩展和升级。</p> <p>RLHF 是让 ChatGPT 等大语言模型变得如此“听话”和“有用”的核心技术，而 MM-RLHF 的目标是让能够理解和生成<strong>图像、视频、音频</strong>等多模态内容的模型也具备同样的能力。</p> <blockquote><p>核心思想</p></blockquote> <p>MM-RLHF 的核心思想与 <code>RLHF</code> 一脉相承：我们不直接告诉模型什么是“好”的答案，而是通过人类对模型不同输出的偏好（喜欢哪个、不喜欢哪个）来间接地“教会”模型我们的价值观和标准。</p> <blockquote><p>怎么做的?</p></blockquote> <ul><li>阶段一：监督微调
<ul><li>选择基础模型</li> <li>微调需要的数据，收集一个高质量的、由人类精心编写的“指令-回答”对数据集。</li></ul></li> <li>阶段二：训练奖励模型
<ul><li>数据收集：</li> <li>模型训练:</li></ul></li> <li>阶段三：强化学习优化</li></ul> <p>与纯文本的 RLHF 相比，MM-RLHF 更加复杂：</p> <ul><li><strong>偏好标注更难、更主观</strong>：判断两张图片哪张更好，可能比判断两段文字更难，因为涉及更多美学、风格等主观因素。标注成本极高。</li> <li><strong>奖励模型更难训练</strong>：捕捉图像质量、艺术风格、与文本的一致性等细微差别，比判断文本质量更具挑战性。</li> <li><strong>生成过程的复杂性</strong>：文生图等模型的生成过程是高度非自回归的，行动空间（像素或潜在空间）巨大且连续，这给强化学习优化带来了巨大困难。</li> <li><strong>评估困难</strong>：如何量化评估生成模型是否“对齐”了，本身就是一个开放性问题。</li></ul> <ol start="9"><li>比较Q-Former和MLP的对齐效果, 为什么现在模型都用MLP而不用Q-Former?</li></ol> <ul><li>Q-Former 是什么，核心结构呀</li> <li>MLP 是什么</li></ul> <blockquote><p>MLP（通常是一个简单的投影层）</p></blockquote> <p>对两者进行一个比较，</p> <blockquote><p>Q-Former VS MLP</p></blockquote> <p>MLP 设计目标： 在计算资源相对充足的情况下，<strong>实现图像特征到文本特征空间的直接、无缝映射。</strong></p> <p>核心结构：通常就是一个或多个线性层，有时会加入非线性激活函数（如GELU）。</p> <ol><li>MLP就是简单的矩阵乘法，计算速度极快。Q-Former包含交叉注意力层，在推理时会引入额外的计算开销。</li> <li>MLP的参数量远小于Q-Former。在一个动辄70亿、130亿参数的模型中，增加一个几十万或几百万参数的MLP几乎可以忽略不计，而Q-Former则会引入数千万的额外参数。</li></ol> <ul><li>总结</li></ul> <ol><li>MLP 推理速度快、参数量小</li> <li>MLP结构简单，易于实现和调试</li> <li>与LLM接口的统一：<strong>现代LLM本质上是接收一个“词嵌入序列”并预测下一个词。</strong> <ul><li>MLP的输出可以直接被视为一组“视觉词”嵌入，与文本词嵌入无缝拼接。</li> <li>这种接口非常自然和统一。</li> <li>虽然Q-Former也输出一个序列，但其内部机制更为复杂。</li></ul></li></ol> <p>还有时代背景： Q-Former是算力受限时期的巧妙设计， MLP： 算力充裕、端到端训练成为主流</p> <ol start="10"><li>对于大模型复杂推理任务, 有哪些主流方法?</li></ol> <ul><li><ol><li>COT</li></ol></li> <li><ol start="2"><li>自我迭代和优化方法</li></ol></li> <li><ol start="3"><li>工具增强，让模型学会调用外部工具</li></ol></li> <li><ol start="4"><li>多智能体协作 - 让模型“团队作战”</li></ol> <ul><li>代表性框架： AutoGPT, ChatDev, MetaGPT, CrewAI等。</li></ul></li> <li><ol start="5"><li>图推理与结构化提示
对于涉及复杂关系、状态变化或逻辑约束的问题，将问题转化为结构化的形式。</li></ol></li></ul> <ol start="11"><li>多模态的GRPO怎么做, 讲一下VLM-R1的核心思想和流程</li></ol> <p>关于多模态GRPO，可以从三个层面来概括：</p> <ol><li><p><strong>定位：</strong> 它是一种<strong>无需训练奖励模型</strong>的强化学习方法，直接用来<strong>对齐和优化多模态模型</strong>的输出，比如让文生图模型生成更符合人类审美的图片。</p></li> <li><p><strong>核心流程：</strong> 它的工作流程可以概括为 <strong>“采样-评分-优化”</strong> 三步循环：</p> <ul><li><strong>采样：</strong> 让当前模型为一批提示生成大量输出（如图片）。</li> <li><strong>评分：</strong> 用一个<strong>预定义的、不可微的奖励函数</strong>（比如一个图像审美打分模型）直接为这些输出打分。</li> <li><strong>优化：</strong> 使用类似PPO的策略梯度算法，<strong>朝着高分方向更新模型，同时约束模型不偏离原始能力太远</strong>。</li></ul></li> <li><p><strong>价值与趋势：</strong></p> <ul><li><strong>它的最大优势是流程简化，避免了训练奖励模型的成本和复杂性。</strong></li> <li>在当前实践中，与其思想一脉相承但更稳定、更流行的方法是 <strong>DPO</strong>，它已经成为多模态对齐领域的主流技术之一。</li></ul></li></ol> <p>总结来说，多模态GRPO/DPO的核心思想，就是<strong>用直接的偏好信号作为“罗盘”，来高效地引导大模型朝着我们期望的方向进化。</strong></p> <blockquote><p>另外一个点：讲一下VLM-R1的核心思想和流程</p></blockquote> <ul><li><p>讲一下VLM-R1的核心思想和流程？</p></li> <li><p>输入一个提示，就可以精准定位图片里的目标的一种手段</p></li></ul> <p>VLM-R1 是一款基于强化学习技术的视觉语言模型，能够通过自然语言指令精确定位图像目标，并支持多模态推理。</p> <ol><li><strong>指代表达理解</strong>：解析自然语言指令，精准定位图像中的特定目标。</li> <li><strong>强化学习优化</strong>：采用 GRPO 技术，在复杂场景下表现出色，提升泛化能力。</li></ol> <p>VLM-R1 提供了两种训练方法：GRPO 和 SFT。</p> <h2 id="汇总"><a href="#汇总" class="header-anchor">#</a> 汇总</h2> <p>vLLM 篇</p> <ol><li>你用过vLLM, 那你了不了解它的底层原理,讲一下Paged Attention?</li></ol> <ul><li>核心的一点：<strong>把碎片化的显存利用起来，来提高显存的利用率</strong></li> <li>具体做法，就是把物理上不连续的片，通过内存分页的形式，在逻辑上把它做成一个连续的，这就是 Paged Attention 的一个主要的做法，包括它里面的一些Block 的设置呀，一般是取16
它的一些设置呀，包括对显存的一些预留，预留分片，进行中的分片
都是为了节省显存、提升显存的利用率而做的</li></ul> <blockquote><p>Paged Attention如何高效管理kv 缓存的，</p></blockquote> <ul><li><p>Paged Attention是VLLM中用于优化Transformer模型推理过程中KV Cache内存管理的关键技术。</p></li> <li><p>其核心原理是: 参考了操作系统的内存分页技术，将KV Cache分块存储在<code>非连续的内存地址</code>中，以提高显存利用率，提升模型推理性能。</p></li></ul> <ol start="2"><li>KV Cache</li></ol> <p>在语言模型生成文本的过程中，每生成一个新的 token，模型都需要注意力计算，以确定当前位置与之前所有位置的相关性.</p> <p>不难发现，大模型生成一个 token 后的注意力计算中，总会用到 token 序列的历史 KV 值，导致重复计算，
KV Cache 的设计正是为了通过缓存历史 KV 值，节省计算开销.</p> <p><strong>KV Cache 能够有效压缩大模型推理时的显存占用.</strong></p> <ol start="3"><li>什么是continuous batching？
<ul><li>连续批处理</li></ul></li></ol> <ul><li>它是做了迭代的Token级调度</li> <li>Batch 的大小是根据每次迭代确定的</li> <li>一个Batch 完成，就可以在其位置插入一个新的，从而实现一个比静态批处理更高的一个 gpu的利用率
可以类比，Continuous Batching 就像一辆列车， Token就像列车上的人，可以随时上车、下车
如果乘客是比较密集的，可以始终达到一个满员的状态，可以极大地提高GPU的利用率</li></ul> <p>因此, 我们能够在最开始将它们添加到批处理中,然后在整个过程中继续添加和删除那些10个标记的较小序列。</p> <p>然后那些落后的、那些100个标记序列最终在未尾完成而不会在整个过程中造成瓶颈。</p> <p>这基本上就是连续批处理，能够为我们做到的事情。</p> <p>而这最终不仅是提高LLM推断的吞吐量和延迟的关键驱动因素之一,还是您常见的LLM推断系统中看到的标记流式处理能力的关键,因为我们能够及时处理它们,并从系统中逐个获取标记,我们能够非常迅速地将这些结果返回给用户, 而不必等待这些大的批处理步骤。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段一" class="sidebar-link reco-side-阶段一" data-v-b57cc07c>阶段一</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段二" class="sidebar-link reco-side-阶段二" data-v-b57cc07c>阶段二</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段三" class="sidebar-link reco-side-阶段三" data-v-b57cc07c>阶段三</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段四" class="sidebar-link reco-side-阶段四" data-v-b57cc07c>阶段四</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段五" class="sidebar-link reco-side-阶段五" data-v-b57cc07c>阶段五</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#阶段六" class="sidebar-link reco-side-阶段六" data-v-b57cc07c>阶段六</a></li><li class="level-2" data-v-b57cc07c><a href="/hmblog/modelstudy/model-question.html#汇总" class="sidebar-link reco-side-汇总" data-v-b57cc07c>汇总</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/hmblog/assets/js/app.252ae38c.js" defer></script><script src="/hmblog/assets/js/7.5041dce4.js" defer></script><script src="/hmblog/assets/js/2.79670d2b.js" defer></script><script src="/hmblog/assets/js/1.1d6abb18.js" defer></script><script src="/hmblog/assets/js/104.4e73c56a.js" defer></script><script src="/hmblog/assets/js/34.b26cede8.js" defer></script>
  </body>
</html>
