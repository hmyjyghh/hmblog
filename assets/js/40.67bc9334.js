(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{484:function(v,_,n){"use strict";n.r(_);var t=n(3),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("好的，我们先分析这段快速排序代码的时间复杂度和空间复杂度。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"时间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[v._v("#")]),v._v(" "),_("strong",[v._v("时间复杂度")])]),v._v(" "),_("h3",{attrs:{id:"平均情况-o-n-log-n"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平均情况-o-n-log-n"}},[v._v("#")]),v._v(" "),_("strong",[v._v("平均情况")]),v._v("：O(n log n)")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("每次划分")]),v._v("：选择基准（pivot），遍历剩余 n 个元素，分成 "),_("code",[v._v("left")]),v._v(" 和 "),_("code",[v._v("right")]),v._v("，这个遍历过程是 O(n)。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("理想划分")]),v._v("：如果每次基准都能将数组均匀分成两半（长度各约 n/2），那么递归深度为 log₂n。")]),v._v(" "),_("ul",[_("li",[v._v("第一层：O(n)")]),v._v(" "),_("li",[v._v("第二层：两个子问题各 O(n/2)，加起来仍是 O(n)")]),v._v(" "),_("li",[v._v("每层总工作量 O(n)，共 log₂n 层"),_("br"),v._v("\n→ "),_("strong",[v._v("总时间 = O(n log n)")])])])]),v._v(" "),_("li",[_("p",[v._v("这个实现里 "),_("code",[v._v("pivot = arr.pop(pivot_index)")]),v._v(" 会使划分后原数组被拆成 "),_("code",[v._v("left")]),v._v("、"),_("code",[v._v("right")]),v._v(" 和新数组，不过这只影响常数因子，不影响大 O。")])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"最坏情况-o-n2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最坏情况-o-n2"}},[v._v("#")]),v._v(" "),_("strong",[v._v("最坏情况")]),v._v("：O(n²)")]),v._v(" "),_("p",[v._v("最坏情况出现在每次选取的基准都是当前子数组的"),_("strong",[v._v("最小或最大元素")]),v._v("。"),_("br"),v._v("\n例如数组已经有序 "),_("code",[v._v("[1, 2, 3, 4, 5]")]),v._v(" 时，选择中间元素（index = len//2）：")]),v._v(" "),_("ul",[_("li",[v._v("第一次：pivot = 3，"),_("code",[v._v("left = [1, 2]")]),v._v("，"),_("code",[v._v("right = [4, 5]")]),v._v(" 还比较均匀。")]),v._v(" "),_("li",[v._v("但如果选择不当，比如总是选第一个元素且已经有序，会变成："),_("br"),v._v("\npivot = 1，"),_("code",[v._v("left = []")]),v._v("，"),_("code",[v._v("right = [2, 3, 4, 5]")]),v._v(" → 右侧 n-1 个元素。"),_("br"),v._v("\n递归下去就是 n + (n-1) + … + 1 = O(n²)。")])]),v._v(" "),_("p",[v._v("不过这个实现"),_("strong",[v._v("基准是中间索引")]),v._v("，对于已经有序的数组，最坏情况概率降低，但如果数组是特定排列（如每次取中间却都是极值），依然可能出现 O(n²)。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"最好情况-o-n-log-n"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最好情况-o-n-log-n"}},[v._v("#")]),v._v(" "),_("strong",[v._v("最好情况")]),v._v("：O(n log n)")]),v._v(" "),_("p",[v._v("每次都能均匀划分，递归树平衡。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"空间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[v._v("#")]),v._v(" "),_("strong",[v._v("空间复杂度")])]),v._v(" "),_("h3",{attrs:{id:"主要空间消耗来源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主要空间消耗来源"}},[v._v("#")]),v._v(" "),_("strong",[v._v("主要空间消耗来源")]),v._v("：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("递归调用栈")]),v._v("：深度为递归树的高度。")]),v._v(" "),_("ul",[_("li",[v._v("平均/最好：O(log n)")]),v._v(" "),_("li",[v._v("最坏：O(n)（退化成链状）")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("额外数组")]),v._v("：此实现不是原地排序，每次递归都创建新的 "),_("code",[v._v("left")]),v._v(" 和 "),_("code",[v._v("right")]),v._v(" 列表，这些列表的总元素数量在每一层加起来都是 O(n)。")]),v._v(" "),_("ul",[_("li",[v._v("例如第一层 n 个元素被分到 left 和 right（加上 pivot 独立），存储它们需要 O(n)。")]),v._v(" "),_("li",[v._v("由于递归过程中，不同层的这些数组同时存在于内存中（因为递归没有立刻合并，而是等到子递归返回），所以空间占用会叠加。")]),v._v(" "),_("li",[v._v("实际上，每次递归都会创建新数组存放子序列，"),_("strong",[v._v("每一层")]),v._v("都要 O(n) 临时存储，递归深度为 O(log n) 时，最大同时存在的数组总元素数为 O(n log n)。")])])])]),v._v(" "),_("p",[v._v("更准确分析（针对这个实现）：")]),v._v(" "),_("ul",[_("li",[v._v("每一层递归（所有该层的子问题合起来）的总元素数为 O(n)。")]),v._v(" "),_("li",[v._v("递归树深度为 d，则所有尚未返回的递归层所占数组总空间 = O(n × d)。"),_("br"),v._v("\n平均 d = O(log n) → "),_("strong",[v._v("平均空间 O(n log n)")]),v._v("；最坏 d = O(n) → "),_("strong",[v._v("最坏空间 O(n²)")]),v._v("（因为每一层都存了逐渐变小的数组，但总和是平方级）。")])]),v._v(" "),_("p",[v._v("简单例子："),_("br"),v._v("\n数组长度 8，均匀划分："),_("br"),v._v("\n第一层：存 left (3), right (4)，pivot (1) 是分开的（pivot 在结果拼接时才出现，但划分时 left 和 right 需要存储原数组所有元素，除了 pivot）。"),_("br"),v._v("\n第二层：两个子问题，它们的 left、right 再存……")]),v._v(" "),_("p",[v._v("这种非原地、每次创建新列表的快排，空间复杂度比原地分区版本高很多。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" "),_("strong",[v._v("总结")])]),v._v(" "),_("p",[v._v("对于你给出的这段 "),_("code",[v._v("quickSort")]),v._v(" 代码：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("时间复杂度")])]),v._v(" "),_("ul",[_("li",[v._v("平均：O(n log n)")]),v._v(" "),_("li",[v._v("最坏：O(n²)")]),v._v(" "),_("li",[v._v("最好：O(n log n)")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("空间复杂度")])]),v._v(" "),_("ul",[_("li",[v._v("平均：O(n log n)（因为递归栈 O(log n) + 每层数组存储 O(n) × 深度 O(log n) 主导）")]),v._v(" "),_("li",[v._v("最坏：O(n²)（递归深度 O(n)，且每层数组存储）")])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"对比原地分区快排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对比原地分区快排"}},[v._v("#")]),v._v(" "),_("strong",[v._v("对比原地分区快排")])]),v._v(" "),_("p",[v._v("原地分区快排（Lomuto 或 Hoare 分区）的空间复杂度：")]),v._v(" "),_("ul",[_("li",[v._v("平均 O(log n)（仅递归栈）")]),v._v(" "),_("li",[v._v("最坏 O(n)（递归栈）")])]),v._v(" "),_("p",[v._v("时间上一样，但你的实现因为 "),_("code",[v._v("pop")]),v._v("、新建数组、拼接，常数因子较大，且空间占用多很多。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("如果想让空间效率更高，可以改为原地分区版本。你的这个版本优点是"),_("strong",[v._v("代码清晰易懂")]),v._v("，适合教学理解分治思想，但工程中通常使用原地分区以避免额外 O(n log n) 的空间。")])])}),[],!1,null,null,null);_.default=r.exports}}]);