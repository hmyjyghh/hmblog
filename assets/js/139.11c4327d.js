(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{582:function(_,v,t){"use strict";t.r(v);var a=t(3),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"向量数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向量数据库"}},[_._v("#")]),_._v(" 向量数据库")]),_._v(" "),v("blockquote",[v("p",[_._v("以向量的形式存储和检索数据，向量是复杂对象(如文本，图像或音频)的数值表示")])]),_._v(" "),v("ul",[v("li",[_._v("它是一种专门设计，"),v("strong",[_._v("用于处理高维数据的数据库")]),_._v("，其中每个条目表示为"),v("strong",[_._v("多维空间中的一个向量")]),_._v("。")]),_._v(" "),v("li",[_._v("向量数据库的核心优势在于，"),v("strong",[_._v("能够高效地存储，索引 和 搜索向量")])]),_._v(" "),v("li",[_._v("有各种相似性搜索算法，特别适合推荐系统(eg: 相关性推荐)")])]),_._v(" "),v("h3",{attrs:{id:"_1-前置概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-前置概念"}},[_._v("#")]),_._v(" 1. 前置概念")]),_._v(" "),v("ul",[v("li",[_._v("向量是具有大小和方向的数学结构")]),_._v(" "),v("li",[_._v("可以将事物的特征用向量来表示")])]),_._v(" "),v("h3",{attrs:{id:"_2-向量数据库的核心思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-向量数据库的核心思想"}},[_._v("#")]),_._v(" 2. 向量数据库的核心思想")]),_._v(" "),v("blockquote",[v("p",[_._v("将文本转为向量，然后将向量存储到数据库中")])]),_._v(" "),v("ul",[v("li",[_._v("当用户输入问题时，将问题转换为向量")]),_._v(" "),v("li",[_._v("然后在数据库中搜索"),v("code",[_._v("最相似的向量")]),_._v("和"),v("code",[_._v("匹配最相似的几个上下文")])]),_._v(" "),v("li",[_._v("最后将文本返回给用户")])]),_._v(" "),v("h3",{attrs:{id:"_3-向量数据库-vs-传统数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-向量数据库-vs-传统数据库"}},[_._v("#")]),_._v(" 3. 向量数据库 vs 传统数据库")]),_._v(" "),v("ul",[v("li",[_._v("向量数据库与传统数据库的区别在于: 它们的"),v("strong",[_._v("应用领域和处理数据的方式")]),_._v("。")])]),_._v(" "),v("h4",{attrs:{id:"两者的对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两者的对比"}},[_._v("#")]),_._v(" 两者的对比")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("对比维度")]),_._v(" "),v("th",[_._v("向量数据库")]),_._v(" "),v("th",[_._v("传统数据库")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("数据表示")]),_._v(" "),v("td",[_._v("数据点以具有固定维度的向量形式表示")]),_._v(" "),v("td",[_._v("数据以表格、行和列的形式组织")])]),_._v(" "),v("tr",[v("td",[_._v("数据类型")]),_._v(" "),v("td",[_._v("多维向量、embeddings")]),_._v(" "),v("td",[_._v("结构化数据（文本、数字、日期）")])]),_._v(" "),v("tr",[v("td",[_._v("查询方式")]),_._v(" "),v("td",[_._v("近似最近邻（ANN）搜索、语义搜索")]),_._v(" "),v("td",[_._v("精确查询、关键词搜索、关系型联接")])]),_._v(" "),v("tr",[v("td",[_._v("应用场景")]),_._v(" "),v("td",[_._v("推荐系统、欺诈检测、异常检测、聊天机器人")]),_._v(" "),v("td",[_._v("银行业务系统、库存管理、客户关系管理（CRM）")])]),_._v(" "),v("tr",[v("td",[_._v("优势")]),_._v(" "),v("td",[_._v("高效的相似性搜索，处理复杂数据，具备良好的扩展性")]),_._v(" "),v("td",[_._v("强大的数据完整性，支持ACID特性")])])])]),_._v(" "),v("h4",{attrs:{id:"核心点分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#核心点分析"}},[_._v("#")]),_._v(" 核心点分析")]),_._v(" "),v("ul",[v("li",[_._v("数据类型不同")]),_._v(" "),v("li",[_._v("查询方式： 近似查询，精确查询")])]),_._v(" "),v("h3",{attrs:{id:"_4-向量数据库的工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-向量数据库的工作流程"}},[_._v("#")]),_._v(" 4. 向量数据库的工作流程")]),_._v(" "),v("blockquote",[v("p",[_._v("向量数据库通过"),v("strong",[_._v("近似最近邻(ANN)搜索")]),_._v("来查找"),v("strong",[_._v("相似的向量")]),_._v(", 从而实现语义信息检索。")])]),_._v(" "),v("h4",{attrs:{id:"_3个步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3个步骤"}},[_._v("#")]),_._v(" 3个步骤")]),_._v(" "),v("ul",[v("li",[_._v("索引(Indexing): 向量数据库将图像、文本、音频或视频内容转换为向量,并使用"),v("code",[_._v("PQ")]),_._v("、"),v("code",[_._v("LSH")]),_._v("或"),v("code",[_._v("HNSW")]),_._v(" 等算法对这些向量进行索引。\n"),v("ul",[v("li",[_._v("这些算法有助于高效处理和存储大量的向量数据, 便于后续的快速检索。")])])]),_._v(" "),v("li",[_._v("查询(Querying): 不同类型的查询(如文本、图像查询)会先被转换为向量, 然后"),v("strong",[_._v("与已经索引的向量进行最近邻比较")]),_._v(", "),v("strong",[_._v("通过最近邻算法找到最相似的结果")]),_._v("。")]),_._v(" "),v("li",[_._v("后处理(Post-processing): 在某些情况下, 向量数据库会从数据集中检索到最近邻向量, 并对它们进行后续处理以返回最终结果。\n"),v("ul",[v("li",[_._v("这个过程可能包括: 使用不同的相似度度量方法, 对最近邻结果进行重新排序, "),v("strong",[_._v("以提升检索结果的准确性和相关性")]),_._v("。")])])])]),_._v(" "),v("h3",{attrs:{id:"_5-向量检索的基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-向量检索的基本原理"}},[_._v("#")]),_._v(" 5. 向量检索的基本原理")]),_._v(" "),v("blockquote",[v("p",[_._v("核心原理：基于"),v("code",[_._v("索引")]),_._v("和"),v("code",[_._v("查询")]),_._v("操作")])]),_._v(" "),v("p",[v("strong",[_._v("以"),v("code",[_._v("PQ")]),_._v(" 量化，乘积量化为例")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("向量数据库")]),_._v("将所有输入的向量"),v("strong",[_._v("转化为指定的维度")]),_._v("，并通过"),v("code",[_._v("聚类算法")]),_._v("将它们分组，每个聚类中心都可以视为一个"),v("code",[_._v("圆形向量")]),_._v(",\n并用于构建最终的索引。")]),_._v(" "),v("li",[_._v("在查询阶段呢，"),v("strong",[_._v("向量数据库")]),_._v(" 通过计算："),v("code",[_._v("输入向量")]),_._v("和"),v("code",[_._v("所有圆形向量之间的距离")]),_._v("，快速找到最相似的聚类中心，从而完成向量的检索。")])]),_._v(" "),v("p",[v("strong",[_._v("总的来说，其实就是向量数据库")])]),_._v(" "),v("ul",[v("li",[_._v("在利用量化的技术或其他近似邻搜索算法来减少搜索空间，提高检索速度，")]),_._v(" "),v("li",[_._v("同时尽可能保证检索的准确性。")])]),_._v(" "),v("h4",{attrs:{id:"通俗易懂的解释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通俗易懂的解释"}},[_._v("#")]),_._v(" 通俗易懂的解释")]),_._v(" "),v("p",[_._v("就是找到"),v("strong",[_._v("和查询向量最接近的那个聚类中心")]),_._v("，"),v("strong",[_._v("缩小搜索范围，再去检索")])]),_._v(" "),v("h3",{attrs:{id:"_6-bm25、tf-idf-排序算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-bm25、tf-idf-排序算法"}},[_._v("#")]),_._v(" 6. BM25、TF-IDF，排序算法")]),_._v(" "),v("ul",[v("li",[_._v("本质还是基于文本的精确匹配")]),_._v(" "),v("li",[_._v("但对于语义搜索功能就非常弱")])]),_._v(" "),v("h3",{attrs:{id:"_7-vector-embedding"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-vector-embedding"}},[_._v("#")]),_._v(" 7. Vector Embedding")]),_._v(" "),v("blockquote",[v("p",[_._v("Vector Embedding 是由 AI 模型（例如大型语言模型 LLM）生成的，它会根据不同的算法生成高维度的向量数据，代表着数据的不同特征，这些特征代表了数据的不同维度。")])]),_._v(" "),v("p",[_._v("例如这份文档是客服培训资料或者操作手册，我们可以先将这份文档的所有内容转化成向量（这个过程称之为 Vector Embedding）")]),_._v(" "),v("ul",[v("li",[_._v("例如，对于文本，这些特征可能包括词汇、语法、语义、情感、情绪、主题、上下文等。对于音频，这些特征可能包括音调、节奏、音高、音色、音量、语音、音乐等。")])]),_._v(" "),v("h3",{attrs:{id:"_8-特征和向量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-特征和向量"}},[_._v("#")]),_._v(" 8. 特征和向量")]),_._v(" "),v("ol",[v("li",[_._v("如何判断相似度?")])]),_._v(" "),v("ul",[v("li",[_._v("可以通过比较向量之间的距离来判断它们的相似度")])]),_._v(" "),v("h3",{attrs:{id:"_9-相似性搜索-similarity-search"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-相似性搜索-similarity-search"}},[_._v("#")]),_._v(" 9. 相似性搜索(Similarity Search)")]),_._v(" "),v("ul",[v("li",[_._v("高效的搜索算法有很多，其主要思想是通过两种方式提高搜索效率：")])]),_._v(" "),v("ol",[v("li",[v("p",[_._v("减少向量大小：通过降维或减少表示向量值的长度。")])]),_._v(" "),v("li",[v("p",[_._v("缩小搜索范围：可以通过"),v("code",[_._v("聚类")]),_._v("或"),v("code",[_._v("将向量组织成基于树形、图形结构来实现")]),_._v("，并限制搜索范围"),v("code",[_._v("仅在最接近的簇中")]),_._v("进行，或者通过最相似的分支进行过滤。")])])]),_._v(" "),v("h3",{attrs:{id:"_10-近似最近邻算法-approximate-nearest-neighbor"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-近似最近邻算法-approximate-nearest-neighbor"}},[_._v("#")]),_._v(" 10. 近似最近邻算法(Approximate Nearest Neighbor)")]),_._v(" "),v("ul",[v("li",[_._v("包含"),v("code",[_._v("暴力搜索")]),_._v("和"),v("code",[_._v("聚类算法")])])]),_._v(" "),v("blockquote",[v("p",[_._v("常见的聚类算法有 "),v("code",[_._v("K-Means")])])]),_._v(" "),v("p",[v("strong",[_._v("k-means 算法的基本步骤")])]),_._v(" "),v("ol",[v("li",[_._v("选择"),v("code",[_._v("k")]),_._v("个初始聚类中心。")]),_._v(" "),v("li",[_._v("将每个数据点分配到最近的聚类中心。")]),_._v(" "),v("li",[_._v("计算每个聚类的新中心。")]),_._v(" "),v("li",[_._v("重复步骤 2 和 3，直到聚类中心不再改变或达到最大迭代次数(趋于稳定)。")])]),_._v(" "),v("h3",{attrs:{id:"_11-pq-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-pq-算法"}},[_._v("#")]),_._v(" 11. PQ 算法")]),_._v(" "),v("p",[_._v("出现的原因是： 在大规模数据集中，聚类算法最大的问题在于内存占用太大。")]),_._v(" "),v("ol",[v("li",[_._v("除了要保存每个向量的坐标")]),_._v(" "),v("li",[_._v("还需要维护聚类中心和每个向量的聚类中心索引，这也会占用大量的内存。")])]),_._v(" "),v("p",[_._v("对于问题1： 可以通过量化 (Quantization) 的方式解决，也就是常见的有损压缩。")]),_._v(" "),v("p",[_._v("降维：")]),_._v(" "),v("ul",[v("li",[_._v("比如将 128 维的向量分为 8 个 16 维的向量，")]),_._v(" "),v("li",[_._v("然后在 8 个 16 维的子向量上分别进行聚类，因为 16 维的子向量大概只需要 256 个聚类中心就能得到还不错的量化结果，所以就可以将码本的大小从 2^64 降低到 8 * 256 = 2048 个聚类中心，从而降低内存开销。")])]),_._v(" "),v("p",[_._v("这也就是乘积量化"),v("code",[_._v("（Product Quantization）")]),_._v("的原理。")]),_._v(" "),v("ul",[v("li",[_._v("使用 PQ 算法，可以显著的减少内存的开销，同时加快搜索的速度，")]),_._v(" "),v("li",[_._v("它唯一的问题是搜索的质量会有所下降，但就像我们刚才所讲，所有算法都是在内存、速度和质量上做一个权衡。")])]),_._v(" "),v("h3",{attrs:{id:"_12-hnsw"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-hnsw"}},[_._v("#")]),_._v(" 12. HNSW")]),_._v(" "),v("blockquote",[v("p",[_._v("Hierarchical Navigable Small Worlds: 分层导航的小世界")])]),_._v(" "),v("ul",[v("li",[_._v("除了聚类以外，也可以通过构建树或者构建图的方式来实现近似最近邻搜索。")]),_._v(" "),v("li",[_._v("这种方法的基本思想是每次将向量加到数据库中的时候，就先找到与它最相邻的向量，然后将它们连接起来，这样就构成了一个图。")]),_._v(" "),v("li",[_._v("当需要搜索的时候，就可以从图中的某个节点开始，不断的进行最相邻搜索和最短路径计算，直到找到最相似的向量。")])]),_._v(" "),v("p",[_._v("HNSW 算法是一种经典的空间换时间的算法，它的搜索质量和搜索速度都比较高，但是它的内存开销也比较大，因为不仅需要将所有的向量都存储在内存中。还需要维护一个图的结构，也同样需要存储。所以这类算法需要根据实际的场景来选择。")]),_._v(" "),v("h3",{attrs:{id:"_13-局部敏感哈希算法-lsh"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-局部敏感哈希算法-lsh"}},[_._v("#")]),_._v(" 13. 局部敏感哈希算法(LSH)")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("或者叫位置敏感哈希函数")])]),_._v(" "),v("li",[v("p",[_._v("局部敏感哈希（Locality Sensitive Hashing）也是一种使用近似最近邻搜索的索引技术。")])]),_._v(" "),v("li",[v("p",[_._v("它的特点是快速，同时仍然提供一个近似、非穷举的结果。")])]),_._v(" "),v("li",[v("p",[_._v("LSH "),v("strong",[_._v("使用一组哈希函数将相似向量映射到“桶”中")]),_._v("，从而使相似向量具有相同的哈希值。")])]),_._v(" "),v("li",[v("p",[_._v("这样，就可以通过比较哈希值来判断向量之间的相似度。")])])]),_._v(" "),v("h3",{attrs:{id:"_14-相似性测量-similarity-measurement"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-相似性测量-similarity-measurement"}},[_._v("#")]),_._v(" 14. 相似性测量 (Similarity Measurement)")]),_._v(" "),v("ol",[v("li",[_._v("欧几里得距离（Euclidean Distance）")]),_._v(" "),v("li",[_._v("余弦相似度（Cosine Similarity）")]),_._v(" "),v("li",[_._v("点积相似度 (Dot product Similarity)")])]),_._v(" "),v("ul",[v("li",[_._v("余弦距离，越⼤越相似")]),_._v(" "),v("li",[_._v("欧式距离，越⼩越相似")])]),_._v(" "),v("p",[_._v("在您的RAG系统中，文本嵌入通常使用"),v("strong",[_._v("余弦相似度")]),_._v("，因为"),v("strong",[_._v("它更关注语义方向")]),_._v("而非向量长度。")]),_._v(" "),v("h3",{attrs:{id:"_15-过滤-filtering"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-过滤-filtering"}},[_._v("#")]),_._v(" 15. 过滤 (Filtering)")]),_._v(" "),v("p",[_._v("在实际的业务场景中，往往不需要在整个向量数据库中进行相似性搜索，"),v("code",[_._v("而是通过部分的业务字段")]),_._v("进行过滤再进行查询。")]),_._v(" "),v("ul",[v("li",[_._v("所以存储在数据库的向量往往还需要包含"),v("code",[_._v("元数据")]),_._v("，例如用户 ID、文档 ID 等信息。\n-`这样就可以在搜索的时候，根据元数据来过滤搜索结果，从而得到最终的结果。")])]),_._v(" "),v("h3",{attrs:{id:"_16-如何选型向量数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-如何选型向量数据库"}},[_._v("#")]),_._v(" 16. 如何选型向量数据库?")]),_._v(" "),v("h4",{attrs:{id:"milvus"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#milvus"}},[_._v("#")]),_._v(" Milvus")]),_._v(" "),v("p",[_._v("Milvus的关键特性包括：")]),_._v(" "),v("ul",[v("li",[_._v("支持海量数据的快速检索")]),_._v(" "),v("li",[_._v("灵活的数据更新和扩展的功能, 具有一个高可用的架构")]),_._v(" "),v("li",[_._v("生态做的很好，可以无缝去集成这种深度学习的框架，包括模型，比如常见的一些向量模型，ranker模型，都能用Milvus来做集成")]),_._v(" "),v("li",[_._v("支持混合检索")]),_._v(" "),v("li",[_._v("检索效率高，毫秒级搜索万亿级向量数据集")])]),_._v(" "),v("h4",{attrs:{id:"chroma"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#chroma"}},[_._v("#")]),_._v(" Chroma")]),_._v(" "),v("p",[_._v("Chroma的关键特性包括:")]),_._v(" "),v("ul",[v("li",[_._v("功能丰富：⽀持查询、过滤、密度估计等多种功能")]),_._v(" "),v("li",[_._v("即将添加的语⾔链（LangChain）、LlamaIndex等更多功能")]),_._v(" "),v("li",[_._v("相同的API可以在Python笔记本中运⾏，也可以扩展到集群，⽤于开发、测试和⽣产")])]),_._v(" "),v("h4",{attrs:{id:"faiss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faiss"}},[_._v("#")]),_._v(" Faiss")]),_._v(" "),v("p",[_._v("Faiss的关键特性包括：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("不仅返回最近的邻居，还返回第⼆近、第三近和第k近的邻居")])]),_._v(" "),v("li",[v("p",[_._v("可以同时搜索多个向量，⽽不仅仅是单个向量（批量处理）")])]),_._v(" "),v("li",[v("p",[_._v("使⽤最⼤内积搜索⽽不是最⼩欧⼏⾥得搜索")])]),_._v(" "),v("li",[v("p",[_._v("也⽀持其他距离度量，但程度较低。")])]),_._v(" "),v("li",[v("p",[_._v("返回查询位置附近指定半径内的所有元素（范围搜索）")])]),_._v(" "),v("li",[v("p",[_._v("可以将索引存储在磁盘上，⽽不仅仅是RAM中")])]),_._v(" "),v("li",[v("p",[_._v("如何选型？")])])]),_._v(" "),v("p",[_._v("需要根据项⽬的具体需求、团队的技术背景和资源情况来综合评估。")]),_._v(" "),v("h3",{attrs:{id:"_17-项目实战中的用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-项目实战中的用法"}},[_._v("#")]),_._v(" 17. 项目实战中的用法")]),_._v(" "),v("h4",{attrs:{id:"milvus-向量数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#milvus-向量数据库"}},[_._v("#")]),_._v(" Milvus 向量数据库")]),_._v(" "),v("div",{staticClass:"language-py extra-class"},[v("pre",{pre:!0,attrs:{class:"language-py"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("from")]),_._v(" pymilvus "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("import")]),_._v(" AnnSearchRequest\n")])])]),v("p",[_._v("在 PyMilvus 中，"),v("code",[_._v("AnnSearchRequest")]),_._v(" 是 "),v("strong",[_._v("向量近邻搜索（Approximate Nearest Neighbor Search）的请求封装类")]),_._v("，核心作用是："),v("strong",[_._v("将单次向量搜索的所有参数（查询向量、搜索集合、搜索参数等）统一封装成一个请求对象")]),_._v("，支持两种核心使用场景：")]),_._v(" "),v("h4",{attrs:{id:"一、核心作用-封装单次搜索的完整参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、核心作用-封装单次搜索的完整参数"}},[_._v("#")]),_._v(" 一、核心作用：封装单次搜索的完整参数")]),_._v(" "),v("p",[_._v("向量搜索需要多个关键参数（如查询向量、目标集合、距离度量方式、TopK 等），"),v("code",[_._v("AnnSearchRequest")]),_._v(" 把这些参数整合为一个结构化对象，避免参数分散传递导致的混乱，同时让代码更易维护。")]),_._v(" "),v("h4",{attrs:{id:"必须-常用参数说明-初始化时指定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#必须-常用参数说明-初始化时指定"}},[_._v("#")]),_._v(" 必须/常用参数说明（初始化时指定）：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("参数名")]),_._v(" "),v("th",[_._v("类型/说明")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("data")])]),_._v(" "),v("td",[_._v("查询向量数据（如 "),v("code",[_._v("[[1.2, 3.4, ...]]")]),_._v("，支持单向量或多向量批量查询）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("collection_name")])]),_._v(" "),v("td",[_._v("要搜索的 Milvus 集合名称（字符串）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("param")])]),_._v(" "),v("td",[_._v("搜索配置字典（核心！如 "),v("code",[_._v('{"metric_type": "L2", "params": {"nprobe": 10}}')]),_._v("）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("limit")])]),_._v(" "),v("td",[_._v("返回的TopK结果数（默认10，即返回与查询向量最相似的前K个结果）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("output_fields")])]),_._v(" "),v("td",[_._v("需要返回的字段列表（默认只返回主键和距离，可指定其他字段如 "),v("code",[_._v('["text", "label"]')]),_._v("）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("partition_names")])]),_._v(" "),v("td",[_._v("要搜索的分区名称列表（可选，不指定则搜索全集合）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("expr")])]),_._v(" "),v("td",[_._v("布尔过滤表达式（可选，如 "),v("code",[_._v("label == 1")]),_._v("，只搜索满足条件的数据）")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("consistency_level")])]),_._v(" "),v("td",[_._v("搜索的一致性级别（可选，如 "),v("code",[_._v("ConsistencyLevel.STRONG")]),_._v("，默认继承集合配置）")])])])]),_._v(" "),v("h4",{attrs:{id:"场景-2-多集合-多参数联合搜索-核心价值场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景-2-多集合-多参数联合搜索-核心价值场景"}},[_._v("#")]),_._v(" 场景 2：多集合 / 多参数联合搜索（核心价值场景）")]),_._v(" "),v("p",[_._v("这是 "),v("code",[_._v("AnnSearchRequest")]),_._v(" 最关键的用途："),v("strong",[_._v("同时向多个集合（或同一集合的不同分区 / 不同搜索参数）发起搜索，再通过 RRFRanker 或 WeightedRanker 对所有结果进行融合排序。")])]),_._v(" "),v("div",{staticClass:"language-py extra-class"},[v("pre",{pre:!0,attrs:{class:"language-py"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 4. 执行联合搜索，用 RRFRanker 融合结果（基于召回率的融合排序）")]),_._v("\nranker "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" RRFRanker"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("k"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("60")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("  "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# k是融合时参考的总结果数，默认60")]),_._v("\nresults "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" utility"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("search_multi"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("\n    requests"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("[")]),_._v("req1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" req2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("]")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("  "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 传入多个搜索请求")]),_._v("\n    ranker"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v("ranker"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("          "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 指定结果融合策略")]),_._v("\n    limit"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("20")]),_._v("                "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 最终返回的TopK结果")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])])]),v("h4",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[v("code",[_._v("AnnSearchRequest")]),_._v(" 的核心价值是 "),v("strong",[_._v("“结构化封装搜索参数” + “支持多集合联合搜索”")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("简单场景下：让单次搜索的参数更清晰；")]),_._v(" "),v("li",[_._v("复杂场景下：实现多集合/多参数的联合搜索与结果融合，是 "),v("code",[_._v("Milvus")]),_._v(" 中实现跨集合向量检索的关键类。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);