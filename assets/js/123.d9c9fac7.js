(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{571:function(_,r,t){"use strict";t.r(r);var a=t(3),e=Object(a.a)({},(function(){var _=this,r=_._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h2",{attrs:{id:"transformer-相关"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformer-相关"}},[_._v("#")]),_._v(" Transformer 相关")]),_._v(" "),r("h3",{attrs:{id:"_1-什么是位置编码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是位置编码"}},[_._v("#")]),_._v(" 1. 什么是位置编码？")]),_._v(" "),r("blockquote",[r("p",[_._v("当我们将文本输入模型时，往往会忽略输入序列中单词的顺序")])]),_._v(" "),r("p",[_._v("举个幽默性的例子：\neg: 狗咬了我  和 我咬了狗， 在模型看来，是一样的，这是灾难性的")]),_._v(" "),r("ul",[r("li",[_._v("Transformer 模型，与之前的RNN 和 LSTM 不同，"),r("strong",[_._v("Transformer 不按顺序处理数据")]),_._v("，而是并行处理输入。")]),_._v(" "),r("li",[_._v("因此，我们需要位置编码来告诉模型，"),r("strong",[_._v("输入序列中各个单词的顺序")]),_._v("。")])]),_._v(" "),r("blockquote",[r("p",[_._v("注意： 位置编码在 transformer 模型架构中的位置，")])]),_._v(" "),r("ul",[r("li",[_._v("输入转为 embedding，添加位置信息，使模型更好地理解每个词的位置。")])]),_._v(" "),r("h3",{attrs:{id:"_2-解释一下语言模型中token的概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-解释一下语言模型中token的概念"}},[_._v("#")]),_._v(" 2. 解释一下语言模型中token的概念？")]),_._v(" "),r("blockquote",[r("p",[_._v("在LLMs 中， token是模型读取或生成的文本单位。")])]),_._v(" "),r("p",[_._v("Token可以是字符、单词、子词或其他文本或代码片段, 具体取决于所使用的"),r("code",[_._v("tokenization")]),_._v("方法或方案。")]),_._v(" "),r("blockquote",[r("p",[_._v("语言模型中常见的几种tokenization方法:")])]),_._v(" "),r("ul",[r("li",[_._v("基于单词的")]),_._v(" "),r("li",[_._v("基于字符的")]),_._v(" "),r("li",[_._v("基于子词的")])]),_._v(" "),r("h3",{attrs:{id:"_3-简单说下什么是大语言模型-以及它是如何训练的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-简单说下什么是大语言模型-以及它是如何训练的"}},[_._v("#")]),_._v(" 3. 简单说下什么是大语言模型, 以及它是如何训练的?")]),_._v(" "),r("blockquote",[r("p",[_._v("什么是大语言模型?")])]),_._v(" "),r("ul",[r("li",[_._v("LLM是高级的自然语言处理(NLP)模型, 经过海量数据集的训练, "),r("strong",[_._v("能够理解和生成类似人类的文本")]),_._v("。")]),_._v(" "),r("li",[_._v("能够基于输入生成连贯且上下文相关的文本。")])]),_._v(" "),r("p",[r("strong",[_._v("总结一下, 大语言模型")]),_._v(":")]),_._v(" "),r("ul",[r("li",[_._v("一种能够"),r("code",[_._v("识别、预测和生成人类语言")]),_._v("的机器学习算法。")]),_._v(" "),r("li",[_._v("预训练规模达到PB级的文本数据集,通常包含数十亿到数千亿个参数的超大模型。")]),_._v(" "),r("li",[_._v("LLM通常先在大规模数据集上进行预训练, 然后再针对特定任务进行微调。")])]),_._v(" "),r("blockquote",[r("p",[_._v("如何训练的?")])]),_._v(" "),r("ul",[r("li",[_._v("在海量的数据集上，进行预训练")]),_._v(" "),r("li",[_._v("微调")]),_._v(" "),r("li",[_._v("强化学习")])]),_._v(" "),r("h3",{attrs:{id:"_4-如何在大型语言模型中使用stop-sequence"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何在大型语言模型中使用stop-sequence"}},[_._v("#")]),_._v(" 4. 如何在大型语言模型中使用Stop Sequence?")]),_._v(" "),r("blockquote",[r("p",[_._v("停止序列")])]),_._v(" "),r("p",[_._v("Stop Sequence 用于"),r("strong",[_._v("让模型在期望的点停止生成")]),_._v(", 例如在句子或列表结束时。通常情况下,回车键 "),r("strong",[_._v("(\\n)可以作为单行完成的Stop Sequence")]),_._v("。")]),_._v(" "),r("p",[_._v("在聊天场景中,目标是只生成与当前说话者相关的一行文本。使用了以下三个Stop Sequences:")]),_._v(" "),r("ul",[r("li",[_._v("换行符(\\n)")]),_._v(" "),r("li",[_._v('字符串"Human:"')]),_._v(" "),r("li",[_._v('字符串"Al:"')])]),_._v(" "),r("p",[_._v("总结: Stop Sequence可以"),r("strong",[_._v("帮助模型在合适的地方停止生成")]),_._v(", 避免生成不必要的文本或发生不合理的切换。")]),_._v(" "),r("ul",[r("li",[_._v("它特别适用于"),r("code",[_._v("控制生成长度和格式的场景")]),_._v("。")])]),_._v(" "),r("h3",{attrs:{id:"_5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5"}},[_._v("#")]),_._v(" 5.")]),_._v(" "),r("h3",{attrs:{id:"_6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6"}},[_._v("#")]),_._v(" 6.")]),_._v(" "),r("h3",{attrs:{id:"_7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7"}},[_._v("#")]),_._v(" 7.")]),_._v(" "),r("h3",{attrs:{id:"_8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8"}},[_._v("#")]),_._v(" 8.")]),_._v(" "),r("h3",{attrs:{id:"_9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9"}},[_._v("#")]),_._v(" 9.")]),_._v(" "),r("h3",{attrs:{id:"_10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10"}},[_._v("#")]),_._v(" 10.")]),_._v(" "),r("h2",{attrs:{id:"搜索-search"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#搜索-search"}},[_._v("#")]),_._v(" 搜索（Search）")]),_._v(" "),r("h3",{attrs:{id:"_1-为什么高质量搜索功能对大模型非常重要"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么高质量搜索功能对大模型非常重要"}},[_._v("#")]),_._v(" 1. 为什么高质量搜索功能对大模型非常重要?")]),_._v(" "),r("blockquote",[r("p",[_._v("对于提升LLM在"),r("strong",[_._v("需要从输入上下文中识别相关信息的任务中")]),_._v("的表现至关重要, 尤其是在"),r("code",[_._v("多文档问答")]),_._v("和键值检索等应用场景中。")])]),_._v(" "),r("ol",[r("li",[_._v("当输入"),r("strong",[_._v("上下文变得更长时, 模型性能会显著下降")]),_._v(", 同时成本也会增加。")]),_._v(" "),r("li",[_._v("因此, 提供精确且相关的信息不仅可以降低成本, 还能够提升LLM系统的准确性。")])]),_._v(" "),r("ul",[r("li",[_._v('研究表明, LLM在上下文开头或结尾有相关信息时, 能达到最佳效果(可以看到一个U型曲线)。这种现象通常被称为"Lost in the Middle"')])]),_._v(" "),r("h3",{attrs:{id:"_2-在信息检索和语义搜索中-常用的架构模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-在信息检索和语义搜索中-常用的架构模式"}},[_._v("#")]),_._v(" 2. 在信息检索和语义搜索中, 常用的架构模式")]),_._v(" "),r("blockquote",[r("p",[_._v("主要有两种: Bi-Encoder 模型 和 Cross-Encoder模型")])]),_._v(" "),r("ol",[r("li",[_._v("Bi-Encoder 模型")])]),_._v(" "),r("ul",[r("li",[r("p",[_._v("在Bi-Encoder模型中,可以并行使用encoders--个用于编码输入query,另一个用于编码候选\ndocuments。它们独立工作,为query和每个document生成各自的embedding。Bi-Encoder将信息\n编码为向量形式(如SentenceAvec或Sentence Bvec),可以使使用距离度量来比较这些向量的相似\n性。")])]),_._v(" "),r("li",[r("p",[_._v("应用场景:")]),_._v(" "),r("ul",[r("li",[_._v("Bi-Encoder常用于以document检索为主要目标的任务(如ANNSearch), 例如搜索引擎和推荐系统。")])])])]),_._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[_._v("Cross-Encoder模型")])]),_._v(" "),r("ul",[r("li",[r("p",[_._v("在Cross-Encoder模型中,query和document在一个encoder中共同处理。这就意味着模型的输入\n必须是包含query和document的一对信息,最终输出的相似度分数介于0到1之间,1表示最相似\n因此,Cross-Encoder模型需要逐对输入来计算相似性。")])]),_._v(" "),r("li",[r("p",[_._v("应用场景:")]),_._v(" "),r("ul",[r("li",[_._v("Cross-Encoder在需要捕捉query与document之间交互关系的任务中非常有用,比如需要理解上下文\n或query与document关系的任务。Cross-Encoder通常用作ranlking模型,帮助根据query对搜索\n结果进行排序。")])])])]),_._v(" "),r("h3",{attrs:{id:"_3-如何在大规模数据集中实现高效且准确的搜索"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何在大规模数据集中实现高效且准确的搜索"}},[_._v("#")]),_._v(" 3. 如何在大规模数据集中实现高效且准确的搜索?")]),_._v(" "),r("p",[_._v("使用"),r("code",[_._v("Cross-Encoder模型")]),_._v("相比于"),r("code",[_._v("Bi-Encoder模型")]),_._v(" "),r("strong",[_._v("能够实现更高的准确性")]),_._v(", 但代价是速度会变慢。")]),_._v(" "),r("ul",[r("li",[_._v("因此,在信息检索或语义搜索场景下,将Cross-Ercoder和Bi-Encoder结合使用是一个合理的选择。")])]),_._v(" "),r("p",[_._v("首先,可以使用高效的Bi-Encoder来检索出前100个最相似的句子,然后再使用Cross-Encoder计算每对\n(query,hit)的分数,对这些结果进行重新排序。")]),_._v(" "),r("p",[_._v("实际操作中,这个流程如下:\n·第一步:使用文档集合和查询,利用Bi-Encoder模型快速检索出候选结果列表。之所以优先使用Bi\nEncoder,是因为它速度快,能够准确找到与查询在语义上相似的文档,同时也会包含一些不需要的额外\n文档。\n第二步:将候选结果输入Cross-Encoder模型,进一步筛选出最相关的结果。Cross-Encoder模型只在\nBi-Encoder结果的一个子集中运行,由于Cross-Encoder准确度高,可以有效过滤掉Bi-Encoder中的\n无关文档。\n这种方法结合了Bi-Encoder的高效检索能力和Cross-Encoder的的高准确度,适合在大规模数据集上使用。")]),_._v(" "),r("h3",{attrs:{id:"_4-如果有一个rag系统-但结果不准确。经调查发现检索系统不够准确-可以采取哪些步骤来改进它"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-如果有一个rag系统-但结果不准确。经调查发现检索系统不够准确-可以采取哪些步骤来改进它"}},[_._v("#")]),_._v(" 4. 如果有一个RAG系统, 但结果不准确。经调查发现检索系统不够准确, 可以采取哪些步骤来改进它?")]),_._v(" "),r("ol",[r("li",[_._v("数据分块策略:")])]),_._v(" "),r("ul",[r("li",[_._v("数据分块方式的不同会对搜索结果产生显著影响,详细内容大家可以回\n看一下数据分块部分的内容。")])]),_._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[_._v("搜索策略:\n有三种搜索方式可供选择:\n。全文搜索:将内容分解为关键字以进行搜索。\n·向量搜索:使用向量embeddings进行搜索。\n混合搜索:结合以上两种方法,使用关键字和向量检索来获得最佳结果。注意,混合搜索优于全文搜\n索和向量搜索。")])]),_._v(" "),r("li",[r("p",[_._v("查询类型:\n微软曾在一项实验中发现,不同风格的查询在不同的搜索设置中会有不同的NDCG分数。")])])]),_._v(" "),r("p",[_._v('重排序模型:\n一个强大的重排序模型可以改进搜索结果。\nFine-tuningembedding 模型:\n正如在前一个问题"Walk me through steps of improving sentende transformer model used for\nembedding?"中所看到的那样,Fine-tuning能显著改进embeddiing表示和搜索结果。\n·Fine-tuned重排序模型:\n我们可以在自定义数据上对重排序模型进行Fine-tuning,以提高重排序模型的准确性')]),_._v(" "),r("h3",{attrs:{id:"_5-关键字检索-keyword-based-retrieval-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-关键字检索-keyword-based-retrieval-方法"}},[_._v("#")]),_._v(" 5. 关键字检索(keyword-based retrieval)方法")]),_._v(" "),r("blockquote",[r("p",[_._v("关键字检索（keyword-based retrieval）是一类基于词项匹配的检索范式，而 BM25 是该范式下的一种经典排序算法，二者是 “范畴与实例” 的关系，并非完全等同。")])]),_._v(" "),r("p",[_._v('BM25有几个关键组成部分:\n·词频(TF):这表示一个词在文档中出现的频率。不过,BM25并不是是简单地使用原始的词频,而是进行\n了一些修改,加入了"饱和效应"(saturation effects)。这样做的目的是防止高频出现的词对相关性得\n分产生过大的影响。\n逆文档频率(IDF):这是衡量一个词在所有文档中重要性的指标。IDF会给稀有词更高的权重,而对于那\n些常见词,它会赋予较低的权重。\n文档长度归一化:由于长文档中术语可能自然地出现得更频繁,这样会导致偏差。因此,BM25对词频进\n行归一化,调整文档的长度,避免评分向长文档倾斜。\n·查询词饱和:这是为了减少高词频对相关性评分的过度影响,即使一个查询词出现非常多次,其影响力也\n会逐渐减弱。')]),_._v(" "),r("p",[_._v("BM25的优缺点\n优点\n。简单高效\n。同时考虑了词频和文档长度\n。能够处理大型文档集合\n缺点\n。BM25不考虑查询和文档的语义或上下文\n。假设查询词是独立的,这不一定总是成立\n。过度依赖词频和文档长度,可能忽视其他重要因素")]),_._v(" "),r("h3",{attrs:{id:"_6-如何微调re-ranking模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何微调re-ranking模型"}},[_._v("#")]),_._v(" 6. 如何微调re-ranking模型?")]),_._v(" "),r("p",[_._v("微调re-ranking模型的一种常用方法是:")]),_._v(" "),r("ul",[r("li",[_._v("使用Sentence Transformer。")]),_._v(" "),r("li",[_._v("Cross-encoder模型是基于transformer的模型(例如BERT、ROBERTa等),它们接受一对句子作为输入,输出一个连续的值来表示两\n个句子的语义相似度。")]),_._v(" "),r("li",[_._v("Sentence Transformers是一个Python框架, 可以用来训练和使用这些模型。\n此外, Sentence Transformers 还支持为句子对的评分和句子对分类任务训练Cross-Encoder模型。")])]),_._v(" "),r("ol",[r("li",[_._v("首先准备数据集，结合RAG 项目里面，微调reranker 模型的步骤，来理解")])]),_._v(" "),r("p",[_._v("模型训练:\n·训练模型相对简单。首先选择一个基础模型(Huggingface的任意模型都可以使用),并根据任务需要定\n义标签数量。\n在连续评分的情况下,我们可以使用CECorrelationEvaluator进行评估。这个类适用于Cross-\nEncoder模型评估,它会计算句子对的预测评分与实际评分之间的Pearson和Spearman相关系数。\n·对于二分类任务,我们可以使用CEBinaryClassificationEvaluator,而多分类任务可以使用CESOf\ntmaxAccuracyEvaluator 。")]),_._v(" "),r("ul",[r("li",[_._v("最后, 对模型进行评估, 如果模型表现达到预期效果, 保存模型")])]),_._v(" "),r("h3",{attrs:{id:"_7-信息检索中常用的评价指标-以及这些指标在什么时候会失效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-信息检索中常用的评价指标-以及这些指标在什么时候会失效"}},[_._v("#")]),_._v(" 7. 信息检索中常用的评价指标, 以及这些指标在什么时候会失效?")]),_._v(" "),r("blockquote",[r("p",[_._v("在信息检索中, 最常用的评价指标是"),r("code",[_._v("Accuracy@1")]),_._v("和"),r("code",[_._v("Accurracy@3")])])]),_._v(" "),r("ol",[r("li",[_._v("Accuracy@1:这个指标衡量模型在重新排序的结果列表中将最相关关的项排在第一位的准确率。具体来\n说,它是模型对于查询能够将最佳答案排在首位的比例。较高的Accuracy@1表明系统在将最相关项置于\n列表顶端方面表现更好。")]),_._v(" "),r("li",[_._v("Accuracy@3:这个指标类似于Accuracy@1,但它衡量的是最相关的项是否出现在重新排序结果列表的\n前三个位置中。Accuracy@3表示的是模型在查询中将最佳答案排在前前三名的比例。较高的Accuracy@3\n表明系统在将相关项置于前3个位置方面表现较好。")])]),_._v(" "),r("p",[_._v("Accuracy@N的局限性:Accuracy@N指标衡量的是在前k个文档中是否至少存在一个相关结果,但它无法评\n估相关项在列表中出现的具体位置。\n例如,Accuracy可以告诉我们相关结果是否出现在前10个搜索索结果中,但无法说明它是排在第一个位置还是最\n后一个位置。因此,当我们关心相关结果出现在列表中的具体顺序时Accuracy@N的表现可能不够理想。")]),_._v(" "),r("h3",{attrs:{id:"_8-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-2"}},[_._v("#")]),_._v(" 8.")]),_._v(" "),r("h3",{attrs:{id:"_9-一个推荐系统-应该选择哪种评价指标来评估系统的效果"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-一个推荐系统-应该选择哪种评价指标来评估系统的效果"}},[_._v("#")]),_._v(" 9. 一个推荐系统, 应该选择哪种评价指标来评估系统的效果?")]),_._v(" "),r("p",[_._v("所以nDCG (Normalized Discounted Cumulative Gain)是推荐系统或信息检索中常用的一个指标,用来评\n估排序模型的质量。\n它既考虑返回项的相关性,也考虑它们在排序列表中的位置。其核心思想是高度相关的项应该更早地出现在列\n表中。")]),_._v(" "),r("h3",{attrs:{id:"_10-对比不同的信息检索指标-并说明分别在什么情况下使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-对比不同的信息检索指标-并说明分别在什么情况下使用"}},[_._v("#")]),_._v(" 10. 对比不同的信息检索指标, 并说明分别在什么情况下使用?")]),_._v(" "),r("table",[r("thead",[r("tr",[r("th",[_._v("指标")]),_._v(" "),r("th",[_._v("什么时候使用")]),_._v(" "),r("th",[_._v("实时应用场景")]),_._v(" "),r("th",[_._v("失效场景")])])]),_._v(" "),r("tbody",[r("tr",[r("td",[_._v("Accuracy@N")]),_._v(" "),r("td",[_._v("当关心在前N个结果中至少有一个推荐是正确的")]),_._v(" "),r("td",[_._v("在信息检索中，只需在前N个结果中找到一个正确答案时适用")]),_._v(" "),r("td",[_._v("无法关注相关项在前N个结果中的具体位置")])]),_._v(" "),r("tr",[r("td",[_._v("MRR@10")]),_._v(" "),r("td",[_._v("当关心相关项在列表中出现的速度时使用")]),_._v(" "),r("td",[_._v("适用于问答系统，希望相关答案尽可能排在前N个结果的顶部")]),_._v(" "),r("td",[_._v("只考虑相关项的位置，而不考虑其相关性，例如在网页搜索中，搜索结果的排序有时需要基于更高的相关性")])]),_._v(" "),r("tr",[r("td",[_._v("nDCG")]),_._v(" "),r("td",[_._v("当关心所有项的质量且它们的顺序很重要时使用")]),_._v(" "),r("td",[_._v("推荐系统或信息检索中，需要关注推荐项的顺序和质量")]),_._v(" "),r("td",[_._v("假设高度相关的项在列表中出现得越靠前越有用，这在某些情况下可能不适用")])])])]),_._v(" "),r("h3",{attrs:{id:"_11-hybrid-search的工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-hybrid-search的工作原理"}},[_._v("#")]),_._v(" 11. Hybrid Search的工作原理")]),_._v(" "),r("blockquote",[r("p",[_._v("Hybrid Search结合了向量搜索和关键字(稀疏)搜索的优势。包含 稠密 和 稀疏")])]),_._v(" "),r("ul",[r("li",[_._v("向量搜索的优势， 找到与query 最相似的信息、")]),_._v(" "),r("li",[_._v("关键字搜索的优势在于， 精确性")])]),_._v(" "),r("p",[_._v("在实际查询中，会使用向量搜索和关键字搜索分别检索前K个结果块。\n使用 RRF做一个融合， 输出融合后的列表")]),_._v(" "),r("h3",{attrs:{id:"_12-假设有多个方法生成的搜索结果-你会如何将它们合并并统一排名-得到一个单一的结果集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-假设有多个方法生成的搜索结果-你会如何将它们合并并统一排名-得到一个单一的结果集"}},[_._v("#")]),_._v(" 12. 假设有多个方法生成的搜索结果,你会如何将它们合并并统一排名, 得到一个单一的结果集?")]),_._v(" "),r("ul",[r("li",[_._v("RRF: 倒数排名融合")])]),_._v(" "),r("h3",{attrs:{id:"_13-如何处理multi-hop-multifaceted查询"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_13-如何处理multi-hop-multifaceted查询"}},[_._v("#")]),_._v(" 13. 如何处理multi-hop/multifaceted查询?")]),_._v(" "),r("ul",[r("li",[_._v("处理多跳问答(MHQA)任务，是回答涉及多个信息片段和多步骤推理的自然语言问题")])]),_._v(" "),r("h2",{attrs:{id:"大语言模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大语言模型"}},[_._v("#")]),_._v(" 大语言模型")]),_._v(" "),r("h3",{attrs:{id:"_1-self-attention"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-self-attention"}},[_._v("#")]),_._v(" 1. Self-Attention")]),_._v(" "),r("p",[_._v("自注意力机制， QK相乘，求相似度，做一次缩放， 然后归一化处理， 然后和 V 进行加权求和\n自注意力机制的缺点")]),_._v(" "),r("h4",{attrs:{id:"_1-1-self-attention-机制的缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-self-attention-机制的缺点"}},[_._v("#")]),_._v(" 1.1 Self-Attention 机制的缺点？")]),_._v(" "),r("h3",{attrs:{id:"_2-transformer-在计算和内存上消耗巨大-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-transformer-在计算和内存上消耗巨大-为什么"}},[_._v("#")]),_._v(" 2. Transformer 在计算和内存上消耗巨大，为什么")]),_._v(" "),r("p",[_._v("MHA 多头注意力机制")]),_._v(" "),r("p",[_._v("带来的开销，每个头都有自己独立的线性层， QKV 矩阵，每次解码都需要加载解码器权重")]),_._v(" "),r("p",[_._v("为了缓解MHA内存瓶颈")]),_._v(" "),r("p",[_._v("MQA，GQA")]),_._v(" "),r("h3",{attrs:{id:"_3-如何增加-llm的-上下文长度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何增加-llm的-上下文长度"}},[_._v("#")]),_._v(" 3. 如何增加 LLM的 上下文长度")]),_._v(" "),r("ul",[r("li",[_._v("ALiBi, 两阶段训练法")])]),_._v(" "),r("h3",{attrs:{id:"_4-什么是位置编码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是位置编码"}},[_._v("#")]),_._v(" 4. 什么是位置编码")]),_._v(" "),r("blockquote",[r("p",[_._v("当我们将文本输入模型时，往往会忽略输入序列中单词的顺序")])]),_._v(" "),r("p",[_._v("举个幽默性的例子：\neg: 狗咬了我  和 我咬了狗， 在模型看来，是一样的，这是灾难性的")]),_._v(" "),r("ul",[r("li",[_._v("Transformer 模型，与之前的RNN 和 LSTM 不同，"),r("strong",[_._v("Transformer 不按顺序处理数据")]),_._v("，而是并行处理输入。")]),_._v(" "),r("li",[_._v("因此，我们需要位置编码来告诉模型，"),r("strong",[_._v("输入序列中各个单词的顺序")]),_._v("。")])]),_._v(" "),r("blockquote",[r("p",[_._v("注意： 位置编码在 transformer 模型架构中的位置，")])]),_._v(" "),r("ul",[r("li",[_._v("输入转为 embedding，添加位置信息，使模型更好地理解每个词的位置。")])]),_._v(" "),r("h3",{attrs:{id:"_5-transformer-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-transformer-架构"}},[_._v("#")]),_._v(" 5. Transformer 架构")]),_._v(" "),r("blockquote",[r("p",[_._v("Transformer 模型包含两个主要部分: "),r("code",[_._v("Encoder(编码器)")]),_._v(" 和 "),r("code",[_._v("Decoder (解码器）")])])]),_._v(" "),r("p",[_._v("是一种用于"),r("strong",[_._v("理解数据序列的神经网络架构")]),_._v(", 广泛应用于NLP任务。因为其可扩展性和处理长距离依赖的能力而闻名。")]),_._v(" "),r("h3",{attrs:{id:"架构图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#架构图"}},[_._v("#")]),_._v(" 架构图")]),_._v(" "),r("p",[r("img",{attrs:{src:"/hmblog/images/llm/transformer/transformer.png",alt:"transformer"}})]),_._v(" "),r("h4",{attrs:{id:"encoder-编码器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#encoder-编码器"}},[_._v("#")]),_._v(" Encoder(编码器)")]),_._v(" "),r("ol",[r("li",[_._v("步骤1: Encoder接收输入序列(例如一种语言的句子)并将其转换为连续表示序列。该序列将作为Decoder生成输出的基础。"),r("strong",[_._v("在标准架构图中, Encoder位于左侧模块。")])]),_._v(" "),r("li",[_._v("步骤2: 输入文本首先被转换为"),r("code",[_._v("word embeddings")]),_._v(", 这些向量表示能够捕捉词汇的语义信息。")]),_._v(" "),r("li",[_._v("步骤3: 向embeddings注入"),r("code",[_._v("positional encoding")]),_._v(", 以标识"),r("code",[_._v("词汇在序列中的位置信息")]),_._v("及词问相对距离。")]),_._v(" "),r("li",[_._v("步骤4: 每个编码块包含两个核心子模块:multi-head attention机制与positionwise feed-forward network\n(原论文采用6个这样的块结构)。")]),_._v(" "),r("li",[_._v("步骤5: 需特别注意,每个子模块均采用"),r("strong",[_._v("残差连接")]),_._v("并接入normalization层, 该设计能有效促进深层模型训练并稳定学习过程。")])]),_._v(" "),r("p",[_._v("上述流程描述的是单个Encoder的处理过程。Encoder最终输出的向量维度与输入维度保持一致,实际应用中可将多个Encoder进行堆叠使用。")]),_._v(" "),r("h3",{attrs:{id:"decoder-解码器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#decoder-解码器"}},[_._v("#")]),_._v(" Decoder(解码器)")]),_._v(" "),r("ol",[r("li",[_._v("步骤1: Decoder生成输出序列(如另一种语言的句子),"),r("strong",[_._v("一次生成一个词")]),_._v("。它基于encoder输出的连续表示序列和先前生成的符号来生成下一个符号。"),r("strong",[_._v("Decoder在架构图的右侧。")])]),_._v(" "),r("li",[_._v("步骤2: Decoder也由多个相同的层组成(paper中设计为6层), 但额外添加了一个多头注意力机制来关注编码器的输出。")]),_._v(" "),r("li",[_._v("步骤3: 首个子模块采用masked multi-head self-attention机制,通i过masking确保对特定位置的预测不会依赖\n后续位置信息。")]),_._v(" "),r("li",[_._v('步骤4: 架构图中可见接收Encoder输出的multi-head attenticon模块,该模块被称作"encoder-decoder\nattention",其keys与values向量源于Encoder。')]),_._v(" "),r("li",[_._v('步骤5: 第二个子模块对Encoder输出执行multi-head attenticn计算-keys与values取自Encoder输出,而\nqueries来自前一层Decoder的输出。例如预测"am"时,"I"将作为query与key,values则来自Encoder')]),_._v(" "),r("li",[_._v('步骤6: 以生成翻译结果"Iam..."为例,Decoder首先生成"I",随后将该结果回传至Decoder网络以生成后续词\n汇"am"(对应架构图中Decoder模块的"Outputs"流向)。')]),_._v(" "),r("li",[_._v("步骤7: Decoder中的multi-head attention机制存在特殊约束:由于输出序列不完整,注意力仅允许关注输出\n序列中已生成的位置(通过将未来位置得分设置为负无穷实现)。")]),_._v(" "),r("li",[_._v('步骤8: Decoder内的"encoder-decoder attention"运作方式与常规attention类似,但其query矩阵来自下层\nDecoder输出,keys与values向量则取自Encoder堆栈的最终输出。')])]),_._v(" "),r("h3",{attrs:{id:"最终层和softmax层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最终层和softmax层"}},[_._v("#")]),_._v(" 最终层和Softmax层")]),_._v(" "),r("ul",[r("li",[r("p",[_._v("logits、概率分布 等等字眼")])]),_._v(" "),r("li",[r("p",[_._v("步骤1:Decoder堆栈的最终输出为一个浮点数向量。")])]),_._v(" "),r("li",[r("p",[_._v("步骤2:通过未端Linear层与Softmax层将该向量转换为具体单词。")])]),_._v(" "),r("li",[r("p",[_._v("步骤3:Linear层作为基础神经网络层,将Decoder输出向量转换为维度更大的logits向量。")])]),_._v(" "),r("li",[r("p",[_._v('步骤4:假设模型从训练数据中学得10,000个唯一英语单词,这些词洞汇构成模型的"输出词汇表"。')])]),_._v(" "),r("li",[r("p",[_._v("步骤5:此时logits向量将包含10,000个数值位,每个位置对)应输出词汇表中一个特定词的得分。")])]),_._v(" "),r("li",[r("p",[_._v("步骤6:Softmax层将这些得分转换为概率分布:所有概率值为正数且总和为1.0。")])]),_._v(" "),r("li",[r("p",[_._v("步骤7:选择概率最高的位置,该位置对应的单词即作为当前步骤的最终输出。")])]),_._v(" "),r("li",[r("p",[_._v("步骤8:当模型识别到"),r("code",[_._v("<end of sentence>")]),_._v("标记时, "),r("strong",[_._v("此生成过程终止")])])])]),_._v(" "),r("h3",{attrs:{id:"损失函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#损失函数"}},[_._v("#")]),_._v(" 损失函数")]),_._v(" "),r("p",[_._v("在已理解Transformer模型训练机制及端到端翻译流程的基础上, 我们现在重点解析如何通过损失函数计算，来优化模型训练:")]),_._v(" "),r("ul",[r("li",[_._v('步骤1: 模型训练从简单样本开始,例如将法语词"merci"翻译为英语词"thanks"')]),_._v(" "),r("li",[_._v('步骤2: 期望模型输出能明确指示目标词"thanks"的概率分布,但由于模型尚未充分训练,此目标暂时无法实现')]),_._v(" "),r("li",[_._v("步骤3: 模型参数(权重)经随机初始化后,未训练模型会为每个词汇生成具有随机数值的概率分布。通过"),r("strong",[_._v("反向传播")]),_._v("算法,我们将比较"),r("strong",[_._v("实际输出与期望输出")]),_._v("的差异,并据此调整模型权重使输出逐步逼近目标")]),_._v(" "),r("li",[_._v("步骤4: 两个概率分布的比较采用差值计算方法, (此为简化说明,具体实现可参考"),r("strong",[_._v("交叉熵")]),_._v("与 "),r("strong",[_._v("Kullback-Leibler散度(KL 散度)")]),_._v(" 等概念)")]),_._v(" "),r("li",[_._v('步骤5: 实际训练场景通常使用多词长句,例如输入"je suis étudiant"时期望输出"Iamastudent"。要求模型成功输出特定维度(词汇表大小,通常为30,000至50,000量级)的概率布向量')]),_._v(" "),r("li",[_._v('步骤6: 每个概率分布应在序列正确词位呈现最高概率值(如第一个分布中"i"概率最高,第二个分布中"am"概率最高,依此类推)')]),_._v(" "),r("li",[_._v("步骤7: 在足够数据集上经过充分训练后,我们期望模型输出正确翻译。注意,即使某些词在当前时间步输出可能性极低,它们仍会获得微小概率值--这是softmax函数的优势特性,有助于训练过程稳定进行")]),_._v(" "),r("li",[_._v('步骤8: 模型以逐时间步方式生成输出。若始终从概率分布中选择最高概率词项而忽略其他选项,该方法称为"贪心解码"')]),_._v(" "),r("li",[_._v('步骤9: 另一种"集束搜索"方法会'),r("strong",[_._v("保留前K个候选词")]),_._v("(例如top2),在下一时间步分别进行多次前向推理(假设首输\n出为'T或'a'), 综合评估多个位置的误差后保留最优路径。该方法始终在内存中维护两个局部假设(未完整翻译结\n果),最终返回两个翻译版本。保留的候选词数量与返回结果数量"),r("strong",[_._v("均为可调整的超参数")])])]),_._v(" "),r("h3",{attrs:{id:"_6-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-2"}},[_._v("#")]),_._v(" 6.")]),_._v(" "),r("h3",{attrs:{id:"_7-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-2"}},[_._v("#")]),_._v(" 7.")]),_._v(" "),r("h3",{attrs:{id:"_8-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3"}},[_._v("#")]),_._v(" 8.")]),_._v(" "),r("h3",{attrs:{id:"_9-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2"}},[_._v("#")]),_._v(" 9.")]),_._v(" "),r("h3",{attrs:{id:"_10-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-2"}},[_._v("#")]),_._v(" 10.")]),_._v(" "),r("h2",{attrs:{id:"transformer-相关-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformer-相关-2"}},[_._v("#")]),_._v(" Transformer 相关")]),_._v(" "),r("h3",{attrs:{id:"_1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[_._v("#")]),_._v(" 1.")]),_._v(" "),r("h3",{attrs:{id:"_2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2"}},[_._v("#")]),_._v(" 2.")]),_._v(" "),r("h3",{attrs:{id:"_3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3"}},[_._v("#")]),_._v(" 3.")]),_._v(" "),r("h3",{attrs:{id:"_4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4"}},[_._v("#")]),_._v(" 4.")]),_._v(" "),r("h3",{attrs:{id:"_5-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2"}},[_._v("#")]),_._v(" 5.")]),_._v(" "),r("h3",{attrs:{id:"_6-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-3"}},[_._v("#")]),_._v(" 6.")]),_._v(" "),r("h3",{attrs:{id:"_7-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-3"}},[_._v("#")]),_._v(" 7.")]),_._v(" "),r("h3",{attrs:{id:"_8-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-4"}},[_._v("#")]),_._v(" 8.")]),_._v(" "),r("h3",{attrs:{id:"_9-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3"}},[_._v("#")]),_._v(" 9.")]),_._v(" "),r("h3",{attrs:{id:"_10-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-3"}},[_._v("#")]),_._v(" 10.")]),_._v(" "),r("h2",{attrs:{id:"transformer-相关-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transformer-相关-3"}},[_._v("#")]),_._v(" Transformer 相关")]),_._v(" "),r("h3",{attrs:{id:"_1-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2"}},[_._v("#")]),_._v(" 1.")]),_._v(" "),r("h3",{attrs:{id:"_2-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2"}},[_._v("#")]),_._v(" 2.")]),_._v(" "),r("h3",{attrs:{id:"_3-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2"}},[_._v("#")]),_._v(" 3.")]),_._v(" "),r("h3",{attrs:{id:"_4-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2"}},[_._v("#")]),_._v(" 4.")]),_._v(" "),r("h3",{attrs:{id:"_5-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-3"}},[_._v("#")]),_._v(" 5.")]),_._v(" "),r("h3",{attrs:{id:"_6-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-4"}},[_._v("#")]),_._v(" 6.")]),_._v(" "),r("h3",{attrs:{id:"_7-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-4"}},[_._v("#")]),_._v(" 7.")]),_._v(" "),r("h3",{attrs:{id:"_8-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5"}},[_._v("#")]),_._v(" 8.")]),_._v(" "),r("h3",{attrs:{id:"_9-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-4"}},[_._v("#")]),_._v(" 9.")]),_._v(" "),r("h3",{attrs:{id:"_10-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-4"}},[_._v("#")]),_._v(" 10.")])])}),[],!1,null,null,null);r.default=e.exports}}]);